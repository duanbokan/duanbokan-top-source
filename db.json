{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"4362db79ed2489fb65cda63a99f1d7bb61d2ffdb","modified":1607496073460},{"_id":"source/_posts/20150112单节点配置FastDFS.markdown","hash":"a21a18066aedf1444367a3ed57e3885779e70b3e","modified":1607494590330},{"_id":"source/_posts/20150225Android集成OCR实现文字识别.md","hash":"7f05e8c02bd9e598ef6c1d33de7fb189e0672553","modified":1607499762440},{"_id":"source/_posts/20150202Android环境String.xml文件中空格的处理.markdown","hash":"98173d15aeeae21873e527d96749fd73e5c2b1e9","modified":1520929348000},{"_id":"source/_posts/20150905Fragment中ListView.setOnItemClickListener失效的问题.markdown","hash":"81664baf67658973803f38e5f25088812212c2d9","modified":1607495210930},{"_id":"source/_posts/20150902FindBugs安装及使用.markdown","hash":"d7c1ccacc3195feb473faa72c1d0cba39cb990d0","modified":1607495188950},{"_id":"source/_posts/20150302LogCatUtil.markdown","hash":"ec0844ea061c5649fea6479a5603a47f4e8f056b","modified":1607495156550},{"_id":"source/_posts/20151016Android使用SQLite批量入库操作性能对比.markdown","hash":"49dc19f71709a9aad70e646a791305d0080e3ec6","modified":1607495266170},{"_id":"source/_posts/20151218Android_横竖屏切换生命周期.md","hash":"8b4e96f5a48c2d6dc5a08b457bdbc71d831a31b8","modified":1607495302520},{"_id":"source/_posts/20160225Android平台OCR工具之Tess-two使用.markdown","hash":"f5810a5e86730875efdcca2adfff4bf3a9041652","modified":1607495360130},{"_id":"source/_posts/20160303Linux下搭建Bouncycastle环境.md","hash":"288cd87fd969b494bbcd09fa4c9384c3899bd76d","modified":1607495389770},{"_id":"source/_posts/20160310Https单双向认证.md","hash":"f29f621a36bcc019cba1ed60650eb44f5d384e32","modified":1607495419460},{"_id":"source/_posts/20160106EventBus简介及使用.markdown","hash":"2457d15665d4742797a8bcf66b323cb07d91ca8c","modified":1607495322590},{"_id":"source/_posts/20160317Android6.0握手失败问题.md","hash":"d4852c289b28773db220fd985056ac3b1f75deb1","modified":1607495457610},{"_id":"source/_posts/20160422AndroidStudio中使用Eclipse配置.md","hash":"638c5dadbafaaed5535e002615d18176b2922f0e","modified":1607495517050},{"_id":"source/_posts/20160513Android更新机制.md","hash":"1032ee8e8f97aeda032b208cd37293fc4bafc511","modified":1607495563010},{"_id":"source/_posts/20160331Android下使用Protobuf进行序列化.md","hash":"e67f501648b5d68f5ce13b8ed9d245568a3abe3a","modified":1607495491430},{"_id":"source/_posts/20160429Android开发中使用CRC校验.md","hash":"15eef3a2f37ca984ec2194d8d12db2865bd382f3","modified":1607495536130},{"_id":"source/_posts/20160623Android自动化测试——Monkey.md","hash":"0e5098e077c7cdb92fc8c4c5584fde2df840a930","modified":1607495600700},{"_id":"source/_posts/20171221IJKPlayer使用SeekTo跳转关键帧不正确.markdown","hash":"d436881de8ab5b67a02cdc6b1c39d2842f3c51c3","modified":1607495750450},{"_id":"source/_posts/20160623Android自动化测试——MonkeyRunner.md","hash":"357956d04ba25d436c61e8881eb2b8b18c0c8d0e","modified":1607495666300},{"_id":"source/_posts/20171211HEIF图片存储格式探秘.markdown","hash":"2eb05b549bd36f99501609107784f39005151426","modified":1650352137360},{"_id":"source/_posts/20180104集成ReactNative到已有工程.markdown","hash":"588021d2b2dc5e8580932af3a802a85fbe39cd71","modified":1607495809320},{"_id":"source/about/index.md","hash":"c5f423a34cb1973e13ca2b9151f277594006a879","modified":1607499110930},{"_id":"source/about/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1575464624150},{"_id":"source/_posts/20191128Flutter—Json数据格式化.md","hash":"57b0873cbd52bffe3e9395016578283682d5b59c","modified":1650352408477},{"_id":"source/categories/index.md","hash":"f2520e6abb6a4ab7e572ebddbda65437dac64381","modified":1575464667660},{"_id":"source/.DS_Store","hash":"8b7ccf1c9fee932d35d405635571c0268066a013","modified":1720613513371},{"_id":"source/_posts/20170710TienLen游戏算法——斗地主算法.md","hash":"ab20fb66f1f2f4580556e0320a963094a9888854","modified":1607495696010},{"_id":"source/_posts/Flutter状态管理框架.md","hash":"50b65a371d1854a19bf44e271d94708353cd4db9","modified":1650352607224},{"_id":"source/link/index.md","hash":"abd286f826ea87b9216c8a823b5156a8f3d69777","modified":1575467357330},{"_id":"source/categories/.DS_Store","hash":"0e7047f2cbd060576f606d294347c65b7179700c","modified":1575465143700},{"_id":"source/link/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1575467384920},{"_id":"themes/butterfly/package.json","hash":"80ebdf46caa7266fc43cd51c96c97731adbc5694","modified":1650365925859},{"_id":"themes/butterfly/README.md","hash":"6ee27baf95a5741abbc224ef8938d679b6597665","modified":1650365925838},{"_id":"themes/butterfly/README_CN.md","hash":"49ace5208f98783344f17a00adab7641cda43280","modified":1650365925838},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1650365925838},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1650365925837},{"_id":"themes/butterfly/languages/default.yml","hash":"7fd2950554e99a6f15232267621f36f026a85380","modified":1650365925839},{"_id":"themes/butterfly/languages/en.yml","hash":"4b2c351f2b5fd4f8497e806085364928e1af0b5b","modified":1650365925839},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"6c35255c196ea8e9817b85b6d7729d00cf18f231","modified":1650365925839},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1650365925840},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ef035065ebb37fce3e56e51f8b56deb596db78b2","modified":1650365925840},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1650365925840},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1650365925859},{"_id":"themes/butterfly/_config.yml","hash":"15e54e3f0a925801216873233efa2790ca901aa1","modified":1650426901922},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1650365925859},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1650365925859},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1650365925859},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1650365925837},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1650365925860},{"_id":"themes/butterfly/scripts/events/init.js","hash":"a7f567b3d3110afe2f99c967b8e15351a7f5bd6d","modified":1650365925860},{"_id":"themes/butterfly/scripts/events/config.js","hash":"a72c2020c87c4998aa124a16e9f8560875b9f86d","modified":1650365925860},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1650365925860},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1650365925837},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1650365925836},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1650365925860},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1650365925861},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1650365925860},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1650365925861},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1650365925861},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"6a103a2472903289bdecd5240eb89cac0b9e13d9","modified":1650365925861},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"21556f9cb412ddc500ad12ecfd419f3ea6c9f663","modified":1650365925861},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1650365925860},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1650365925861},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1650365925862},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1650365925862},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1650365925837},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1650365925841},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1650365925841},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"847a5cbc13db1a435a4f762a7c0007d9bcbb79a2","modified":1650365925842},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"ab3bdeb6e0acd3d58091698c1335afb069eea7e5","modified":1650365925841},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"f093ab771257a6a939b194f68607a2038c8d7da3","modified":1650365925849},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1650365925848},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1650365925845},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1650365925847},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1650365925871},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1650365925870},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1650365925871},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1650365925870},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1650365925873},{"_id":"themes/butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1650365925873},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1650365925871},{"_id":"themes/butterfly/source/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1650365925872},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1650365925844},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1650365925844},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"dc3913c1a6dd207051c3d3414a33851ae8bc0a45","modified":1650365925845},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1650365925844},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1650365925845},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1650365925846},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1650365925845},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1650365925847},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1650365925847},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1650365925847},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1650365925847},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1650365925848},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1650365925848},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1650365925846},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1650365925846},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0380a1e048e6219ea4b4a8a4eadba960edf308f0","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1650365925858},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1650365925859},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1650365925842},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1650365925859},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1650365925842},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1650365925843},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1650365925843},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"9e58c80af8bbd0c66ccb4f94d3781818cebf0d66","modified":1650365925842},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1650365925843},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1650365925843},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1650365925843},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1650365925844},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1650365925856},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"d4072f9ab79f4ac49aa251ae470abc45a2fddbd6","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"b63fd8ec48d782f51ee11226753fed1998bbf34a","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1650365925849},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f7fd855593396b30932a06627287a73a407aff88","modified":1650365925863},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1650365925864},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1650365925863},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1650365925863},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1650365925864},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1650365925864},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"2d3b0386c8b62a61734e10bab2cf86842cbb1673","modified":1650365925864},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"84d4f27fde933bdf839629eb3bddcbc0f4592836","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1650365925865},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1650365925866},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"1bcbc80dff19cd53d0b367c3b9a3c751d3a1f10d","modified":1650365925866},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"e5008f43897d8482b4831cd4c13a0af40e496762","modified":1650365925866},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"f67177310f5594954b25a591d186d28d5d450b18","modified":1650365925866},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1650365925866},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1650365925866},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1650365925867},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1650365925867},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1650365925867},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1650365925867},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1650365925867},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1650365925867},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"656f9007d94cf29a20532705d94fb7f22827e6fe","modified":1650365925868},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0290605c4984882990059eefe3ad18d2ac6a19ef","modified":1650365925868},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"e4c987c0202162b50dec91e1df74665d0fa933c9","modified":1650365925868},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1650365925868},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1650365925868},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1650365925869},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1650365925870},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1650365925870},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"fe684aaad4c99b908dc4499c85afd9a2cd893aae","modified":1650365925852},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"ec62117f38e095425f295b1170c222c7a1399425","modified":1650365925872},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1650365925872},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1650365925852},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"143236e395c18d80ab8dc794821eb337c85f6b32","modified":1650365925852},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"0764709381fa29778f6390d645ed137d2f91228f","modified":1650365925852},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"9c96e6e67931977268b218b99084b98597c2e42b","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"c1c75abe5c899618ed6699c97ac999544840098a","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"c271cacbac14ed665bbf47aa9c6e74e94c69dcef","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"59c22ebf3aaee90152e7cdb17ff5841c888fcd82","modified":1650365925853},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7648e4cb0b224f480b5f1356d64f62c9235f6723","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1650365925849},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1650365925849},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1650365925850},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1650365925850},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1650365925850},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1650365925850},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1650365925851},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1650365925851},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1650365925851},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1650365925850},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1650365925851},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1650365925851},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"0a7587a0211011b5942edba2aa80d51169561d30","modified":1650365925854},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"ac811c1d6e0bf08aeb933ade1b9557e0c560d0c9","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"8ce336a4c8cae81b58ee26ff51040ca650ff1519","modified":1650365925856},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"c92df4f9d0611cf44c1a4491e226f242ec80f5bb","modified":1650365925856},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"5e32d903903c76db55a625640f9417d15a3a312f","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"9028efac78e4122acd734edd5ef9110ef3f05cd1","modified":1650365925855},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1650365925856},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1650365925856},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1650365925857},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1650365925857},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1650365925863},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1650365925863},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1650365925864},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1650365925864},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1650365925864},{"_id":"public/sitemap.xml","hash":"a5f43efa5b2d325c3e75723067037bd96f67f6d1","modified":1650438632587},{"_id":"public/sitemap.txt","hash":"b8faf015a84fb5770e885a240cf9560410c076a7","modified":1650438632587},{"_id":"public/atom.xml","hash":"c2e3f3b1be88dea8ca5b44b7c5b1cd8131b58d9a","modified":1650438632587},{"_id":"public/about/index.html","hash":"b00b0a92949c26588cdc5ec94b54af950208c5b3","modified":1650438632587},{"_id":"public/categories/index.html","hash":"e0c9e5032ea2fe0c23f448f185cc7c4ad5f86c88","modified":1650438632587},{"_id":"public/link/index.html","hash":"d513a59994ccd076ee55af49cc5e31636a7639f3","modified":1650438632587},{"_id":"public/2022/04/19/Flutter状态管理框架/index.html","hash":"8990b2a26c71cbab7ad6552fce80cbcd2cfa86c7","modified":1650438632587},{"_id":"public/2019/11/28/20191128Flutter—Json数据格式化/index.html","hash":"66fceded8ed0fbbd65172ce94cbb982f9ab671e7","modified":1650438632587},{"_id":"public/2018/01/04/20180104集成ReactNative到已有工程/index.html","hash":"555fdc5aa00deefab71b210d2d055923028abc34","modified":1650438632587},{"_id":"public/2017/12/21/20171221IJKPlayer使用SeekTo跳转关键帧不正确/index.html","hash":"b75254d1252642a2b170f429b27cde6be17d8e1d","modified":1650438632587},{"_id":"public/2017/12/11/20171211HEIF图片存储格式探秘/index.html","hash":"8d9d12858da4b6b978dd95795599f4f0fd388a0a","modified":1650438632587},{"_id":"public/2017/07/10/20170710TienLen游戏算法——斗地主算法/index.html","hash":"59dd6aca8c0beda76ba9ca8b17105b6eef8c3da8","modified":1650438632587},{"_id":"public/2016/06/23/20160623Android自动化测试——Monkey/index.html","hash":"0945792f6f76986376efaefbb81c4ecbaa8373c9","modified":1650438632587},{"_id":"public/2016/06/23/20160623Android自动化测试——MonkeyRunner/index.html","hash":"d7ce088dd96a4f049eb7ad12241d575e83ee0431","modified":1650438632587},{"_id":"public/2016/05/13/20160513Android更新机制/index.html","hash":"4a0e78d21ae8cc17004d281d432ac7ddd56fd44b","modified":1650438632587},{"_id":"public/2016/04/29/20160317Android6.0握手失败问题/index.html","hash":"8414585a2fd1f437dfeac7baf38fadff43b8633c","modified":1650438632587},{"_id":"public/2016/04/29/20160429Android开发中使用CRC校验/index.html","hash":"a2f3a7c19b70d2c94bb6b2cd2e927102837d30d6","modified":1650438632587},{"_id":"public/2016/04/22/20160422AndroidStudio中使用Eclipse配置/index.html","hash":"3d04e160c8e057ee092c7c7e67ac48305b32f3e6","modified":1650438632587},{"_id":"public/2016/03/31/20160331Android下使用Protobuf进行序列化/index.html","hash":"a8da86bc04a51e1832b277d92b9a63fefebbbfd4","modified":1650438632587},{"_id":"public/2016/03/10/20160310Https单双向认证/index.html","hash":"e40d12071fe73024582d04f4c13b463e39d48d79","modified":1650438632587},{"_id":"public/2016/03/03/20160303Linux下搭建Bouncycastle环境/index.html","hash":"8afeea05eb6704394dc8a29bcd6afb0548371713","modified":1650438632587},{"_id":"public/2016/02/25/20150225Android集成OCR实现文字识别/index.html","hash":"861a7cd8a9f277643808d2990bcc2455e305ae1c","modified":1650438632587},{"_id":"public/2016/02/25/20160225Android平台OCR工具之Tess-two使用/index.html","hash":"4b374196e3ca34c60135679901b81df928e4b03e","modified":1650438632587},{"_id":"public/2016/01/06/20160106EventBus简介及使用/index.html","hash":"ca910a1168639820b3f2c9fe5b6c943f4b7aabc3","modified":1650438632587},{"_id":"public/2015/12/18/20151218Android_横竖屏切换生命周期/index.html","hash":"dc2ab2fda30715154d40109856ea65f6821b90a0","modified":1650438632587},{"_id":"public/2015/10/16/20151016Android使用SQLite批量入库操作性能对比/index.html","hash":"4127687cb9e55416c37f091669939d1301346665","modified":1650438632587},{"_id":"public/2015/09/15/20150905Fragment中ListView.setOnItemClickListener失效的问题/index.html","hash":"af66e63fc2225831e44dd8ddd2d42597cb159991","modified":1650438632587},{"_id":"public/2015/09/02/20150902FindBugs安装及使用/index.html","hash":"263a0adb5795ab35c368f140fe0c9bbc30c7cbc0","modified":1650438632587},{"_id":"public/2015/03/02/20150302LogCatUtil/index.html","hash":"666a63b82b08d0dcb43f08caa69c3f251d00c5a3","modified":1650438632587},{"_id":"public/2015/02/02/20150202Android环境String.xml文件中空格的处理/index.html","hash":"7f743bcc9db5d01f24697a3d32fc8ed2f4582a9e","modified":1650438632587},{"_id":"public/2015/01/12/20150112单节点配置FastDFS/index.html","hash":"3c8ed38db13f12c1b95293d0dfe14af45ca13ab6","modified":1650438632587},{"_id":"public/categories/FastDFS/index.html","hash":"7baee87770947a5341b76a92c57f79ff9a923d23","modified":1650438632587},{"_id":"public/categories/Android/index.html","hash":"35b693948b9bb95d551c0ea2a7fd4517e11d0633","modified":1650438632587},{"_id":"public/categories/Android/page/2/index.html","hash":"80b7e3a854321e1f4bb21c9f6dee0e27c0274e99","modified":1650438632587},{"_id":"public/categories/Android/问题记录/index.html","hash":"dbf150f26503d0fd83eb02b791fa186884fb1d2c","modified":1650438632587},{"_id":"public/categories/Https/index.html","hash":"7941f8253889eb596b8d487f280152f441f4c1cf","modified":1650438632587},{"_id":"public/categories/Android/HEIF/index.html","hash":"0be0d0efef5841f5bb228848fa5c3eba35ed262c","modified":1650438632587},{"_id":"public/categories/ReactNative/index.html","hash":"25d5276739746eed9720ecc9341f96511bc7442b","modified":1650438632587},{"_id":"public/categories/Flutter/index.html","hash":"d8da310c8877c45068d95edb2f5fc316fec07657","modified":1650438632587},{"_id":"public/archives/index.html","hash":"5cfdf009112d37c93eba64adbbc6922740682884","modified":1650438632587},{"_id":"public/archives/page/2/index.html","hash":"4c6e963f97c30f98d2d5fba89ecca05f5498fb5a","modified":1650438632587},{"_id":"public/archives/page/3/index.html","hash":"5ddf6a18b164e7b82f19e81b5f8c149f69b13558","modified":1650438632587},{"_id":"public/archives/2015/index.html","hash":"616980add74ce7e997029b963f16c8fc73db14fb","modified":1650438632587},{"_id":"public/archives/2015/01/index.html","hash":"15ee4eac342495ef17b5333bcf673043e5645a43","modified":1650438632587},{"_id":"public/archives/2015/02/index.html","hash":"f6971f9797dc0aaee30d693d0a5735b3e66329f6","modified":1650438632587},{"_id":"public/archives/2015/03/index.html","hash":"665140ccdc302408486be4695388c0b6c97ca8b1","modified":1650438632587},{"_id":"public/archives/2015/09/index.html","hash":"3578f3641b9e30af9380ed7753a48e8772dd687b","modified":1650438632587},{"_id":"public/archives/2015/10/index.html","hash":"2809bf1a5a8a90d073c85988f45b171e22060255","modified":1650438632587},{"_id":"public/archives/2015/12/index.html","hash":"a48672d7e048b214fe9f9cb97d4499172664faae","modified":1650438632587},{"_id":"public/archives/2016/index.html","hash":"8be0c45da4eda5a014816c23c4f044548bf37a29","modified":1650438632587},{"_id":"public/archives/2016/page/2/index.html","hash":"148126602e85f83653f1fd803122d8589b9e8d5f","modified":1650438632587},{"_id":"public/archives/2016/01/index.html","hash":"fb9b2483a62d27b02e9b35c2689a137d55aae45e","modified":1650438632587},{"_id":"public/archives/2016/02/index.html","hash":"ebfd10e734a3a6200c3f49b05a7514824a941cd8","modified":1650438632587},{"_id":"public/archives/2016/03/index.html","hash":"ec5c1abc357985b355db8b653830a1cdace180e2","modified":1650438632587},{"_id":"public/archives/2016/04/index.html","hash":"924f1be62e6275fb1c56bf52e2d3b803694eb351","modified":1650438632587},{"_id":"public/archives/2017/index.html","hash":"8a36d49dfa9ad61643590faff816c765f5ca8f07","modified":1650438632587},{"_id":"public/archives/2017/07/index.html","hash":"81c1d09e244b10fb5a07a9b52106292a27a533fc","modified":1650438632587},{"_id":"public/archives/2016/06/index.html","hash":"e93789aefef0c111ca6db157cc5d0debf65dda11","modified":1650438632587},{"_id":"public/archives/2017/12/index.html","hash":"f60a9e7cfa96493f3bbe5ca14ba7ee2c77aa439f","modified":1650438632587},{"_id":"public/archives/2018/index.html","hash":"9025109409011c967529d23b044c5935977b6be2","modified":1650438632587},{"_id":"public/archives/2016/05/index.html","hash":"9d6197da1a944169bb97c2bd8cf5286fea5e6481","modified":1650438632587},{"_id":"public/archives/2018/01/index.html","hash":"be98ea5e2418b3d1182d3e335dffd73c670fb469","modified":1650438632587},{"_id":"public/archives/2019/index.html","hash":"eb3230f48746cb01e85b0a8bef1a27204ac7f0c6","modified":1650438632587},{"_id":"public/archives/2019/11/index.html","hash":"4901f13c8ee9911d45f4045b1aa8426b297582b3","modified":1650438632587},{"_id":"public/archives/2022/index.html","hash":"de08fb5f8be2a4fe115f45122d789a3d01506f44","modified":1650438632587},{"_id":"public/archives/2022/04/index.html","hash":"ae35a4dba8f9e218637d59a1d90afd45260aba22","modified":1650438632587},{"_id":"public/tags/FastDFS/index.html","hash":"7b67edca89bb159114760a11a28279b63dc4bc0e","modified":1650438632587},{"_id":"public/tags/Linux/index.html","hash":"3ec21ff3c19fe1b828e26eb63d54a515e6834bc6","modified":1650438632587},{"_id":"public/tags/数据存储/index.html","hash":"c728a016ab5daa012aa6022f3cb09ce11f858064","modified":1650438632587},{"_id":"public/tags/String-xml空格/index.html","hash":"7c0e2e87de170de8309d58720b35a80f27306595","modified":1650438632587},{"_id":"public/tags/问题记录/index.html","hash":"005a10f707d635946d0c6df029266c4b1b08005f","modified":1650438632587},{"_id":"public/tags/Android/index.html","hash":"f427dfdd449c8d807e1c77596cd8449d96885fab","modified":1650438632587},{"_id":"public/tags/Android/page/2/index.html","hash":"3370dab1b0fbcf4dd70a0d669991cc1cafd32ef0","modified":1650438632587},{"_id":"public/tags/OCR/index.html","hash":"6b528d6d1b3f60a9cf6ce0540769f9954ffafcc4","modified":1650438632587},{"_id":"public/tags/图像识别/index.html","hash":"ec81f0e0a70c7a35f6549ddc8542b8700cb7dc64","modified":1650438632587},{"_id":"public/tags/LogcatUtil/index.html","hash":"4b410b83e7002587bb682cc84a065af023984da5","modified":1650438632587},{"_id":"public/tags/FindBugs/index.html","hash":"e5c097c62d12608bfde52aa0edafdcf39d414aca","modified":1650438632587},{"_id":"public/tags/Android笔记/index.html","hash":"d2ee924beca93f3e7ee74d62e90419cb9d7a3791","modified":1650438632587},{"_id":"public/tags/横竖屏切换/index.html","hash":"7e26826b276cf4605b8d63279be9a0fed6f66e6b","modified":1650438632587},{"_id":"public/tags/生命周期/index.html","hash":"b686a135e0c8f75781ae87f1cb6f6daa4d6eec23","modified":1650438632587},{"_id":"public/tags/SQLite数据库/index.html","hash":"b509c29082ec5a9933e3d5d9dd1fdeef009a7d2d","modified":1650438632587},{"_id":"public/tags/数据库性能/index.html","hash":"c54c43203aafff18d98a9f964684d377f74ff4b6","modified":1650438632587},{"_id":"public/tags/EventBus/index.html","hash":"8249ce6f1a8daa564950f7532d27e42fcda4a32b","modified":1650438632587},{"_id":"public/tags/观察者模式/index.html","hash":"8623a007bd8ff2165bcf50e6bf40a842d2287feb","modified":1650438632587},{"_id":"public/tags/Tess-Two/index.html","hash":"869fa146406f9b52b0b2bc5d76be96739e6f846f","modified":1650438632587},{"_id":"public/tags/Tesseract/index.html","hash":"e81be7c7f7ca7e023dc55a2cdee972df01d8f90d","modified":1650438632587},{"_id":"public/tags/Bouncycast/index.html","hash":"c71d727bfc48496ff39bf60a52df2c9d53ffb3a9","modified":1650438632587},{"_id":"public/tags/Https证书生成/index.html","hash":"96249038c932d06c0bbf06ab7316f62afbeb82f1","modified":1650438632587},{"_id":"public/tags/Https/index.html","hash":"34ab2c25a555de6c317923a12c1ec11e7cf91850","modified":1650438632587},{"_id":"public/tags/Https单向认证/index.html","hash":"66e554a3fec58c96a12c5d74d443c53ae7b188ba","modified":1650438632587},{"_id":"public/tags/Https双向认证/index.html","hash":"ac82936fe594e0149765e967bc2693e1f405d4ac","modified":1650438632587},{"_id":"public/tags/HTTP/index.html","hash":"1cfab05cf199adc4f67385628a99941ab6e876e4","modified":1650438632587},{"_id":"public/tags/Protobuf/index.html","hash":"be602152d30c4fd8bf0ea3c1f1f7859550f6daf3","modified":1650438632587},{"_id":"public/tags/Eclipse/index.html","hash":"b14ae9a7a0775089ce8e280fbbe1e15a1be33f67","modified":1650438632587},{"_id":"public/tags/CRC/index.html","hash":"d222fd985edd6a25b6ccf91ef3f0ca4c8e7478df","modified":1650438632587},{"_id":"public/tags/App更新/index.html","hash":"9f7137b0c2dbef261213c53d0f4c94234eeff0f0","modified":1650438632587},{"_id":"public/tags/Google更新/index.html","hash":"79e87f6a38e364bf6116962680237e7108cb3520","modified":1650438632587},{"_id":"public/tags/自动化测试/index.html","hash":"259d1436857b69bd31719042cc5e8dc320543aea","modified":1650438632587},{"_id":"public/tags/Monkey/index.html","hash":"5ea3fa5787e696aaceafda4ec6b10b30c495e03c","modified":1650438632587},{"_id":"public/tags/MonkeyRunner/index.html","hash":"7bcf0f1ed96783518f076b13e0b883951a1e59c7","modified":1650438632587},{"_id":"public/tags/斗地主/index.html","hash":"319c834836382790be085c3c73e2ff0a82728d14","modified":1650438632587},{"_id":"public/tags/算法/index.html","hash":"d48fcdbb1d1a522cdbf46fcb1c54bf348acf6872","modified":1650438632587},{"_id":"public/tags/IJKPlayer/index.html","hash":"5ce6415371a2f805a5b4a182e189201b8b683209","modified":1650438632587},{"_id":"public/tags/IOS11图片格式/index.html","hash":"c32b366f2bc4562cec51e5a2688f01161a7b9fa2","modified":1650438632587},{"_id":"public/tags/图片存储/index.html","hash":"73081c0173ee83c1c2f5a97a27a2dcd8f7f43f73","modified":1650438632587},{"_id":"public/tags/ReactNative/index.html","hash":"3bb995d0d89d752a546560c4ba5f9473d51c818c","modified":1650438632587},{"_id":"public/tags/集成RN/index.html","hash":"8199cf9b4ab0ef27a57cf5c7ea74571c078f6fa9","modified":1650438632587},{"_id":"public/tags/Flutter/index.html","hash":"0442c2df81bfd25cd1011cfc0fd1fb339fbeb808","modified":1650438632587},{"_id":"public/tags/Json/index.html","hash":"bfb44bf16eecf21b4f51fe78bb5c0259f2fb0bee","modified":1650438632587},{"_id":"public/tags/序列化和反序列化/index.html","hash":"6ffddc1ad707c0d132a78387c8112991f0ac93bb","modified":1650438632587},{"_id":"public/tags/状态管理/index.html","hash":"3d6b34ffa0a278c8154ff8010db4d2ed4b92271c","modified":1650438632587},{"_id":"public/tags/Provider/index.html","hash":"29ec3ef559dc745e65de69a158b2d1841f05c480","modified":1650438632587},{"_id":"public/tags/Stream/index.html","hash":"ffe152eea2f9bc278607199defc5bbd674ef53ae","modified":1650438632587},{"_id":"public/index.html","hash":"d95893d3ca6d4c20fcfa45619ff3dc5053304df6","modified":1650438632587},{"_id":"public/page/2/index.html","hash":"c095a671375d9b558bec4d60a639f923e894e788","modified":1650438632587},{"_id":"public/page/3/index.html","hash":"1c42d9160e788fbdd051ab44c0ff4389282db5f3","modified":1650438632587},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1650438632587},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1650438632587},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1650438632587},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1650438632587},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1650438632587},{"_id":"public/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1650438632587},{"_id":"public/js/search/local-search.js","hash":"ec62117f38e095425f295b1170c222c7a1399425","modified":1650438632587},{"_id":"public/css/index.css","hash":"0d43836914245d492e34d5aa16a894dd77ff673c","modified":1650438632587},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1650438632587},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1650438632587},{"_id":"source/_posts/20231221-HarmonyOS开发—基础—环境搭建.md","hash":"a6d39930ccc47021695c82051b3162660902a746","modified":1720606942176},{"_id":"source/_posts/20240129-HarmonyOS开发—基础—基础组件.md","hash":"e981fd68d8509839a3981a2dc3d2dba86dbab642","modified":1720607042825},{"_id":"source/_posts/20231222-HarmonyOS开发—基础—ArkTS语言介绍.md","hash":"489b8990f2e52fa0b58064809c0333c36d28821c","modified":1720606994418},{"_id":"source/_posts/20240217-HarmonyOS开发—进阶—ArkUI进阶.md","hash":"d1445c366fd8c2f36e3d394cae686a61204c98cf","modified":1720607073314},{"_id":"source/_posts/20231229-HarmonyOS开发—基础—应用程序入口-UIAbility.md","hash":"79580ebe5a698601eb3e04502252954e86e80d7a","modified":1720607028376},{"_id":"source/_posts/20220419Flutter状态管理框架.md","hash":"50b65a371d1854a19bf44e271d94708353cd4db9","modified":1650352607224},{"_id":"source/_posts/20240216-HarmonyOS开发—基础—自定义组件.md","hash":"f968dce13623c51eda85ab5265f5279c5d6f9afa","modified":1720607058045}],"Category":[{"name":"FastDFS","_id":"cl278jurd0004b3t1ht3d438x"},{"name":"Android","_id":"cl278juri000ab3t19zg9fsvh"},{"name":"问题记录","parent":"cl278juri000ab3t19zg9fsvh","_id":"cl278juro000qb3t18bu5gl89"},{"name":"Https","_id":"cl278jurq000zb3t1bg803n4r"},{"name":"HEIF","parent":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurx001sb3t19a5vhpl2"},{"name":"ReactNative","_id":"cl278jurz001zb3t14jxfayeu"},{"name":"Flutter","_id":"cl278jus00026b3t1hs282ncp"},{"name":"HarmonyOS","_id":"clyfsx01c00020nv6gbm2952p"}],"Data":[],"Page":[{"title":"关于","date":"2019-12-01T14:16:15.000Z","_content":"\n![](http://image.jucaiwy.com/image/my_self_1.jpeg)\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于\n\ndate: 2019-12-01 22:16:15\n\n---\n\n![](http://image.jucaiwy.com/image/my_self_1.jpeg)\n\n\n","updated":"2020-12-09T07:31:50.930Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl278jur60000b3t1f5ktaz5w","content":"<p><img src=\"http://image.jucaiwy.com/image/my_self_1.jpeg\"></p>\n","site":{"data":{}},"cover":"http://image.jucaiwy.com/back_001.jpg","excerpt":"","more":"<p><img src=\"http://image.jucaiwy.com/image/my_self_1.jpeg\"></p>\n"},{"title":"分类","date":"2019-12-01T13:53:53.000Z","_content":"\n暂时还未创建分类文件","source":"categories/index.md","raw":"---\ntitle: 分类\n\ndate: 2019-12-01 21:53:53\n\n---\n\n暂时还未创建分类文件","updated":"2019-12-04T13:04:27.660Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl278jurb0002b3t158u71ear","content":"<p>暂时还未创建分类文件</p>\n","site":{"data":{}},"cover":"http://image.jucaiwy.com/back_001.jpg","excerpt":"","more":"<p>暂时还未创建分类文件</p>\n"},{"title":"相关链接","date":"2019-12-01T13:54:05.000Z","_content":"\n\nCSDN: [沙僧](https://me.csdn.net/duanbokan)\n\n微博主页：[沙僧师弟](https://weibo.com/sbook213044)\n\n马蜂窝：[沙僧](http://www.mafengwo.cn/u/93302323.html)","source":"link/index.md","raw":"---\ntitle: 相关链接\n\ndate: 2019-12-01 21:54:05\n\n---\n\n\nCSDN: [沙僧](https://me.csdn.net/duanbokan)\n\n微博主页：[沙僧师弟](https://weibo.com/sbook213044)\n\n马蜂窝：[沙僧](http://www.mafengwo.cn/u/93302323.html)","updated":"2019-12-04T13:49:17.330Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl278jurf0006b3t144htcdek","content":"<p>CSDN: <a href=\"https://me.csdn.net/duanbokan\">沙僧</a></p>\n<p>微博主页：<a href=\"https://weibo.com/sbook213044\">沙僧师弟</a></p>\n<p>马蜂窝：<a href=\"http://www.mafengwo.cn/u/93302323.html\">沙僧</a></p>\n","site":{"data":{}},"cover":"http://image.jucaiwy.com/back_001.jpg","excerpt":"","more":"<p>CSDN: <a href=\"https://me.csdn.net/duanbokan\">沙僧</a></p>\n<p>微博主页：<a href=\"https://weibo.com/sbook213044\">沙僧师弟</a></p>\n<p>马蜂窝：<a href=\"http://www.mafengwo.cn/u/93302323.html\">沙僧</a></p>\n"}],"Post":[{"title":"单节点配置FastDFS","date":"2015-01-12T06:54:46.000Z","keywords":"FastDFS,Linux,数据存储","description":"单节点配置FastDFS","top_img":"http://image.jucaiwy.com/image/20150112/FastDFS.png","cover":"http://image.jucaiwy.com/image/20150112/FastDFS.png","_content":"\nFastDFS是一款开源的轻量级分布式文件系统纯C实现，支持Linux、FreeBSD等UNIX系统类google FS，不是通用的文件系统，只能通过专有API访问，目前提供了C、Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性FastDFS可以看做是基于文件的key value pair存储系统，称作分布式文件存储服务更为合适。最近在做柬埔寨一个IM项目，需要对图片、视频、录音等文件进行存储，这里选择使用FastDFS进行存储，记录了一下搭建过程，以备后期查阅。\n\n### 1.准备工作\n\n首先我们看一下FastDFS的三方交互图：\n\n![](http://image.jucaiwy.com/image/20150112/FastDFS.png)\n\n\n以下为我配置时使用的机器信息\n\n- 系统：CentOS 5.7 32位\n- Libevent：libevent-2.0.16-stable.tar.gz\n- FastDFS：FastDFS_v3.06.tar.gz\n- Male：yum -y install make\n\n### 2.安装Libevent\n\n按照以下步骤进行安装和配置\n\n#### 2.1 解压libevent-2.0.16-stable.tar.gz：\n```bash\ntar -zxvf  libevent-2.0.16-stable.tar.gz\n```\n#### 2.2 新建目录libevent：\n\n用于放置libevent编译出来的文件\n\n#### 2.3 配置：在libevent-2.0.16-stable目录中执行：\n\n```bash\n./configure --prefix=/usr/xinwei/libevent\n```\n\n**注：/usr/xinwei/libevent目录需要新建，不能设置libevent-2.0.16-stable目录，否则上传时会出错**\n\n#### 2.4 Make：\n```bash\ncd libevent-2.0.16-stable/  然后执行：make\n```\n\n#### 2.5 安装：\n```bash\nmake install\n```\n\n执行完毕后再之前新建的libevent目录中会生成bin、include和lib三个目录\n\n### 3.安装FastDFS\n\n#### 3.1 解压FastDFS_v3.06.tar.gz：\n```bash\ntar -zxvf  FastDFS_v3.06.tar.gz\n```\n#### 3.2 配置1：\n\n```bash\nvi make.sh\n```\n修改：\n\n```\nTARGET_PREFIX=/usr/local\nTARGET_CONF_PATH=/etc/fdfs\nWITH_HTTPD=1\t\nWITH_LINUX_SERVICE=1\n保存后退出\n```\n\n#### 3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\n\n```bash\n./make.sh C_INCLUDE_PATH=/usr/xinwei/libevent/include LIBRARY_PATH=/usr/xinwei/libevent/lib\n```\n\n#### 3.3 Make：执行FastDFS目录中的make.sh文件  \n\n安装：\n\n```bash\ncd FastDFS\n./make.sh install\n```\n\n安装完成后在/etc/fdfs/目录中会生成配置文件，包含client.conf、http.conf、mime.types、storage.conf、tracker.conf \n\n### 4.配置\n需要对/etc/fdfs/目录中的client.conf、storage.conf、tracker.conf 进行配置\n\n#### 4.1 Client.conf：\n\t\n```bash\nbase_path=/home/xinwei/fastdfs\ntracker_server=192.168.113.234:22122\n#include http.conf\n```\n\t\n#### 4.2 Storage.conf：\n```bash\nbase_path=/home/xinwei/fastdfs\nstore_path0=/home/xinwei/fastdfs\t\ntracker_server=192.168.113.234:22122\n#include http.conf\t\n```\n\t\n\t\n#### 4.3 Tracker.conf:\n\t\n```bash\n#include http.conf\n```\n\n配置完成后可进行启动：\n\n### 5.启动\n\n直接使用以下命令进行启动\n\n```bash\nService fdfs_storaged start\nService fdfs_trackerd start\n\n```\n\t\n\n### 6.测试\n上传一个文件进行测试：\n\n```bash\n/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload /usr/xinwei/test/test \n```\n\n### 7.备注\n(1).  FastDFS的log在/home/xinwei/fastdfs/logs目录中\n\n(2).  若出以下错误:\n\n```java\n[2015-01-03 23:19:52] ERROR - file: ../common/fdfs_http_shared.c, line: 128, param \"http.mime_types_filename\" not exist or is empty\n```\n\n则配置**http.conf**文件中：\n\n```\nhttp.mime_types_filename=/etc/fdfs/mime.types\n```\n\n \n\n \n\n \n\n \n\n ","source":"_posts/20150112单节点配置FastDFS.markdown","raw":"---\n\ntitle: 单节点配置FastDFS\n\ndate: 2015-01-12 14:54:46\n\ntags: [FastDFS,Linux,数据存储]\n\ncategories: FastDFS\n\nkeywords: FastDFS,Linux,数据存储\n\ndescription: 单节点配置FastDFS\n\ntop_img: http://image.jucaiwy.com/image/20150112/FastDFS.png\n\ncover: http://image.jucaiwy.com/image/20150112/FastDFS.png\n\n---\n\nFastDFS是一款开源的轻量级分布式文件系统纯C实现，支持Linux、FreeBSD等UNIX系统类google FS，不是通用的文件系统，只能通过专有API访问，目前提供了C、Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性FastDFS可以看做是基于文件的key value pair存储系统，称作分布式文件存储服务更为合适。最近在做柬埔寨一个IM项目，需要对图片、视频、录音等文件进行存储，这里选择使用FastDFS进行存储，记录了一下搭建过程，以备后期查阅。\n\n### 1.准备工作\n\n首先我们看一下FastDFS的三方交互图：\n\n![](http://image.jucaiwy.com/image/20150112/FastDFS.png)\n\n\n以下为我配置时使用的机器信息\n\n- 系统：CentOS 5.7 32位\n- Libevent：libevent-2.0.16-stable.tar.gz\n- FastDFS：FastDFS_v3.06.tar.gz\n- Male：yum -y install make\n\n### 2.安装Libevent\n\n按照以下步骤进行安装和配置\n\n#### 2.1 解压libevent-2.0.16-stable.tar.gz：\n```bash\ntar -zxvf  libevent-2.0.16-stable.tar.gz\n```\n#### 2.2 新建目录libevent：\n\n用于放置libevent编译出来的文件\n\n#### 2.3 配置：在libevent-2.0.16-stable目录中执行：\n\n```bash\n./configure --prefix=/usr/xinwei/libevent\n```\n\n**注：/usr/xinwei/libevent目录需要新建，不能设置libevent-2.0.16-stable目录，否则上传时会出错**\n\n#### 2.4 Make：\n```bash\ncd libevent-2.0.16-stable/  然后执行：make\n```\n\n#### 2.5 安装：\n```bash\nmake install\n```\n\n执行完毕后再之前新建的libevent目录中会生成bin、include和lib三个目录\n\n### 3.安装FastDFS\n\n#### 3.1 解压FastDFS_v3.06.tar.gz：\n```bash\ntar -zxvf  FastDFS_v3.06.tar.gz\n```\n#### 3.2 配置1：\n\n```bash\nvi make.sh\n```\n修改：\n\n```\nTARGET_PREFIX=/usr/local\nTARGET_CONF_PATH=/etc/fdfs\nWITH_HTTPD=1\t\nWITH_LINUX_SERVICE=1\n保存后退出\n```\n\n#### 3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\n\n```bash\n./make.sh C_INCLUDE_PATH=/usr/xinwei/libevent/include LIBRARY_PATH=/usr/xinwei/libevent/lib\n```\n\n#### 3.3 Make：执行FastDFS目录中的make.sh文件  \n\n安装：\n\n```bash\ncd FastDFS\n./make.sh install\n```\n\n安装完成后在/etc/fdfs/目录中会生成配置文件，包含client.conf、http.conf、mime.types、storage.conf、tracker.conf \n\n### 4.配置\n需要对/etc/fdfs/目录中的client.conf、storage.conf、tracker.conf 进行配置\n\n#### 4.1 Client.conf：\n\t\n```bash\nbase_path=/home/xinwei/fastdfs\ntracker_server=192.168.113.234:22122\n#include http.conf\n```\n\t\n#### 4.2 Storage.conf：\n```bash\nbase_path=/home/xinwei/fastdfs\nstore_path0=/home/xinwei/fastdfs\t\ntracker_server=192.168.113.234:22122\n#include http.conf\t\n```\n\t\n\t\n#### 4.3 Tracker.conf:\n\t\n```bash\n#include http.conf\n```\n\n配置完成后可进行启动：\n\n### 5.启动\n\n直接使用以下命令进行启动\n\n```bash\nService fdfs_storaged start\nService fdfs_trackerd start\n\n```\n\t\n\n### 6.测试\n上传一个文件进行测试：\n\n```bash\n/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload /usr/xinwei/test/test \n```\n\n### 7.备注\n(1).  FastDFS的log在/home/xinwei/fastdfs/logs目录中\n\n(2).  若出以下错误:\n\n```java\n[2015-01-03 23:19:52] ERROR - file: ../common/fdfs_http_shared.c, line: 128, param \"http.mime_types_filename\" not exist or is empty\n```\n\n则配置**http.conf**文件中：\n\n```\nhttp.mime_types_filename=/etc/fdfs/mime.types\n```\n\n \n\n \n\n \n\n \n\n ","slug":"20150112单节点配置FastDFS","published":1,"updated":"2020-12-09T06:16:30.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jur80001b3t10a2vg87e","content":"<p>FastDFS是一款开源的轻量级分布式文件系统纯C实现，支持Linux、FreeBSD等UNIX系统类google FS，不是通用的文件系统，只能通过专有API访问，目前提供了C、Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性FastDFS可以看做是基于文件的key value pair存储系统，称作分布式文件存储服务更为合适。最近在做柬埔寨一个IM项目，需要对图片、视频、录音等文件进行存储，这里选择使用FastDFS进行存储，记录了一下搭建过程，以备后期查阅。</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h3><p>首先我们看一下FastDFS的三方交互图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20150112/FastDFS.png\"></p>\n<p>以下为我配置时使用的机器信息</p>\n<ul>\n<li>系统：CentOS 5.7 32位</li>\n<li>Libevent：libevent-2.0.16-stable.tar.gz</li>\n<li>FastDFS：FastDFS_v3.06.tar.gz</li>\n<li>Male：yum -y install make</li>\n</ul>\n<h3 id=\"2-安装Libevent\"><a href=\"#2-安装Libevent\" class=\"headerlink\" title=\"2.安装Libevent\"></a>2.安装Libevent</h3><p>按照以下步骤进行安装和配置</p>\n<h4 id=\"2-1-解压libevent-2-0-16-stable-tar-gz：\"><a href=\"#2-1-解压libevent-2-0-16-stable-tar-gz：\" class=\"headerlink\" title=\"2.1 解压libevent-2.0.16-stable.tar.gz：\"></a>2.1 解压libevent-2.0.16-stable.tar.gz：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf  libevent-2.0.16-stable.tar.gz</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-新建目录libevent：\"><a href=\"#2-2-新建目录libevent：\" class=\"headerlink\" title=\"2.2 新建目录libevent：\"></a>2.2 新建目录libevent：</h4><p>用于放置libevent编译出来的文件</p>\n<h4 id=\"2-3-配置：在libevent-2-0-16-stable目录中执行：\"><a href=\"#2-3-配置：在libevent-2-0-16-stable目录中执行：\" class=\"headerlink\" title=\"2.3 配置：在libevent-2.0.16-stable目录中执行：\"></a>2.3 配置：在libevent-2.0.16-stable目录中执行：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/xinwei/libevent</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：&#x2F;usr&#x2F;xinwei&#x2F;libevent目录需要新建，不能设置libevent-2.0.16-stable目录，否则上传时会出错</strong></p>\n<h4 id=\"2-4-Make：\"><a href=\"#2-4-Make：\" class=\"headerlink\" title=\"2.4 Make：\"></a>2.4 Make：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> libevent-2.0.16-stable/  然后执行：make</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-安装：\"><a href=\"#2-5-安装：\" class=\"headerlink\" title=\"2.5 安装：\"></a>2.5 安装：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<p>执行完毕后再之前新建的libevent目录中会生成bin、include和lib三个目录</p>\n<h3 id=\"3-安装FastDFS\"><a href=\"#3-安装FastDFS\" class=\"headerlink\" title=\"3.安装FastDFS\"></a>3.安装FastDFS</h3><h4 id=\"3-1-解压FastDFS-v3-06-tar-gz：\"><a href=\"#3-1-解压FastDFS-v3-06-tar-gz：\" class=\"headerlink\" title=\"3.1 解压FastDFS_v3.06.tar.gz：\"></a>3.1 解压FastDFS_v3.06.tar.gz：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf  FastDFS_v3.06.tar.gz</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-配置1：\"><a href=\"#3-2-配置1：\" class=\"headerlink\" title=\"3.2 配置1：\"></a>3.2 配置1：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi make.sh</span><br></pre></td></tr></table></figure>\n<p>修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TARGET_PREFIX=/usr/local</span><br><span class=\"line\">TARGET_CONF_PATH=/etc/fdfs</span><br><span class=\"line\">WITH_HTTPD=1\t</span><br><span class=\"line\">WITH_LINUX_SERVICE=1</span><br><span class=\"line\">保存后退出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\"><a href=\"#3-2-配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\" class=\"headerlink\" title=\"3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\"></a>3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./make.sh C_INCLUDE_PATH=/usr/xinwei/libevent/include LIBRARY_PATH=/usr/xinwei/libevent/lib</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-Make：执行FastDFS目录中的make-sh文件\"><a href=\"#3-3-Make：执行FastDFS目录中的make-sh文件\" class=\"headerlink\" title=\"3.3 Make：执行FastDFS目录中的make.sh文件\"></a>3.3 Make：执行FastDFS目录中的make.sh文件</h4><p>安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> FastDFS</span><br><span class=\"line\">./make.sh install</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后在&#x2F;etc&#x2F;fdfs&#x2F;目录中会生成配置文件，包含client.conf、http.conf、mime.types、storage.conf、tracker.conf </p>\n<h3 id=\"4-配置\"><a href=\"#4-配置\" class=\"headerlink\" title=\"4.配置\"></a>4.配置</h3><p>需要对&#x2F;etc&#x2F;fdfs&#x2F;目录中的client.conf、storage.conf、tracker.conf 进行配置</p>\n<h4 id=\"4-1-Client-conf：\"><a href=\"#4-1-Client-conf：\" class=\"headerlink\" title=\"4.1 Client.conf：\"></a>4.1 Client.conf：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_path=/home/xinwei/fastdfs</span><br><span class=\"line\">tracker_server=192.168.113.234:22122</span><br><span class=\"line\"><span class=\"comment\">#include http.conf</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-Storage-conf：\"><a href=\"#4-2-Storage-conf：\" class=\"headerlink\" title=\"4.2 Storage.conf：\"></a>4.2 Storage.conf：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_path=/home/xinwei/fastdfs</span><br><span class=\"line\">store_path0=/home/xinwei/fastdfs\t</span><br><span class=\"line\">tracker_server=192.168.113.234:22122</span><br><span class=\"line\"><span class=\"comment\">#include http.conf\t</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-Tracker-conf\"><a href=\"#4-3-Tracker-conf\" class=\"headerlink\" title=\"4.3 Tracker.conf:\"></a>4.3 Tracker.conf:</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include http.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>配置完成后可进行启动：</p>\n<h3 id=\"5-启动\"><a href=\"#5-启动\" class=\"headerlink\" title=\"5.启动\"></a>5.启动</h3><p>直接使用以下命令进行启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Service fdfs_storaged start</span><br><span class=\"line\">Service fdfs_trackerd start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-测试\"><a href=\"#6-测试\" class=\"headerlink\" title=\"6.测试\"></a>6.测试</h3><p>上传一个文件进行测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload /usr/xinwei/test/test </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-备注\"><a href=\"#7-备注\" class=\"headerlink\" title=\"7.备注\"></a>7.备注</h3><p>(1).  FastDFS的log在&#x2F;home&#x2F;xinwei&#x2F;fastdfs&#x2F;logs目录中</p>\n<p>(2).  若出以下错误:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2015</span>-<span class=\"number\">01</span>-<span class=\"number\">03</span> <span class=\"number\">23</span>:<span class=\"number\">19</span>:<span class=\"number\">52</span>] ERROR - file: ../common/fdfs_http_shared.c, line: <span class=\"number\">128</span>, param <span class=\"string\">&quot;http.mime_types_filename&quot;</span> not exist or is empty</span><br></pre></td></tr></table></figure>\n\n<p>则配置<strong>http.conf</strong>文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.mime_types_filename=/etc/fdfs/mime.types</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>FastDFS是一款开源的轻量级分布式文件系统纯C实现，支持Linux、FreeBSD等UNIX系统类google FS，不是通用的文件系统，只能通过专有API访问，目前提供了C、Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性FastDFS可以看做是基于文件的key value pair存储系统，称作分布式文件存储服务更为合适。最近在做柬埔寨一个IM项目，需要对图片、视频、录音等文件进行存储，这里选择使用FastDFS进行存储，记录了一下搭建过程，以备后期查阅。</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h3><p>首先我们看一下FastDFS的三方交互图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20150112/FastDFS.png\"></p>\n<p>以下为我配置时使用的机器信息</p>\n<ul>\n<li>系统：CentOS 5.7 32位</li>\n<li>Libevent：libevent-2.0.16-stable.tar.gz</li>\n<li>FastDFS：FastDFS_v3.06.tar.gz</li>\n<li>Male：yum -y install make</li>\n</ul>\n<h3 id=\"2-安装Libevent\"><a href=\"#2-安装Libevent\" class=\"headerlink\" title=\"2.安装Libevent\"></a>2.安装Libevent</h3><p>按照以下步骤进行安装和配置</p>\n<h4 id=\"2-1-解压libevent-2-0-16-stable-tar-gz：\"><a href=\"#2-1-解压libevent-2-0-16-stable-tar-gz：\" class=\"headerlink\" title=\"2.1 解压libevent-2.0.16-stable.tar.gz：\"></a>2.1 解压libevent-2.0.16-stable.tar.gz：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf  libevent-2.0.16-stable.tar.gz</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-新建目录libevent：\"><a href=\"#2-2-新建目录libevent：\" class=\"headerlink\" title=\"2.2 新建目录libevent：\"></a>2.2 新建目录libevent：</h4><p>用于放置libevent编译出来的文件</p>\n<h4 id=\"2-3-配置：在libevent-2-0-16-stable目录中执行：\"><a href=\"#2-3-配置：在libevent-2-0-16-stable目录中执行：\" class=\"headerlink\" title=\"2.3 配置：在libevent-2.0.16-stable目录中执行：\"></a>2.3 配置：在libevent-2.0.16-stable目录中执行：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/xinwei/libevent</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：&#x2F;usr&#x2F;xinwei&#x2F;libevent目录需要新建，不能设置libevent-2.0.16-stable目录，否则上传时会出错</strong></p>\n<h4 id=\"2-4-Make：\"><a href=\"#2-4-Make：\" class=\"headerlink\" title=\"2.4 Make：\"></a>2.4 Make：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> libevent-2.0.16-stable/  然后执行：make</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-安装：\"><a href=\"#2-5-安装：\" class=\"headerlink\" title=\"2.5 安装：\"></a>2.5 安装：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<p>执行完毕后再之前新建的libevent目录中会生成bin、include和lib三个目录</p>\n<h3 id=\"3-安装FastDFS\"><a href=\"#3-安装FastDFS\" class=\"headerlink\" title=\"3.安装FastDFS\"></a>3.安装FastDFS</h3><h4 id=\"3-1-解压FastDFS-v3-06-tar-gz：\"><a href=\"#3-1-解压FastDFS-v3-06-tar-gz：\" class=\"headerlink\" title=\"3.1 解压FastDFS_v3.06.tar.gz：\"></a>3.1 解压FastDFS_v3.06.tar.gz：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf  FastDFS_v3.06.tar.gz</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-配置1：\"><a href=\"#3-2-配置1：\" class=\"headerlink\" title=\"3.2 配置1：\"></a>3.2 配置1：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi make.sh</span><br></pre></td></tr></table></figure>\n<p>修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TARGET_PREFIX=/usr/local</span><br><span class=\"line\">TARGET_CONF_PATH=/etc/fdfs</span><br><span class=\"line\">WITH_HTTPD=1\t</span><br><span class=\"line\">WITH_LINUX_SERVICE=1</span><br><span class=\"line\">保存后退出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\"><a href=\"#3-2-配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\" class=\"headerlink\" title=\"3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib\"></a>3.2 配置2：配置include的路径和lib的路径。均为之前新建目录libevent中的include和lib</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./make.sh C_INCLUDE_PATH=/usr/xinwei/libevent/include LIBRARY_PATH=/usr/xinwei/libevent/lib</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-Make：执行FastDFS目录中的make-sh文件\"><a href=\"#3-3-Make：执行FastDFS目录中的make-sh文件\" class=\"headerlink\" title=\"3.3 Make：执行FastDFS目录中的make.sh文件\"></a>3.3 Make：执行FastDFS目录中的make.sh文件</h4><p>安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> FastDFS</span><br><span class=\"line\">./make.sh install</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后在&#x2F;etc&#x2F;fdfs&#x2F;目录中会生成配置文件，包含client.conf、http.conf、mime.types、storage.conf、tracker.conf </p>\n<h3 id=\"4-配置\"><a href=\"#4-配置\" class=\"headerlink\" title=\"4.配置\"></a>4.配置</h3><p>需要对&#x2F;etc&#x2F;fdfs&#x2F;目录中的client.conf、storage.conf、tracker.conf 进行配置</p>\n<h4 id=\"4-1-Client-conf：\"><a href=\"#4-1-Client-conf：\" class=\"headerlink\" title=\"4.1 Client.conf：\"></a>4.1 Client.conf：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_path=/home/xinwei/fastdfs</span><br><span class=\"line\">tracker_server=192.168.113.234:22122</span><br><span class=\"line\"><span class=\"comment\">#include http.conf</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-Storage-conf：\"><a href=\"#4-2-Storage-conf：\" class=\"headerlink\" title=\"4.2 Storage.conf：\"></a>4.2 Storage.conf：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base_path=/home/xinwei/fastdfs</span><br><span class=\"line\">store_path0=/home/xinwei/fastdfs\t</span><br><span class=\"line\">tracker_server=192.168.113.234:22122</span><br><span class=\"line\"><span class=\"comment\">#include http.conf\t</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-Tracker-conf\"><a href=\"#4-3-Tracker-conf\" class=\"headerlink\" title=\"4.3 Tracker.conf:\"></a>4.3 Tracker.conf:</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include http.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>配置完成后可进行启动：</p>\n<h3 id=\"5-启动\"><a href=\"#5-启动\" class=\"headerlink\" title=\"5.启动\"></a>5.启动</h3><p>直接使用以下命令进行启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Service fdfs_storaged start</span><br><span class=\"line\">Service fdfs_trackerd start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-测试\"><a href=\"#6-测试\" class=\"headerlink\" title=\"6.测试\"></a>6.测试</h3><p>上传一个文件进行测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload /usr/xinwei/test/test </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-备注\"><a href=\"#7-备注\" class=\"headerlink\" title=\"7.备注\"></a>7.备注</h3><p>(1).  FastDFS的log在&#x2F;home&#x2F;xinwei&#x2F;fastdfs&#x2F;logs目录中</p>\n<p>(2).  若出以下错误:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2015</span>-<span class=\"number\">01</span>-<span class=\"number\">03</span> <span class=\"number\">23</span>:<span class=\"number\">19</span>:<span class=\"number\">52</span>] ERROR - file: ../common/fdfs_http_shared.c, line: <span class=\"number\">128</span>, param <span class=\"string\">&quot;http.mime_types_filename&quot;</span> not exist or is empty</span><br></pre></td></tr></table></figure>\n\n<p>则配置<strong>http.conf</strong>文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.mime_types_filename=/etc/fdfs/mime.types</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"Android环境String.xml文件中空格的处理","date":"2015-02-02T08:59:25.000Z","comments":1,"_content":"\n Android的String.xml文件中将多个空格合并为一个空格了，例如：\n\n\t<string name=\"test\">test      test      test      test</string>\n\n每一个Test中间有五个空格，但是实际在Log中打印出来的：\n\n\t![String.xml的Log](http://img.blog.csdn.net/20150202170214171)\n\n为解决这个问题，需要在xml文件中将空格用Unicode 字符值： **\\u0020** 代替：\n\n\t<string name=\"test\">test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test</string>\n","source":"_posts/20150202Android环境String.xml文件中空格的处理.markdown","raw":"---\nlayout: post\ntitle: \"Android环境String.xml文件中空格的处理\"\ndate: 2015-02-02 16:59:25\ncomments: true\ntags: \n\t- String.xml空格\n\t- 问题记录\n---\n\n Android的String.xml文件中将多个空格合并为一个空格了，例如：\n\n\t<string name=\"test\">test      test      test      test</string>\n\n每一个Test中间有五个空格，但是实际在Log中打印出来的：\n\n\t![String.xml的Log](http://img.blog.csdn.net/20150202170214171)\n\n为解决这个问题，需要在xml文件中将空格用Unicode 字符值： **\\u0020** 代替：\n\n\t<string name=\"test\">test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test</string>\n","slug":"20150202Android环境String.xml文件中空格的处理","published":1,"updated":"2018-03-13T08:22:28.000Z","photos":[],"link":"","_id":"cl278jurc0003b3t11wt5hzux","content":"<p> Android的String.xml文件中将多个空格合并为一个空格了，例如：</p>\n<pre><code>&lt;string name=&quot;test&quot;&gt;test      test      test      test&lt;/string&gt;\n</code></pre>\n<p>每一个Test中间有五个空格，但是实际在Log中打印出来的：</p>\n<pre><code>![String.xml的Log](http://img.blog.csdn.net/20150202170214171)\n</code></pre>\n<p>为解决这个问题，需要在xml文件中将空格用Unicode 字符值： <strong>\\u0020</strong> 代替：</p>\n<pre><code>&lt;string name=&quot;test&quot;&gt;test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test&lt;/string&gt;\n</code></pre>\n","site":{"data":{}},"cover":"http://image.jucaiwy.com/back_001.jpg","excerpt":"","more":"<p> Android的String.xml文件中将多个空格合并为一个空格了，例如：</p>\n<pre><code>&lt;string name=&quot;test&quot;&gt;test      test      test      test&lt;/string&gt;\n</code></pre>\n<p>每一个Test中间有五个空格，但是实际在Log中打印出来的：</p>\n<pre><code>![String.xml的Log](http://img.blog.csdn.net/20150202170214171)\n</code></pre>\n<p>为解决这个问题，需要在xml文件中将空格用Unicode 字符值： <strong>\\u0020</strong> 代替：</p>\n<pre><code>&lt;string name=&quot;test&quot;&gt;test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test\\u0020\\u0020\\u0020\\u0020\\u0020test&lt;/string&gt;\n</code></pre>\n"},{"title":"Android集成OCR实现文字识别","date":"2016-02-25T10:34:46.000Z","keywords":"Android , OCR , 图像识别","description":"Android集成OCR实现文字识别","top_img":"http://image.jucaiwy.com/image/20160225/ocr.jpg","cover":"http://image.jucaiwy.com/image/20160225/ocr.jpg","_content":"\nOCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；\n\n\n### 1.Tesseract简介\n\nTesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。\n现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。\n\n\n主页地址：[https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)\n\n\n在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为\n\n中文：[chi-sim.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n英文：[eng.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n### 2.Tess-two\n\n因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。\n\n#### 2.1 项目地址\n\nTess-two在git上地址为：[https://github.com/rmtheis/tess-two](https://github.com/rmtheis/tess-two)\n\n\n#### 2.2 编译\n我编译使用的环境：\n\n- Eclipse 4.2.1\n- ADT 23.0.2\n- NDK R10\n- Cygwin \n\nNDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：[Windows下Android NDK环境搭建](http://blog.csdn.net/pengchua/article/details/7582949)\n\n配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：\n\n- 第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。\n- 第二步：切换到tess-two目录下的jni目录\n- 第三步：输入命令进行编译\n\n编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。\n\n也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。\n\ntess-two下载\n\n\n\n### 3.tess-two使用\n\n编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：\n\n\n\n识别函数：\n\n```java\n\t/**\n     * 识别图片中文字,需要放入异步线程中进行执行\n     *\n     * @param bitmap\n     * @return\n     * @throws IOException\n     */\n    public String parseImageToString(String imagePath) throws IOException {\n        // 检验图片地址是否正确\n        if (imagePath == null || imagePath.equals(\"\")) {\n            return TessErrorCode.IMAGE_PATH_IS_NULL;\n        }\n\n        // 获取Bitmap\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inSampleSize = 2;\n        Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n        // 图片旋转角度\n        int rotate = 0;\n\n        ExifInterface exif = new ExifInterface(imagePath);\n\n        // 先获取当前图像的方向，判断是否需要旋转\n        int imageOrientation = exif\n                .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                        ExifInterface.ORIENTATION_NORMAL);\n\n        Log.i(TAG, \"Current image orientation is \" + imageOrientation);\n\n        switch (imageOrientation) {\n            case ExifInterface.ORIENTATION_ROTATE_90:\n                rotate = 90;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_180:\n                rotate = 180;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_270:\n                rotate = 270;\n                break;\n            default:\n                break;\n        }\n\n        Log.i(TAG, \"Current image need rotate: \" + rotate);\n\n        // 获取当前图片的宽和高\n        int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n\n        // 使用Matrix对图片进行处理\n        Matrix mtx = new Matrix();\n        mtx.preRotate(rotate);\n\n        // 旋转图片\n        bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n        bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        // 开始调用Tess函数对图像进行识别\n        TessBaseAPI baseApi = new TessBaseAPI();\n        baseApi.setDebug(true);\n        // 使用默认语言初始化BaseApi\n        baseApi.init(TessConstantConfig.TESSBASE_PATH,\n                TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n        baseApi.setImage(bitmap);\n\n        // 获取返回值\n        String recognizedText = baseApi.getUTF8Text();\n        baseApi.end();\n        return recognizedText;\n    }\n```\n\n使用之前，需要先下载数据包到/mnt/sdcard/tesseract/目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载\n\n\n[数据包下载地址](https://github.com/tesseract-ocr/tessdata)\n\n\n\n经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：\n\n\n\n\n### 4.总结\n总结tess-two的使用方法，大致可分为以下几步：\n\n1. 下载并解压tess-two，下载路径：\n2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n3. 测试，训练\n\n\n\n\n\n","source":"_posts/20150225Android集成OCR实现文字识别.md","raw":"---\n\ntitle: Android集成OCR实现文字识别\n\ndate: 2016-02-25 18:34:46\n\ntags: [ Android , OCR , 图像识别]\n\ncategories: Android\n\nkeywords:  Android , OCR , 图像识别\n\ndescription: Android集成OCR实现文字识别\n\ntop_img: http://image.jucaiwy.com/image/20160225/ocr.jpg\n\ncover: http://image.jucaiwy.com/image/20160225/ocr.jpg\n\n---\n\nOCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；\n\n\n### 1.Tesseract简介\n\nTesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。\n现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。\n\n\n主页地址：[https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)\n\n\n在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为\n\n中文：[chi-sim.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n英文：[eng.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n### 2.Tess-two\n\n因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。\n\n#### 2.1 项目地址\n\nTess-two在git上地址为：[https://github.com/rmtheis/tess-two](https://github.com/rmtheis/tess-two)\n\n\n#### 2.2 编译\n我编译使用的环境：\n\n- Eclipse 4.2.1\n- ADT 23.0.2\n- NDK R10\n- Cygwin \n\nNDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：[Windows下Android NDK环境搭建](http://blog.csdn.net/pengchua/article/details/7582949)\n\n配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：\n\n- 第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。\n- 第二步：切换到tess-two目录下的jni目录\n- 第三步：输入命令进行编译\n\n编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。\n\n也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。\n\ntess-two下载\n\n\n\n### 3.tess-two使用\n\n编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：\n\n\n\n识别函数：\n\n```java\n\t/**\n     * 识别图片中文字,需要放入异步线程中进行执行\n     *\n     * @param bitmap\n     * @return\n     * @throws IOException\n     */\n    public String parseImageToString(String imagePath) throws IOException {\n        // 检验图片地址是否正确\n        if (imagePath == null || imagePath.equals(\"\")) {\n            return TessErrorCode.IMAGE_PATH_IS_NULL;\n        }\n\n        // 获取Bitmap\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inSampleSize = 2;\n        Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n        // 图片旋转角度\n        int rotate = 0;\n\n        ExifInterface exif = new ExifInterface(imagePath);\n\n        // 先获取当前图像的方向，判断是否需要旋转\n        int imageOrientation = exif\n                .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                        ExifInterface.ORIENTATION_NORMAL);\n\n        Log.i(TAG, \"Current image orientation is \" + imageOrientation);\n\n        switch (imageOrientation) {\n            case ExifInterface.ORIENTATION_ROTATE_90:\n                rotate = 90;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_180:\n                rotate = 180;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_270:\n                rotate = 270;\n                break;\n            default:\n                break;\n        }\n\n        Log.i(TAG, \"Current image need rotate: \" + rotate);\n\n        // 获取当前图片的宽和高\n        int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n\n        // 使用Matrix对图片进行处理\n        Matrix mtx = new Matrix();\n        mtx.preRotate(rotate);\n\n        // 旋转图片\n        bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n        bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        // 开始调用Tess函数对图像进行识别\n        TessBaseAPI baseApi = new TessBaseAPI();\n        baseApi.setDebug(true);\n        // 使用默认语言初始化BaseApi\n        baseApi.init(TessConstantConfig.TESSBASE_PATH,\n                TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n        baseApi.setImage(bitmap);\n\n        // 获取返回值\n        String recognizedText = baseApi.getUTF8Text();\n        baseApi.end();\n        return recognizedText;\n    }\n```\n\n使用之前，需要先下载数据包到/mnt/sdcard/tesseract/目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载\n\n\n[数据包下载地址](https://github.com/tesseract-ocr/tessdata)\n\n\n\n经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：\n\n\n\n\n### 4.总结\n总结tess-two的使用方法，大致可分为以下几步：\n\n1. 下载并解压tess-two，下载路径：\n2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n3. 测试，训练\n\n\n\n\n\n","slug":"20150225Android集成OCR实现文字识别","published":1,"updated":"2020-12-09T07:42:42.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurg0007b3t1du3h4zht","content":"<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p>\n<h3 id=\"1-Tesseract简介\"><a href=\"#1-Tesseract简介\" class=\"headerlink\" title=\"1.Tesseract简介\"></a>1.Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p>\n<p>主页地址：<a href=\"https://github.com/tesseract-ocr\">https://github.com/tesseract-ocr</a></p>\n<p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p>\n<p>中文：<a href=\"https://github.com/tesseract-ocr/tessdata\">chi-sim.traineddata</a></p>\n<p>英文：<a href=\"https://github.com/tesseract-ocr/tessdata\">eng.traineddata</a></p>\n<h3 id=\"2-Tess-two\"><a href=\"#2-Tess-two\" class=\"headerlink\" title=\"2.Tess-two\"></a>2.Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p>\n<h4 id=\"2-1-项目地址\"><a href=\"#2-1-项目地址\" class=\"headerlink\" title=\"2.1 项目地址\"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href=\"https://github.com/rmtheis/tess-two\">https://github.com/rmtheis/tess-two</a></p>\n<h4 id=\"2-2-编译\"><a href=\"#2-2-编译\" class=\"headerlink\" title=\"2.2 编译\"></a>2.2 编译</h4><p>我编译使用的环境：</p>\n<ul>\n<li>Eclipse 4.2.1</li>\n<li>ADT 23.0.2</li>\n<li>NDK R10</li>\n<li>Cygwin</li>\n</ul>\n<p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href=\"http://blog.csdn.net/pengchua/article/details/7582949\">Windows下Android NDK环境搭建</a></p>\n<p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：</p>\n<ul>\n<li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li>\n<li>第二步：切换到tess-two目录下的jni目录</li>\n<li>第三步：输入命令进行编译</li>\n</ul>\n<p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p>\n<p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p>\n<p>tess-two下载</p>\n<h3 id=\"3-tess-two使用\"><a href=\"#3-tess-two使用\" class=\"headerlink\" title=\"3.tess-two使用\"></a>3.tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p>\n<p>识别函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 识别图片中文字,需要放入异步线程中进行执行</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">parseImageToString</span><span class=\"params\">(String imagePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 检验图片地址是否正确</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (imagePath == <span class=\"literal\">null</span> || imagePath.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> TessErrorCode.IMAGE_PATH_IS_NULL;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取Bitmap</span></span><br><span class=\"line\">       BitmapFactory.<span class=\"type\">Options</span> <span class=\"variable\">options</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BitmapFactory</span>.Options();</span><br><span class=\"line\">       options.inSampleSize = <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"type\">Bitmap</span> <span class=\"variable\">bitmap</span> <span class=\"operator\">=</span> BitmapFactory.decodeFile(imagePath, options);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 图片旋转角度</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">rotate</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">ExifInterface</span> <span class=\"variable\">exif</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExifInterface</span>(imagePath);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 先获取当前图像的方向，判断是否需要旋转</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">imageOrientation</span> <span class=\"operator\">=</span> exif</span><br><span class=\"line\">               .getAttributeInt(ExifInterface.TAG_ORIENTATION,</span><br><span class=\"line\">                       ExifInterface.ORIENTATION_NORMAL);</span><br><span class=\"line\"></span><br><span class=\"line\">       Log.i(TAG, <span class=\"string\">&quot;Current image orientation is &quot;</span> + imageOrientation);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (imageOrientation) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class=\"line\">               rotate = <span class=\"number\">90</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class=\"line\">               rotate = <span class=\"number\">180</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class=\"line\">               rotate = <span class=\"number\">270</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Log.i(TAG, <span class=\"string\">&quot;Current image need rotate: &quot;</span> + rotate);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取当前图片的宽和高</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> bitmap.getWidth();</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> bitmap.getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 使用Matrix对图片进行处理</span></span><br><span class=\"line\">       <span class=\"type\">Matrix</span> <span class=\"variable\">mtx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Matrix</span>();</span><br><span class=\"line\">       mtx.preRotate(rotate);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 旋转图片</span></span><br><span class=\"line\">       bitmap = Bitmap.createBitmap(bitmap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h, mtx, <span class=\"literal\">false</span>);</span><br><span class=\"line\">       bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 开始调用Tess函数对图像进行识别</span></span><br><span class=\"line\">       <span class=\"type\">TessBaseAPI</span> <span class=\"variable\">baseApi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TessBaseAPI</span>();</span><br><span class=\"line\">       baseApi.setDebug(<span class=\"literal\">true</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 使用默认语言初始化BaseApi</span></span><br><span class=\"line\">       baseApi.init(TessConstantConfig.TESSBASE_PATH,</span><br><span class=\"line\">               TessConstantConfig.DEFAULT_LANGUAGE_CHI);</span><br><span class=\"line\">       baseApi.setImage(bitmap);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取返回值</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">recognizedText</span> <span class=\"operator\">=</span> baseApi.getUTF8Text();</span><br><span class=\"line\">       baseApi.end();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> recognizedText;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p>\n<p><a href=\"https://github.com/tesseract-ocr/tessdata\">数据包下载地址</a></p>\n<p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p>\n<ol>\n<li>下载并解压tess-two，下载路径：</li>\n<li>编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码</li>\n<li>测试，训练</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p>\n<h3 id=\"1-Tesseract简介\"><a href=\"#1-Tesseract简介\" class=\"headerlink\" title=\"1.Tesseract简介\"></a>1.Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p>\n<p>主页地址：<a href=\"https://github.com/tesseract-ocr\">https://github.com/tesseract-ocr</a></p>\n<p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p>\n<p>中文：<a href=\"https://github.com/tesseract-ocr/tessdata\">chi-sim.traineddata</a></p>\n<p>英文：<a href=\"https://github.com/tesseract-ocr/tessdata\">eng.traineddata</a></p>\n<h3 id=\"2-Tess-two\"><a href=\"#2-Tess-two\" class=\"headerlink\" title=\"2.Tess-two\"></a>2.Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p>\n<h4 id=\"2-1-项目地址\"><a href=\"#2-1-项目地址\" class=\"headerlink\" title=\"2.1 项目地址\"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href=\"https://github.com/rmtheis/tess-two\">https://github.com/rmtheis/tess-two</a></p>\n<h4 id=\"2-2-编译\"><a href=\"#2-2-编译\" class=\"headerlink\" title=\"2.2 编译\"></a>2.2 编译</h4><p>我编译使用的环境：</p>\n<ul>\n<li>Eclipse 4.2.1</li>\n<li>ADT 23.0.2</li>\n<li>NDK R10</li>\n<li>Cygwin</li>\n</ul>\n<p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href=\"http://blog.csdn.net/pengchua/article/details/7582949\">Windows下Android NDK环境搭建</a></p>\n<p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：</p>\n<ul>\n<li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li>\n<li>第二步：切换到tess-two目录下的jni目录</li>\n<li>第三步：输入命令进行编译</li>\n</ul>\n<p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p>\n<p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p>\n<p>tess-two下载</p>\n<h3 id=\"3-tess-two使用\"><a href=\"#3-tess-two使用\" class=\"headerlink\" title=\"3.tess-two使用\"></a>3.tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p>\n<p>识别函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 识别图片中文字,需要放入异步线程中进行执行</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">parseImageToString</span><span class=\"params\">(String imagePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 检验图片地址是否正确</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (imagePath == <span class=\"literal\">null</span> || imagePath.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> TessErrorCode.IMAGE_PATH_IS_NULL;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取Bitmap</span></span><br><span class=\"line\">       BitmapFactory.<span class=\"type\">Options</span> <span class=\"variable\">options</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BitmapFactory</span>.Options();</span><br><span class=\"line\">       options.inSampleSize = <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"type\">Bitmap</span> <span class=\"variable\">bitmap</span> <span class=\"operator\">=</span> BitmapFactory.decodeFile(imagePath, options);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 图片旋转角度</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">rotate</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">ExifInterface</span> <span class=\"variable\">exif</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExifInterface</span>(imagePath);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 先获取当前图像的方向，判断是否需要旋转</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">imageOrientation</span> <span class=\"operator\">=</span> exif</span><br><span class=\"line\">               .getAttributeInt(ExifInterface.TAG_ORIENTATION,</span><br><span class=\"line\">                       ExifInterface.ORIENTATION_NORMAL);</span><br><span class=\"line\"></span><br><span class=\"line\">       Log.i(TAG, <span class=\"string\">&quot;Current image orientation is &quot;</span> + imageOrientation);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (imageOrientation) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class=\"line\">               rotate = <span class=\"number\">90</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class=\"line\">               rotate = <span class=\"number\">180</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class=\"line\">               rotate = <span class=\"number\">270</span>;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Log.i(TAG, <span class=\"string\">&quot;Current image need rotate: &quot;</span> + rotate);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取当前图片的宽和高</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> bitmap.getWidth();</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> bitmap.getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 使用Matrix对图片进行处理</span></span><br><span class=\"line\">       <span class=\"type\">Matrix</span> <span class=\"variable\">mtx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Matrix</span>();</span><br><span class=\"line\">       mtx.preRotate(rotate);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 旋转图片</span></span><br><span class=\"line\">       bitmap = Bitmap.createBitmap(bitmap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h, mtx, <span class=\"literal\">false</span>);</span><br><span class=\"line\">       bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 开始调用Tess函数对图像进行识别</span></span><br><span class=\"line\">       <span class=\"type\">TessBaseAPI</span> <span class=\"variable\">baseApi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TessBaseAPI</span>();</span><br><span class=\"line\">       baseApi.setDebug(<span class=\"literal\">true</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 使用默认语言初始化BaseApi</span></span><br><span class=\"line\">       baseApi.init(TessConstantConfig.TESSBASE_PATH,</span><br><span class=\"line\">               TessConstantConfig.DEFAULT_LANGUAGE_CHI);</span><br><span class=\"line\">       baseApi.setImage(bitmap);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 获取返回值</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">recognizedText</span> <span class=\"operator\">=</span> baseApi.getUTF8Text();</span><br><span class=\"line\">       baseApi.end();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> recognizedText;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p>\n<p><a href=\"https://github.com/tesseract-ocr/tessdata\">数据包下载地址</a></p>\n<p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p>\n<ol>\n<li>下载并解压tess-two，下载路径：</li>\n<li>编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码</li>\n<li>测试，训练</li>\n</ol>\n"},{"title":"LogcatUtil","date":"2015-03-02T09:27:06.000Z","keywords":"Android , LogcatUtil","description":"LogcatUtil","top_img":"http://image.jucaiwy.com/image/20150302/logcat.jpg","cover":"http://image.jucaiwy.com/image/20150302/logcat.jpg","_content":"\n\n之前项目中，需要自己打印log，于是模仿别人的工具，整理了一个日志打印工具，支持开关、打印文件名、方法名、行数等：\n\n\n\tpackage com.xinwei.palmhall.util;  \n  \n\timport java.text.SimpleDateFormat;  \n\timport java.util.Date;  \n  \n\timport android.util.Log;  \n  \n\tpublic class LogCatUtil {  \n    private static final boolean DEBUG = true;  \n  \n    public static void d(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.d(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void d(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.d(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void e(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.e(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void e(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.e(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void i(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.i(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void i(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.i(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void w(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.w(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void w(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.w(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    // 获取文件、行数  \n    private static String getFileLineMethod() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        StringBuffer toStringBuffer = new StringBuffer(\"[\")  \n                .append(traceElement.getFileName()).append(\" | \")  \n                .append(traceElement.getLineNumber()).append(\" | \")  \n                .append(traceElement.getMethodName()).append(\"]\");  \n        return toStringBuffer.toString();  \n    }  \n  \n    // 获取行数  \n    public static String getLineMethod() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        StringBuffer toStringBuffer = new StringBuffer(\"[\")  \n                .append(traceElement.getLineNumber()).append(\" | \")  \n                .append(traceElement.getMethodName()).append(\"]\");  \n        return toStringBuffer.toString();  \n    }  \n  \n    // 获取文件名  \n    public static String _FILE_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        return traceElement.getFileName();  \n    }  \n  \n    // 获取方法名  \n    public static String _FUNC_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n        return traceElement.getMethodName();  \n    }  \n  \n    // 获取行数  \n    public static int _LINE_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n        return traceElement.getLineNumber();  \n    }  \n  \n    // 获取时间  \n    public static String _TIME_() {  \n        Date now = new Date();  \n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n        return sdf.format(now);  \n    }  \n\t}  ","source":"_posts/20150302LogCatUtil.markdown","raw":"---\n\ntitle: LogcatUtil\n\ndate: 2015-03-02 17:27:06\n\ntags: [Android , LogcatUtil ]\n\ncategories: Android \n\nkeywords: Android , LogcatUtil\n\ndescription: LogcatUtil\n\ntop_img: http://image.jucaiwy.com/image/20150302/logcat.jpg\n\ncover: http://image.jucaiwy.com/image/20150302/logcat.jpg\n\n---\n\n\n之前项目中，需要自己打印log，于是模仿别人的工具，整理了一个日志打印工具，支持开关、打印文件名、方法名、行数等：\n\n\n\tpackage com.xinwei.palmhall.util;  \n  \n\timport java.text.SimpleDateFormat;  \n\timport java.util.Date;  \n  \n\timport android.util.Log;  \n  \n\tpublic class LogCatUtil {  \n    private static final boolean DEBUG = true;  \n  \n    public static void d(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.d(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void d(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.d(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void e(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.e(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void e(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.e(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void i(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.i(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void i(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.i(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void w(String TAG, String method, String msg) {  \n        if (DEBUG) {  \n            Log.w(TAG, \"[\" + method + \"]\" + msg);  \n        }  \n    }  \n  \n    public static void w(String TAG, String msg) {  \n        if (DEBUG) {  \n            Log.w(TAG, \"[\" + getFileLineMethod() + \"]\" + msg);  \n        }  \n    }  \n  \n    // 获取文件、行数  \n    private static String getFileLineMethod() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        StringBuffer toStringBuffer = new StringBuffer(\"[\")  \n                .append(traceElement.getFileName()).append(\" | \")  \n                .append(traceElement.getLineNumber()).append(\" | \")  \n                .append(traceElement.getMethodName()).append(\"]\");  \n        return toStringBuffer.toString();  \n    }  \n  \n    // 获取行数  \n    public static String getLineMethod() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        StringBuffer toStringBuffer = new StringBuffer(\"[\")  \n                .append(traceElement.getLineNumber()).append(\" | \")  \n                .append(traceElement.getMethodName()).append(\"]\");  \n        return toStringBuffer.toString();  \n    }  \n  \n    // 获取文件名  \n    public static String _FILE_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n        return traceElement.getFileName();  \n    }  \n  \n    // 获取方法名  \n    public static String _FUNC_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n        return traceElement.getMethodName();  \n    }  \n  \n    // 获取行数  \n    public static int _LINE_() {  \n        StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n        return traceElement.getLineNumber();  \n    }  \n  \n    // 获取时间  \n    public static String _TIME_() {  \n        Date now = new Date();  \n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n        return sdf.format(now);  \n    }  \n\t}  ","slug":"20150302LogCatUtil","published":1,"updated":"2020-12-09T06:25:56.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurg0008b3t10hho5m3g","content":"<p>之前项目中，需要自己打印log，于是模仿别人的工具，整理了一个日志打印工具，支持开关、打印文件名、方法名、行数等：</p>\n<pre><code>package com.xinwei.palmhall.util;  \n\nimport java.text.SimpleDateFormat;  \nimport java.util.Date;  \n\nimport android.util.Log;  \n\npublic class LogCatUtil &#123;  \nprivate static final boolean DEBUG = true;  \n\npublic static void d(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.d(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void d(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.d(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void e(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.e(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void e(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.e(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void i(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.i(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void i(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.i(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void w(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.w(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void w(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.w(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\n// 获取文件、行数  \nprivate static String getFileLineMethod() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    StringBuffer toStringBuffer = new StringBuffer(&quot;[&quot;)  \n            .append(traceElement.getFileName()).append(&quot; | &quot;)  \n            .append(traceElement.getLineNumber()).append(&quot; | &quot;)  \n            .append(traceElement.getMethodName()).append(&quot;]&quot;);  \n    return toStringBuffer.toString();  \n&#125;  \n\n// 获取行数  \npublic static String getLineMethod() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    StringBuffer toStringBuffer = new StringBuffer(&quot;[&quot;)  \n            .append(traceElement.getLineNumber()).append(&quot; | &quot;)  \n            .append(traceElement.getMethodName()).append(&quot;]&quot;);  \n    return toStringBuffer.toString();  \n&#125;  \n\n// 获取文件名  \npublic static String _FILE_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    return traceElement.getFileName();  \n&#125;  \n\n// 获取方法名  \npublic static String _FUNC_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n    return traceElement.getMethodName();  \n&#125;  \n\n// 获取行数  \npublic static int _LINE_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n    return traceElement.getLineNumber();  \n&#125;  \n\n// 获取时间  \npublic static String _TIME_() &#123;  \n    Date now = new Date();  \n    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);  \n    return sdf.format(now);  \n&#125;  \n&#125;  \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>之前项目中，需要自己打印log，于是模仿别人的工具，整理了一个日志打印工具，支持开关、打印文件名、方法名、行数等：</p>\n<pre><code>package com.xinwei.palmhall.util;  \n\nimport java.text.SimpleDateFormat;  \nimport java.util.Date;  \n\nimport android.util.Log;  \n\npublic class LogCatUtil &#123;  \nprivate static final boolean DEBUG = true;  \n\npublic static void d(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.d(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void d(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.d(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void e(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.e(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void e(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.e(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void i(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.i(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void i(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.i(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void w(String TAG, String method, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.w(TAG, &quot;[&quot; + method + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\npublic static void w(String TAG, String msg) &#123;  \n    if (DEBUG) &#123;  \n        Log.w(TAG, &quot;[&quot; + getFileLineMethod() + &quot;]&quot; + msg);  \n    &#125;  \n&#125;  \n\n// 获取文件、行数  \nprivate static String getFileLineMethod() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    StringBuffer toStringBuffer = new StringBuffer(&quot;[&quot;)  \n            .append(traceElement.getFileName()).append(&quot; | &quot;)  \n            .append(traceElement.getLineNumber()).append(&quot; | &quot;)  \n            .append(traceElement.getMethodName()).append(&quot;]&quot;);  \n    return toStringBuffer.toString();  \n&#125;  \n\n// 获取行数  \npublic static String getLineMethod() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    StringBuffer toStringBuffer = new StringBuffer(&quot;[&quot;)  \n            .append(traceElement.getLineNumber()).append(&quot; | &quot;)  \n            .append(traceElement.getMethodName()).append(&quot;]&quot;);  \n    return toStringBuffer.toString();  \n&#125;  \n\n// 获取文件名  \npublic static String _FILE_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[2];  \n    return traceElement.getFileName();  \n&#125;  \n\n// 获取方法名  \npublic static String _FUNC_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n    return traceElement.getMethodName();  \n&#125;  \n\n// 获取行数  \npublic static int _LINE_() &#123;  \n    StackTraceElement traceElement = ((new Exception()).getStackTrace())[1];  \n    return traceElement.getLineNumber();  \n&#125;  \n\n// 获取时间  \npublic static String _TIME_() &#123;  \n    Date now = new Date();  \n    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);  \n    return sdf.format(now);  \n&#125;  \n&#125;  \n</code></pre>\n"},{"title":"FindBugs安装及使用","date":"2015-09-02T09:27:06.000Z","keywords":"Android , FindBugs","description":"Fragment中ListView.setOnItemClickListener失效的问题","top_img":"http://image.jucaiwy.com/image/20150902/find_bugs_4.jpeg","cover":"http://image.jucaiwy.com/image/20150902/find_bugs_4.jpeg","_content":"\n\nFindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。有了静态分析工具，就可以在不实际运行程序的情况对软件进行分析。\n\n### 1. 安装\n\n本文主要叙述如何在Eclipse中安装和使用FindBugs，安装可以分为在线安装和离线安装两种方式：\n\n\n#### 1.1 在线安装 \n\n安装地址：[http://findbugs.cs.umd.edu/eclipse](http://findbugs.cs.umd.edu/eclipse) ，\n\n在Eclipse—Help—Install New Software—Add—location中写入该地址，然后一路Next直到完成，重启Eclipse后，即可完成安装（可以任选一个项目，右键菜单中会出现Find Bugs）\n\n\n#### 1.2 离线安装 \n\n下载地址为：[ http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu](http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu)\n\n下载完成以后，将它放入Eclipse下的plusin文件夹，然后重启Eclipse即可。\n\n### 2. 使用\n\nFindBugs使用方法很简单，首先，在Window—Show View—Bug Explorer，打开Bug Explorer面板：\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_1.png)\n\n选中需要检查的项目，右键选择FindBugs：\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_2.png)\n\n然后会在BugExplorer中看到当前选择工程中存在的问题。分为四个等级：\n\n- Scariest\n- Scary\n- Troubling\n- Of Concern\n\n同时也可以打开Perspective界面查看Bug的详细信息及FindBugs给出的参考解决方案\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_3.png)\n\n### 3. 错误类型\n\n官方错误信息集合：[http://findbugs.sourceforge.net/bugDescriptions.html](http://findbugs.sourceforge.net/bugDescriptions.html)","source":"_posts/20150902FindBugs安装及使用.markdown","raw":"---\n\ntitle: FindBugs安装及使用\n\ndate: 2015-09-02 17:27:06\n\ntags: [Android , FindBugs ]\n\ncategories: Android \n\nkeywords: Android , FindBugs\n\ndescription: Fragment中ListView.setOnItemClickListener失效的问题\n\ntop_img: http://image.jucaiwy.com/image/20150902/find_bugs_4.jpeg\n\ncover: http://image.jucaiwy.com/image/20150902/find_bugs_4.jpeg\n\n---\n\n\nFindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。有了静态分析工具，就可以在不实际运行程序的情况对软件进行分析。\n\n### 1. 安装\n\n本文主要叙述如何在Eclipse中安装和使用FindBugs，安装可以分为在线安装和离线安装两种方式：\n\n\n#### 1.1 在线安装 \n\n安装地址：[http://findbugs.cs.umd.edu/eclipse](http://findbugs.cs.umd.edu/eclipse) ，\n\n在Eclipse—Help—Install New Software—Add—location中写入该地址，然后一路Next直到完成，重启Eclipse后，即可完成安装（可以任选一个项目，右键菜单中会出现Find Bugs）\n\n\n#### 1.2 离线安装 \n\n下载地址为：[ http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu](http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu)\n\n下载完成以后，将它放入Eclipse下的plusin文件夹，然后重启Eclipse即可。\n\n### 2. 使用\n\nFindBugs使用方法很简单，首先，在Window—Show View—Bug Explorer，打开Bug Explorer面板：\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_1.png)\n\n选中需要检查的项目，右键选择FindBugs：\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_2.png)\n\n然后会在BugExplorer中看到当前选择工程中存在的问题。分为四个等级：\n\n- Scariest\n- Scary\n- Troubling\n- Of Concern\n\n同时也可以打开Perspective界面查看Bug的详细信息及FindBugs给出的参考解决方案\n\n![](http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_3.png)\n\n### 3. 错误类型\n\n官方错误信息集合：[http://findbugs.sourceforge.net/bugDescriptions.html](http://findbugs.sourceforge.net/bugDescriptions.html)","slug":"20150902FindBugs安装及使用","published":1,"updated":"2020-12-09T06:26:28.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurh0009b3t1hctq2wak","content":"<p>FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。有了静态分析工具，就可以在不实际运行程序的情况对软件进行分析。</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>本文主要叙述如何在Eclipse中安装和使用FindBugs，安装可以分为在线安装和离线安装两种方式：</p>\n<h4 id=\"1-1-在线安装\"><a href=\"#1-1-在线安装\" class=\"headerlink\" title=\"1.1 在线安装\"></a>1.1 在线安装</h4><p>安装地址：<a href=\"http://findbugs.cs.umd.edu/eclipse\">http://findbugs.cs.umd.edu/eclipse</a> ，</p>\n<p>在Eclipse—Help—Install New Software—Add—location中写入该地址，然后一路Next直到完成，重启Eclipse后，即可完成安装（可以任选一个项目，右键菜单中会出现Find Bugs）</p>\n<h4 id=\"1-2-离线安装\"><a href=\"#1-2-离线安装\" class=\"headerlink\" title=\"1.2 离线安装\"></a>1.2 离线安装</h4><p>下载地址为：<a href=\"http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu\"> http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror&#x3D;ncu</a></p>\n<p>下载完成以后，将它放入Eclipse下的plusin文件夹，然后重启Eclipse即可。</p>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h3><p>FindBugs使用方法很简单，首先，在Window—Show View—Bug Explorer，打开Bug Explorer面板：</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_1.png\"></p>\n<p>选中需要检查的项目，右键选择FindBugs：</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_2.png\"></p>\n<p>然后会在BugExplorer中看到当前选择工程中存在的问题。分为四个等级：</p>\n<ul>\n<li>Scariest</li>\n<li>Scary</li>\n<li>Troubling</li>\n<li>Of Concern</li>\n</ul>\n<p>同时也可以打开Perspective界面查看Bug的详细信息及FindBugs给出的参考解决方案</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_3.png\"></p>\n<h3 id=\"3-错误类型\"><a href=\"#3-错误类型\" class=\"headerlink\" title=\"3. 错误类型\"></a>3. 错误类型</h3><p>官方错误信息集合：<a href=\"http://findbugs.sourceforge.net/bugDescriptions.html\">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。有了静态分析工具，就可以在不实际运行程序的情况对软件进行分析。</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>本文主要叙述如何在Eclipse中安装和使用FindBugs，安装可以分为在线安装和离线安装两种方式：</p>\n<h4 id=\"1-1-在线安装\"><a href=\"#1-1-在线安装\" class=\"headerlink\" title=\"1.1 在线安装\"></a>1.1 在线安装</h4><p>安装地址：<a href=\"http://findbugs.cs.umd.edu/eclipse\">http://findbugs.cs.umd.edu/eclipse</a> ，</p>\n<p>在Eclipse—Help—Install New Software—Add—location中写入该地址，然后一路Next直到完成，重启Eclipse后，即可完成安装（可以任选一个项目，右键菜单中会出现Find Bugs）</p>\n<h4 id=\"1-2-离线安装\"><a href=\"#1-2-离线安装\" class=\"headerlink\" title=\"1.2 离线安装\"></a>1.2 离线安装</h4><p>下载地址为：<a href=\"http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror=ncu\"> http://downloads.sourceforge.net/project/findbugs/findbugs%20eclipse%20plugin/1.3.9/edu.umd.cs.findbugs.plugin.eclipse_1.3.9.20090821.zip?use_mirror&#x3D;ncu</a></p>\n<p>下载完成以后，将它放入Eclipse下的plusin文件夹，然后重启Eclipse即可。</p>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h3><p>FindBugs使用方法很简单，首先，在Window—Show View—Bug Explorer，打开Bug Explorer面板：</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_1.png\"></p>\n<p>选中需要检查的项目，右键选择FindBugs：</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_2.png\"></p>\n<p>然后会在BugExplorer中看到当前选择工程中存在的问题。分为四个等级：</p>\n<ul>\n<li>Scariest</li>\n<li>Scary</li>\n<li>Troubling</li>\n<li>Of Concern</li>\n</ul>\n<p>同时也可以打开Perspective界面查看Bug的详细信息及FindBugs给出的参考解决方案</p>\n<p><img src=\"http://q1tssra9v.bkt.clouddn.com/image/20150902/find_bugs_3.png\"></p>\n<h3 id=\"3-错误类型\"><a href=\"#3-错误类型\" class=\"headerlink\" title=\"3. 错误类型\"></a>3. 错误类型</h3><p>官方错误信息集合：<a href=\"http://findbugs.sourceforge.net/bugDescriptions.html\">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>\n"},{"title":"Fragment中ListView.setOnItemClickListener失效的问题","date":"2015-09-15T08:01:19.000Z","keywords":"Android , 问题记录","description":"Fragment中ListView.setOnItemClickListener失效的问题","top_img":"http://image.jucaiwy.com/image/20150905/android.jpg","cover":"http://image.jucaiwy.com/image/20150905/android.jpg","_content":"\n  今天在写代码的时候发现一个很奇怪的现象，当一个Activity继承自Fragment时，在其中设置ListView.setOnItemClickListener会没有作用，不会抛出异常，打断点也进不去，没有找到原因，但是找到了解决方案：\n \n在ListView的Item的Layout代码最外层的Layout中设置：\n\n\tandroid:clickable=\"false\"\n\tandroid:focusable=\"false\"\n \t\n ","source":"_posts/20150905Fragment中ListView.setOnItemClickListener失效的问题.markdown","raw":"---\n\ntitle: Fragment中ListView.setOnItemClickListener失效的问题\n\ndate: 2015-09-15 16:01:19\n\ntags: [Android , 问题记录 ]\n\ncategories: [Android , 问题记录 ]\n\nkeywords: Android , 问题记录 \n\ndescription: Fragment中ListView.setOnItemClickListener失效的问题\n\ntop_img: http://image.jucaiwy.com/image/20150905/android.jpg\n\ncover: http://image.jucaiwy.com/image/20150905/android.jpg\n\n---\n\n  今天在写代码的时候发现一个很奇怪的现象，当一个Activity继承自Fragment时，在其中设置ListView.setOnItemClickListener会没有作用，不会抛出异常，打断点也进不去，没有找到原因，但是找到了解决方案：\n \n在ListView的Item的Layout代码最外层的Layout中设置：\n\n\tandroid:clickable=\"false\"\n\tandroid:focusable=\"false\"\n \t\n ","slug":"20150905Fragment中ListView.setOnItemClickListener失效的问题","published":1,"updated":"2020-12-09T06:26:50.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278juri000cb3t17dorgxy9","content":"<p>  今天在写代码的时候发现一个很奇怪的现象，当一个Activity继承自Fragment时，在其中设置ListView.setOnItemClickListener会没有作用，不会抛出异常，打断点也进不去，没有找到原因，但是找到了解决方案：</p>\n<p>在ListView的Item的Layout代码最外层的Layout中设置：</p>\n<pre><code>android:clickable=&quot;false&quot;\nandroid:focusable=&quot;false&quot;\n \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>  今天在写代码的时候发现一个很奇怪的现象，当一个Activity继承自Fragment时，在其中设置ListView.setOnItemClickListener会没有作用，不会抛出异常，打断点也进不去，没有找到原因，但是找到了解决方案：</p>\n<p>在ListView的Item的Layout代码最外层的Layout中设置：</p>\n<pre><code>android:clickable=&quot;false&quot;\nandroid:focusable=&quot;false&quot;\n \n</code></pre>\n"},{"title":"Android横竖屏切换时生命周期变化","date":"2015-12-17T16:00:00.000Z","keywords":"Aandroid笔记，Android横竖屏切换","description":"Android横竖屏切换生命周期","top_img":"http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png","cover":"http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png","_content":"\n在开发中我们经常会遇到横竖屏切换的场景，那么在这些场景下，Activity的生命周期是一个怎么样的调用呢，本文中我们打印日志记录了一个Activity横竖屏切换时的生命周期的调用，方便以后开发过程中的查阅和记忆。\n\n### 1. 设置横屏\n在AndroidManifest.xml文件中对应的Activity加上如下标签:\n\n``` java\nandroid:screenOrientation=\"landscape\"\n```\n\n该Activity将会设置为横屏。\n\n### 2. 横屏旋转时生命周期\n横屏竖屏切换时，系统会走该应用所有生命周期\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png)\n\n这里需要注意，横屏切换竖屏时，会执行一次OnCreat和两次OnRestart。\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged2.png)\n\n\n竖屏切换横屏时，会执行一次OnRestart和一次OnCreat。\n\n### 3. 设置横竖屏切换时，不执行生命周期\n\n在AndroidManifest.xml文件中对应的Activity加上如下标签:\n\n``` java\nandroid:configChanges=\"orientation|keyboardHidden|screenSize\"\n```\n\n切记一定要加上后边的screenSize否则在4.0以上版本不生效。\n\n加上后，再次进行切换，则不会重复执行生命周期，只是执行\n\n``` java\n@Override\npublic void onConfigurationChanged(Configuration newConfig) {\n    Log.e(TAG, \"监听到横竖屏切换\");\n    super.onConfigurationChanged(newConfig);\n}\n```\n\n加上后执行过程如下：\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged3.png)\n\n\n需要注意的是，折叠屏适配许多工作都在**onConfigurationChanged**中完成\n\n\n\n\n","source":"_posts/20151218Android_横竖屏切换生命周期.md","raw":"---\n\ntitle: Android横竖屏切换时生命周期变化\n\ndate: 2015-12-18\n\ntags: [Android笔记 ,横竖屏切换 ,生命周期]\n\ncategories: Android\n\nkeywords: Aandroid笔记，Android横竖屏切换\n\ndescription: Android横竖屏切换生命周期\n\ntop_img: http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png\n\ncover: http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png\n---\n\n在开发中我们经常会遇到横竖屏切换的场景，那么在这些场景下，Activity的生命周期是一个怎么样的调用呢，本文中我们打印日志记录了一个Activity横竖屏切换时的生命周期的调用，方便以后开发过程中的查阅和记忆。\n\n### 1. 设置横屏\n在AndroidManifest.xml文件中对应的Activity加上如下标签:\n\n``` java\nandroid:screenOrientation=\"landscape\"\n```\n\n该Activity将会设置为横屏。\n\n### 2. 横屏旋转时生命周期\n横屏竖屏切换时，系统会走该应用所有生命周期\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png)\n\n这里需要注意，横屏切换竖屏时，会执行一次OnCreat和两次OnRestart。\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged2.png)\n\n\n竖屏切换横屏时，会执行一次OnRestart和一次OnCreat。\n\n### 3. 设置横竖屏切换时，不执行生命周期\n\n在AndroidManifest.xml文件中对应的Activity加上如下标签:\n\n``` java\nandroid:configChanges=\"orientation|keyboardHidden|screenSize\"\n```\n\n切记一定要加上后边的screenSize否则在4.0以上版本不生效。\n\n加上后，再次进行切换，则不会重复执行生命周期，只是执行\n\n``` java\n@Override\npublic void onConfigurationChanged(Configuration newConfig) {\n    Log.e(TAG, \"监听到横竖屏切换\");\n    super.onConfigurationChanged(newConfig);\n}\n```\n\n加上后执行过程如下：\n\n![](http://image.jucaiwy.com/image/20151218/ConfigurationChanged3.png)\n\n\n需要注意的是，折叠屏适配许多工作都在**onConfigurationChanged**中完成\n\n\n\n\n","slug":"20151218Android_横竖屏切换生命周期","published":1,"updated":"2020-12-09T06:28:22.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurj000db3t1gltw5j7t","content":"<p>在开发中我们经常会遇到横竖屏切换的场景，那么在这些场景下，Activity的生命周期是一个怎么样的调用呢，本文中我们打印日志记录了一个Activity横竖屏切换时的生命周期的调用，方便以后开发过程中的查阅和记忆。</p>\n<h3 id=\"1-设置横屏\"><a href=\"#1-设置横屏\" class=\"headerlink\" title=\"1. 设置横屏\"></a>1. 设置横屏</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:screenOrientation=<span class=\"string\">&quot;landscape&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>该Activity将会设置为横屏。</p>\n<h3 id=\"2-横屏旋转时生命周期\"><a href=\"#2-横屏旋转时生命周期\" class=\"headerlink\" title=\"2. 横屏旋转时生命周期\"></a>2. 横屏旋转时生命周期</h3><p>横屏竖屏切换时，系统会走该应用所有生命周期</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png\"></p>\n<p>这里需要注意，横屏切换竖屏时，会执行一次OnCreat和两次OnRestart。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged2.png\"></p>\n<p>竖屏切换横屏时，会执行一次OnRestart和一次OnCreat。</p>\n<h3 id=\"3-设置横竖屏切换时，不执行生命周期\"><a href=\"#3-设置横竖屏切换时，不执行生命周期\" class=\"headerlink\" title=\"3. 设置横竖屏切换时，不执行生命周期\"></a>3. 设置横竖屏切换时，不执行生命周期</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=<span class=\"string\">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>切记一定要加上后边的screenSize否则在4.0以上版本不生效。</p>\n<p>加上后，再次进行切换，则不会重复执行生命周期，只是执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onConfigurationChanged</span><span class=\"params\">(Configuration newConfig)</span> &#123;</span><br><span class=\"line\">    Log.e(TAG, <span class=\"string\">&quot;监听到横竖屏切换&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onConfigurationChanged(newConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上后执行过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged3.png\"></p>\n<p>需要注意的是，折叠屏适配许多工作都在<strong>onConfigurationChanged</strong>中完成</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发中我们经常会遇到横竖屏切换的场景，那么在这些场景下，Activity的生命周期是一个怎么样的调用呢，本文中我们打印日志记录了一个Activity横竖屏切换时的生命周期的调用，方便以后开发过程中的查阅和记忆。</p>\n<h3 id=\"1-设置横屏\"><a href=\"#1-设置横屏\" class=\"headerlink\" title=\"1. 设置横屏\"></a>1. 设置横屏</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:screenOrientation=<span class=\"string\">&quot;landscape&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>该Activity将会设置为横屏。</p>\n<h3 id=\"2-横屏旋转时生命周期\"><a href=\"#2-横屏旋转时生命周期\" class=\"headerlink\" title=\"2. 横屏旋转时生命周期\"></a>2. 横屏旋转时生命周期</h3><p>横屏竖屏切换时，系统会走该应用所有生命周期</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png\"></p>\n<p>这里需要注意，横屏切换竖屏时，会执行一次OnCreat和两次OnRestart。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged2.png\"></p>\n<p>竖屏切换横屏时，会执行一次OnRestart和一次OnCreat。</p>\n<h3 id=\"3-设置横竖屏切换时，不执行生命周期\"><a href=\"#3-设置横竖屏切换时，不执行生命周期\" class=\"headerlink\" title=\"3. 设置横竖屏切换时，不执行生命周期\"></a>3. 设置横竖屏切换时，不执行生命周期</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=<span class=\"string\">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>切记一定要加上后边的screenSize否则在4.0以上版本不生效。</p>\n<p>加上后，再次进行切换，则不会重复执行生命周期，只是执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onConfigurationChanged</span><span class=\"params\">(Configuration newConfig)</span> &#123;</span><br><span class=\"line\">    Log.e(TAG, <span class=\"string\">&quot;监听到横竖屏切换&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onConfigurationChanged(newConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上后执行过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151218/ConfigurationChanged3.png\"></p>\n<p>需要注意的是，折叠屏适配许多工作都在<strong>onConfigurationChanged</strong>中完成</p>\n"},{"title":"Android使用SQLite批量入库操作性能对比","date":"2015-10-16T06:28:28.000Z","keywords":"Android , SQLite数据库 , 数据库性能","description":"Android使用SQLite批量入库操作性能对比","top_img":"http://image.jucaiwy.com/image/20151016/sqlite_2.jpg","cover":"http://image.jucaiwy.com/image/20151016/sqlite_2.jpg","_content":"\n\nAndroid开发过程中经常会用到数据库，不可避免的会出现批量操作数据库，比如一次操作需要往数据库中插入一万条记录，这就需要进行批量操作，以下提供了四种批量操作方式，并分别进行对比。\n\n- 直接使用SQL语句进行插入\n- 直接使用SQL语句插入，添加事务\n- 使用ContentValues方式\n- 使用SQLiteStatement方式\n\n接下来对每一种方式的实现及性能分别进行对比（向统一数据库同一张表插入一万条数据）：\n\n\n### 1. 直接使用SQL语句进行插入\n\n实现代码：\n\n    @Override\n    public CommonResult addGroupMember()\n    {\n        String insertSQL = \"insert into \"\n                + SQLHelp.GROUP_MEMBER_TABLENAME\n                + \"(\"\n                + SQLHelp.GROUP_ID\n                + \",\"\n                + SQLHelp.MEMBERS_SUBS_ID\n                + \",\"\n                + SQLHelp.MEMBER_NICK_NAME\n                + \",\"\n                + SQLHelp.MEMBER_ROLE\n                + \",\"\n                + SQLHelp.MEMBER_JID\n                + \",\"\n                + SQLHelp.MEM_UNION_KEY\n                + \",\"\n                + SQLHelp.CREAT_TIME\n                + \", \"\n                + SQLHelp.UPDATE_TIME\n                + \",\"\n                + SQLHelp.ORDER_ID\n                + \",\"\n                + SQLHelp.EXT\n                + \" ) values(458906628,85469875,'xinwei',2,100856,18663,'2015-06-08','2015-06-09',123456,'beizhu')\";\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // 插入一万条\n        for (int i = 0; i < 10000; i++)\n        {\n            sqlDatabase.execSQL(insertSQL);\n        }\n\n        return null;\n    }\n\n\n计时结果如下： \n\n![](http://image.jucaiwy.com/image/20151016/20151016135641277.png)\n\n### 2. 直接使用SQL语句插入，添加事务\n\n这种方法是在第一种方法的基础上，添加事务操作：\n\n    // 开始\n    sqlDatabase.beginTransaction();\n    \n    // 设置为成功\n    sqlDatabase.setTransactionSuccessful();\n    \n    // 结束\n    sqlDatabase.endTransaction();\n\n在操作数据库之前设置为开始、数据库语句执行完毕后，设置数据库事务为Success，当执行到sqlDatabase.endTransaction()时，系统会判断之前是否有设置成功标志，如果没有则认为插入失败，数据库自动进行回滚操作。\n \n执行代码如下：\n\n\t@Override\n    public CommonResult addGroupMemberThing()\n    {\n        String insertSQL = \"insert into \"\n                + SQLHelp.GROUP_MEMBER_TABLENAME\n                + \"(\"\n                + SQLHelp.GROUP_ID\n                + \",\"\n                + SQLHelp.MEMBERS_SUBS_ID\n                + \",\"\n                + SQLHelp.MEMBER_NICK_NAME\n                + \",\"\n                + SQLHelp.MEMBER_ROLE\n                + \",\"\n                + SQLHelp.MEMBER_JID\n                + \",\"\n                + SQLHelp.MEM_UNION_KEY\n                + \",\"\n                + SQLHelp.CREAT_TIME\n                + \", \"\n                + SQLHelp.UPDATE_TIME\n                + \",\"\n                + SQLHelp.ORDER_ID\n                + \",\"\n                + SQLHelp.EXT\n                + \" ) values(458906628,85469875,'xinwei',2,100856,18663,'2015-06-08','2015-06-09',123456,'beizhu')\";\n\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // 开始\n        sqlDatabase.beginTransaction();\n\n        // 循环一万次\n        for (int i = 0; i < 10000; i++)\n        {\n            // 执行语句\n            sqlDatabase.execSQL(insertSQL);\n        }\n\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n\n        // 结束\n        sqlDatabase.endTransaction();\n\n        return null;\n    }\n\n\n执行结束后，结果如下：\n\n![](http://image.jucaiwy.com/image/20151016/20151016141825629.png)\n\n### 3. 使用ContentValues方式\n\n使用ContentValues的好处是可以动态拼接SQL语句进行执行，有更好的灵活性，可以直接使用对象进行赋值，代码如下：\n\n\t@Override\n    public CommonResult addGroupMemberContentValues(CamTalkGroupMemberInfo memberInfo)\n    {\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n        try\n        {\n            sqlDatabase.beginTransaction();\n\n            ContentValues values = new ContentValues();\n            if (memberInfo != null)\n            {\n                values.put(SQLHelp.GROUP_ID, memberInfo.getGroupID());\n                values.put(SQLHelp.MEMBERS_SUBS_ID, memberInfo.getMemberSubsID());\n                values.put(SQLHelp.MEMBER_NICK_NAME, memberInfo.getMemberNickName());\n                values.put(SQLHelp.MEMBER_ROLE, memberInfo.getMemberRole());\n                values.put(SQLHelp.MEMBER_JID, memberInfo.getMemberJID());\n                values.put(SQLHelp.MEM_UNION_KEY, memberInfo.getMemUnionKey());\n                values.put(SQLHelp.CREAT_TIME, convertDate2String(memberInfo.getCreatTime()));\n                values.put(SQLHelp.UPDATE_TIME, convertDate2String(memberInfo.getUpdateTime()));\n                values.put(SQLHelp.ORDER_ID, memberInfo.getOrderID());\n                values.put(SQLHelp.EXT, memberInfo.getExt());\n\n                // 插入10000次\n                for (int i = 0; i < 10000; i++)\n                {\n                    sqlDatabase.insert(SQLHelp.GROUP_MEMBER_TABLENAME, null, values);\n                }\n            }\n            // 成功\n            sqlDatabase.setTransactionSuccessful();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            // 结束\n            sqlDatabase.endTransaction();\n            sqlDatabase.close();\n        }\n\n        return null;\n    }\n\n执行完毕后，结果如下：\n\n![](http://image.jucaiwy.com/image/20151016/20151016142239726.png)\n\n### 4. 使用SQLiteStatement方式\n\n这个方法与上边ContentValues方式实现大致类似，不同的是需要自己编写SQL语句：\n\n\t@Override\n    public CommonResult addGroupMemberStatement(CamTalkGroupMemberInfo memberInfo)\n    {\n        SQLiteDatabase sqlDatabase = null;\n\n        String insertSQL = \"insert into \" + SQLHelp.GROUP_MEMBER_TABLENAME + \"(\" + SQLHelp.GROUP_ID\n                + \",\" + SQLHelp.MEMBERS_SUBS_ID + \",\" + SQLHelp.MEMBER_NICK_NAME + \",\"\n                + SQLHelp.MEMBER_ROLE + \",\" + SQLHelp.MEMBER_JID + \",\" + SQLHelp.MEM_UNION_KEY\n                + \",\" + SQLHelp.CREAT_TIME + \", \" + SQLHelp.UPDATE_TIME + \",\" + SQLHelp.ORDER_ID\n                + \",\" + SQLHelp.EXT + \") values \" + \"(?,?,?,?,?,?,?,?,?,?)\";\n\n        try\n        {\n            sqlDatabase = sqlHelp.getWritableDatabase();\n\n            // SQL事物控制-结束之前检测是否成功，没有成功则自动回滚\n            sqlDatabase.beginTransaction();\n\n            SQLiteStatement stat = sqlDatabase.compileStatement(insertSQL);\n            stat.bindLong(1, memberInfo.getGroupID());\n            stat.bindString(2, memberInfo.getMemberSubsID());\n            stat.bindString(3, memberInfo.getMemberNickName());\n            stat.bindLong(4, memberInfo.getMemberRole());\n            stat.bindString(5, memberInfo.getMemberJID());\n            stat.bindString(6, memberInfo.getMemUnionKey());\n            stat.bindString(7, convertDate2String(memberInfo.getCreatTime()));\n            stat.bindString(8, convertDate2String(memberInfo.getUpdateTime()));\n            stat.bindString(9, memberInfo.getOrderID());\n            stat.bindString(10, memberInfo.getExt());\n\n            // 插入10000次\n            for (int i = 0; i < 10000; i++)\n            {\n                stat.executeInsert();\n            }\n\n            // 成功\n            sqlDatabase.setTransactionSuccessful();\n        }\n        catch (SQLException e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            // 结束\n            sqlDatabase.endTransaction();\n            sqlDatabase.close();\n        }\n        return null;\n    }\n\n执行结果如下： \n\n![](http://image.jucaiwy.com/image/20151016/20151016142545977.png)\n\n### 5. 总的对比图\n\n![](http://image.jucaiwy.com/image/20151016/sqlite.png)\n\n综上，对比四种结果，使用SQLiteStatement 插入最快，插入一万条数据，只需三秒钟，性能最好。","source":"_posts/20151016Android使用SQLite批量入库操作性能对比.markdown","raw":"---\n\ntitle: Android使用SQLite批量入库操作性能对比\n\ndate: 2015-10-16 14:28:28\n\ntags: [Android , SQLite数据库 , 数据库性能]\n\ncategories: Android\n\nkeywords: Android , SQLite数据库 , 数据库性能\n\ndescription: Android使用SQLite批量入库操作性能对比\n\ntop_img: http://image.jucaiwy.com/image/20151016/sqlite_2.jpg\n\ncover: http://image.jucaiwy.com/image/20151016/sqlite_2.jpg\n\n---\n\n\nAndroid开发过程中经常会用到数据库，不可避免的会出现批量操作数据库，比如一次操作需要往数据库中插入一万条记录，这就需要进行批量操作，以下提供了四种批量操作方式，并分别进行对比。\n\n- 直接使用SQL语句进行插入\n- 直接使用SQL语句插入，添加事务\n- 使用ContentValues方式\n- 使用SQLiteStatement方式\n\n接下来对每一种方式的实现及性能分别进行对比（向统一数据库同一张表插入一万条数据）：\n\n\n### 1. 直接使用SQL语句进行插入\n\n实现代码：\n\n    @Override\n    public CommonResult addGroupMember()\n    {\n        String insertSQL = \"insert into \"\n                + SQLHelp.GROUP_MEMBER_TABLENAME\n                + \"(\"\n                + SQLHelp.GROUP_ID\n                + \",\"\n                + SQLHelp.MEMBERS_SUBS_ID\n                + \",\"\n                + SQLHelp.MEMBER_NICK_NAME\n                + \",\"\n                + SQLHelp.MEMBER_ROLE\n                + \",\"\n                + SQLHelp.MEMBER_JID\n                + \",\"\n                + SQLHelp.MEM_UNION_KEY\n                + \",\"\n                + SQLHelp.CREAT_TIME\n                + \", \"\n                + SQLHelp.UPDATE_TIME\n                + \",\"\n                + SQLHelp.ORDER_ID\n                + \",\"\n                + SQLHelp.EXT\n                + \" ) values(458906628,85469875,'xinwei',2,100856,18663,'2015-06-08','2015-06-09',123456,'beizhu')\";\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // 插入一万条\n        for (int i = 0; i < 10000; i++)\n        {\n            sqlDatabase.execSQL(insertSQL);\n        }\n\n        return null;\n    }\n\n\n计时结果如下： \n\n![](http://image.jucaiwy.com/image/20151016/20151016135641277.png)\n\n### 2. 直接使用SQL语句插入，添加事务\n\n这种方法是在第一种方法的基础上，添加事务操作：\n\n    // 开始\n    sqlDatabase.beginTransaction();\n    \n    // 设置为成功\n    sqlDatabase.setTransactionSuccessful();\n    \n    // 结束\n    sqlDatabase.endTransaction();\n\n在操作数据库之前设置为开始、数据库语句执行完毕后，设置数据库事务为Success，当执行到sqlDatabase.endTransaction()时，系统会判断之前是否有设置成功标志，如果没有则认为插入失败，数据库自动进行回滚操作。\n \n执行代码如下：\n\n\t@Override\n    public CommonResult addGroupMemberThing()\n    {\n        String insertSQL = \"insert into \"\n                + SQLHelp.GROUP_MEMBER_TABLENAME\n                + \"(\"\n                + SQLHelp.GROUP_ID\n                + \",\"\n                + SQLHelp.MEMBERS_SUBS_ID\n                + \",\"\n                + SQLHelp.MEMBER_NICK_NAME\n                + \",\"\n                + SQLHelp.MEMBER_ROLE\n                + \",\"\n                + SQLHelp.MEMBER_JID\n                + \",\"\n                + SQLHelp.MEM_UNION_KEY\n                + \",\"\n                + SQLHelp.CREAT_TIME\n                + \", \"\n                + SQLHelp.UPDATE_TIME\n                + \",\"\n                + SQLHelp.ORDER_ID\n                + \",\"\n                + SQLHelp.EXT\n                + \" ) values(458906628,85469875,'xinwei',2,100856,18663,'2015-06-08','2015-06-09',123456,'beizhu')\";\n\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // 开始\n        sqlDatabase.beginTransaction();\n\n        // 循环一万次\n        for (int i = 0; i < 10000; i++)\n        {\n            // 执行语句\n            sqlDatabase.execSQL(insertSQL);\n        }\n\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n\n        // 结束\n        sqlDatabase.endTransaction();\n\n        return null;\n    }\n\n\n执行结束后，结果如下：\n\n![](http://image.jucaiwy.com/image/20151016/20151016141825629.png)\n\n### 3. 使用ContentValues方式\n\n使用ContentValues的好处是可以动态拼接SQL语句进行执行，有更好的灵活性，可以直接使用对象进行赋值，代码如下：\n\n\t@Override\n    public CommonResult addGroupMemberContentValues(CamTalkGroupMemberInfo memberInfo)\n    {\n        SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n        try\n        {\n            sqlDatabase.beginTransaction();\n\n            ContentValues values = new ContentValues();\n            if (memberInfo != null)\n            {\n                values.put(SQLHelp.GROUP_ID, memberInfo.getGroupID());\n                values.put(SQLHelp.MEMBERS_SUBS_ID, memberInfo.getMemberSubsID());\n                values.put(SQLHelp.MEMBER_NICK_NAME, memberInfo.getMemberNickName());\n                values.put(SQLHelp.MEMBER_ROLE, memberInfo.getMemberRole());\n                values.put(SQLHelp.MEMBER_JID, memberInfo.getMemberJID());\n                values.put(SQLHelp.MEM_UNION_KEY, memberInfo.getMemUnionKey());\n                values.put(SQLHelp.CREAT_TIME, convertDate2String(memberInfo.getCreatTime()));\n                values.put(SQLHelp.UPDATE_TIME, convertDate2String(memberInfo.getUpdateTime()));\n                values.put(SQLHelp.ORDER_ID, memberInfo.getOrderID());\n                values.put(SQLHelp.EXT, memberInfo.getExt());\n\n                // 插入10000次\n                for (int i = 0; i < 10000; i++)\n                {\n                    sqlDatabase.insert(SQLHelp.GROUP_MEMBER_TABLENAME, null, values);\n                }\n            }\n            // 成功\n            sqlDatabase.setTransactionSuccessful();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            // 结束\n            sqlDatabase.endTransaction();\n            sqlDatabase.close();\n        }\n\n        return null;\n    }\n\n执行完毕后，结果如下：\n\n![](http://image.jucaiwy.com/image/20151016/20151016142239726.png)\n\n### 4. 使用SQLiteStatement方式\n\n这个方法与上边ContentValues方式实现大致类似，不同的是需要自己编写SQL语句：\n\n\t@Override\n    public CommonResult addGroupMemberStatement(CamTalkGroupMemberInfo memberInfo)\n    {\n        SQLiteDatabase sqlDatabase = null;\n\n        String insertSQL = \"insert into \" + SQLHelp.GROUP_MEMBER_TABLENAME + \"(\" + SQLHelp.GROUP_ID\n                + \",\" + SQLHelp.MEMBERS_SUBS_ID + \",\" + SQLHelp.MEMBER_NICK_NAME + \",\"\n                + SQLHelp.MEMBER_ROLE + \",\" + SQLHelp.MEMBER_JID + \",\" + SQLHelp.MEM_UNION_KEY\n                + \",\" + SQLHelp.CREAT_TIME + \", \" + SQLHelp.UPDATE_TIME + \",\" + SQLHelp.ORDER_ID\n                + \",\" + SQLHelp.EXT + \") values \" + \"(?,?,?,?,?,?,?,?,?,?)\";\n\n        try\n        {\n            sqlDatabase = sqlHelp.getWritableDatabase();\n\n            // SQL事物控制-结束之前检测是否成功，没有成功则自动回滚\n            sqlDatabase.beginTransaction();\n\n            SQLiteStatement stat = sqlDatabase.compileStatement(insertSQL);\n            stat.bindLong(1, memberInfo.getGroupID());\n            stat.bindString(2, memberInfo.getMemberSubsID());\n            stat.bindString(3, memberInfo.getMemberNickName());\n            stat.bindLong(4, memberInfo.getMemberRole());\n            stat.bindString(5, memberInfo.getMemberJID());\n            stat.bindString(6, memberInfo.getMemUnionKey());\n            stat.bindString(7, convertDate2String(memberInfo.getCreatTime()));\n            stat.bindString(8, convertDate2String(memberInfo.getUpdateTime()));\n            stat.bindString(9, memberInfo.getOrderID());\n            stat.bindString(10, memberInfo.getExt());\n\n            // 插入10000次\n            for (int i = 0; i < 10000; i++)\n            {\n                stat.executeInsert();\n            }\n\n            // 成功\n            sqlDatabase.setTransactionSuccessful();\n        }\n        catch (SQLException e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            // 结束\n            sqlDatabase.endTransaction();\n            sqlDatabase.close();\n        }\n        return null;\n    }\n\n执行结果如下： \n\n![](http://image.jucaiwy.com/image/20151016/20151016142545977.png)\n\n### 5. 总的对比图\n\n![](http://image.jucaiwy.com/image/20151016/sqlite.png)\n\n综上，对比四种结果，使用SQLiteStatement 插入最快，插入一万条数据，只需三秒钟，性能最好。","slug":"20151016Android使用SQLite批量入库操作性能对比","published":1,"updated":"2020-12-09T06:27:46.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurl000hb3t1eu2d8tob","content":"<p>Android开发过程中经常会用到数据库，不可避免的会出现批量操作数据库，比如一次操作需要往数据库中插入一万条记录，这就需要进行批量操作，以下提供了四种批量操作方式，并分别进行对比。</p>\n<ul>\n<li>直接使用SQL语句进行插入</li>\n<li>直接使用SQL语句插入，添加事务</li>\n<li>使用ContentValues方式</li>\n<li>使用SQLiteStatement方式</li>\n</ul>\n<p>接下来对每一种方式的实现及性能分别进行对比（向统一数据库同一张表插入一万条数据）：</p>\n<h3 id=\"1-直接使用SQL语句进行插入\"><a href=\"#1-直接使用SQL语句进行插入\" class=\"headerlink\" title=\"1. 直接使用SQL语句进行插入\"></a>1. 直接使用SQL语句进行插入</h3><p>实现代码：</p>\n<pre><code>@Override\npublic CommonResult addGroupMember()\n&#123;\n    String insertSQL = &quot;insert into &quot;\n            + SQLHelp.GROUP_MEMBER_TABLENAME\n            + &quot;(&quot;\n            + SQLHelp.GROUP_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBERS_SUBS_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_NICK_NAME\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_JID\n            + &quot;,&quot;\n            + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot;\n            + SQLHelp.CREAT_TIME\n            + &quot;, &quot;\n            + SQLHelp.UPDATE_TIME\n            + &quot;,&quot;\n            + SQLHelp.ORDER_ID\n            + &quot;,&quot;\n            + SQLHelp.EXT\n            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n    // 插入一万条\n    for (int i = 0; i &lt; 10000; i++)\n    &#123;\n        sqlDatabase.execSQL(insertSQL);\n    &#125;\n\n    return null;\n&#125;\n</code></pre>\n<p>计时结果如下： </p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016135641277.png\"></p>\n<h3 id=\"2-直接使用SQL语句插入，添加事务\"><a href=\"#2-直接使用SQL语句插入，添加事务\" class=\"headerlink\" title=\"2. 直接使用SQL语句插入，添加事务\"></a>2. 直接使用SQL语句插入，添加事务</h3><p>这种方法是在第一种方法的基础上，添加事务操作：</p>\n<pre><code>// 开始\nsqlDatabase.beginTransaction();\n\n// 设置为成功\nsqlDatabase.setTransactionSuccessful();\n\n// 结束\nsqlDatabase.endTransaction();\n</code></pre>\n<p>在操作数据库之前设置为开始、数据库语句执行完毕后，设置数据库事务为Success，当执行到sqlDatabase.endTransaction()时，系统会判断之前是否有设置成功标志，如果没有则认为插入失败，数据库自动进行回滚操作。</p>\n<p>执行代码如下：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberThing()\n&#123;\n    String insertSQL = &quot;insert into &quot;\n            + SQLHelp.GROUP_MEMBER_TABLENAME\n            + &quot;(&quot;\n            + SQLHelp.GROUP_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBERS_SUBS_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_NICK_NAME\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_JID\n            + &quot;,&quot;\n            + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot;\n            + SQLHelp.CREAT_TIME\n            + &quot;, &quot;\n            + SQLHelp.UPDATE_TIME\n            + &quot;,&quot;\n            + SQLHelp.ORDER_ID\n            + &quot;,&quot;\n            + SQLHelp.EXT\n            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;\n\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n    // 开始\n    sqlDatabase.beginTransaction();\n\n    // 循环一万次\n    for (int i = 0; i &lt; 10000; i++)\n    &#123;\n        // 执行语句\n        sqlDatabase.execSQL(insertSQL);\n    &#125;\n\n    // 成功\n    sqlDatabase.setTransactionSuccessful();\n\n    // 结束\n    sqlDatabase.endTransaction();\n\n    return null;\n&#125;\n</code></pre>\n<p>执行结束后，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016141825629.png\"></p>\n<h3 id=\"3-使用ContentValues方式\"><a href=\"#3-使用ContentValues方式\" class=\"headerlink\" title=\"3. 使用ContentValues方式\"></a>3. 使用ContentValues方式</h3><p>使用ContentValues的好处是可以动态拼接SQL语句进行执行，有更好的灵活性，可以直接使用对象进行赋值，代码如下：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberContentValues(CamTalkGroupMemberInfo memberInfo)\n&#123;\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n    try\n    &#123;\n        sqlDatabase.beginTransaction();\n\n        ContentValues values = new ContentValues();\n        if (memberInfo != null)\n        &#123;\n            values.put(SQLHelp.GROUP_ID, memberInfo.getGroupID());\n            values.put(SQLHelp.MEMBERS_SUBS_ID, memberInfo.getMemberSubsID());\n            values.put(SQLHelp.MEMBER_NICK_NAME, memberInfo.getMemberNickName());\n            values.put(SQLHelp.MEMBER_ROLE, memberInfo.getMemberRole());\n            values.put(SQLHelp.MEMBER_JID, memberInfo.getMemberJID());\n            values.put(SQLHelp.MEM_UNION_KEY, memberInfo.getMemUnionKey());\n            values.put(SQLHelp.CREAT_TIME, convertDate2String(memberInfo.getCreatTime()));\n            values.put(SQLHelp.UPDATE_TIME, convertDate2String(memberInfo.getUpdateTime()));\n            values.put(SQLHelp.ORDER_ID, memberInfo.getOrderID());\n            values.put(SQLHelp.EXT, memberInfo.getExt());\n\n            // 插入10000次\n            for (int i = 0; i &lt; 10000; i++)\n            &#123;\n                sqlDatabase.insert(SQLHelp.GROUP_MEMBER_TABLENAME, null, values);\n            &#125;\n        &#125;\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n    &#125;\n    catch (Exception e)\n    &#123;\n        e.printStackTrace();\n    &#125;\n    finally\n    &#123;\n        // 结束\n        sqlDatabase.endTransaction();\n        sqlDatabase.close();\n    &#125;\n\n    return null;\n&#125;\n</code></pre>\n<p>执行完毕后，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016142239726.png\"></p>\n<h3 id=\"4-使用SQLiteStatement方式\"><a href=\"#4-使用SQLiteStatement方式\" class=\"headerlink\" title=\"4. 使用SQLiteStatement方式\"></a>4. 使用SQLiteStatement方式</h3><p>这个方法与上边ContentValues方式实现大致类似，不同的是需要自己编写SQL语句：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberStatement(CamTalkGroupMemberInfo memberInfo)\n&#123;\n    SQLiteDatabase sqlDatabase = null;\n\n    String insertSQL = &quot;insert into &quot; + SQLHelp.GROUP_MEMBER_TABLENAME + &quot;(&quot; + SQLHelp.GROUP_ID\n            + &quot;,&quot; + SQLHelp.MEMBERS_SUBS_ID + &quot;,&quot; + SQLHelp.MEMBER_NICK_NAME + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE + &quot;,&quot; + SQLHelp.MEMBER_JID + &quot;,&quot; + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot; + SQLHelp.CREAT_TIME + &quot;, &quot; + SQLHelp.UPDATE_TIME + &quot;,&quot; + SQLHelp.ORDER_ID\n            + &quot;,&quot; + SQLHelp.EXT + &quot;) values &quot; + &quot;(?,?,?,?,?,?,?,?,?,?)&quot;;\n\n    try\n    &#123;\n        sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // SQL事物控制-结束之前检测是否成功，没有成功则自动回滚\n        sqlDatabase.beginTransaction();\n\n        SQLiteStatement stat = sqlDatabase.compileStatement(insertSQL);\n        stat.bindLong(1, memberInfo.getGroupID());\n        stat.bindString(2, memberInfo.getMemberSubsID());\n        stat.bindString(3, memberInfo.getMemberNickName());\n        stat.bindLong(4, memberInfo.getMemberRole());\n        stat.bindString(5, memberInfo.getMemberJID());\n        stat.bindString(6, memberInfo.getMemUnionKey());\n        stat.bindString(7, convertDate2String(memberInfo.getCreatTime()));\n        stat.bindString(8, convertDate2String(memberInfo.getUpdateTime()));\n        stat.bindString(9, memberInfo.getOrderID());\n        stat.bindString(10, memberInfo.getExt());\n\n        // 插入10000次\n        for (int i = 0; i &lt; 10000; i++)\n        &#123;\n            stat.executeInsert();\n        &#125;\n\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n    &#125;\n    catch (SQLException e)\n    &#123;\n        e.printStackTrace();\n    &#125;\n    finally\n    &#123;\n        // 结束\n        sqlDatabase.endTransaction();\n        sqlDatabase.close();\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>执行结果如下： </p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016142545977.png\"></p>\n<h3 id=\"5-总的对比图\"><a href=\"#5-总的对比图\" class=\"headerlink\" title=\"5. 总的对比图\"></a>5. 总的对比图</h3><p><img src=\"http://image.jucaiwy.com/image/20151016/sqlite.png\"></p>\n<p>综上，对比四种结果，使用SQLiteStatement 插入最快，插入一万条数据，只需三秒钟，性能最好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android开发过程中经常会用到数据库，不可避免的会出现批量操作数据库，比如一次操作需要往数据库中插入一万条记录，这就需要进行批量操作，以下提供了四种批量操作方式，并分别进行对比。</p>\n<ul>\n<li>直接使用SQL语句进行插入</li>\n<li>直接使用SQL语句插入，添加事务</li>\n<li>使用ContentValues方式</li>\n<li>使用SQLiteStatement方式</li>\n</ul>\n<p>接下来对每一种方式的实现及性能分别进行对比（向统一数据库同一张表插入一万条数据）：</p>\n<h3 id=\"1-直接使用SQL语句进行插入\"><a href=\"#1-直接使用SQL语句进行插入\" class=\"headerlink\" title=\"1. 直接使用SQL语句进行插入\"></a>1. 直接使用SQL语句进行插入</h3><p>实现代码：</p>\n<pre><code>@Override\npublic CommonResult addGroupMember()\n&#123;\n    String insertSQL = &quot;insert into &quot;\n            + SQLHelp.GROUP_MEMBER_TABLENAME\n            + &quot;(&quot;\n            + SQLHelp.GROUP_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBERS_SUBS_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_NICK_NAME\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_JID\n            + &quot;,&quot;\n            + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot;\n            + SQLHelp.CREAT_TIME\n            + &quot;, &quot;\n            + SQLHelp.UPDATE_TIME\n            + &quot;,&quot;\n            + SQLHelp.ORDER_ID\n            + &quot;,&quot;\n            + SQLHelp.EXT\n            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n    // 插入一万条\n    for (int i = 0; i &lt; 10000; i++)\n    &#123;\n        sqlDatabase.execSQL(insertSQL);\n    &#125;\n\n    return null;\n&#125;\n</code></pre>\n<p>计时结果如下： </p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016135641277.png\"></p>\n<h3 id=\"2-直接使用SQL语句插入，添加事务\"><a href=\"#2-直接使用SQL语句插入，添加事务\" class=\"headerlink\" title=\"2. 直接使用SQL语句插入，添加事务\"></a>2. 直接使用SQL语句插入，添加事务</h3><p>这种方法是在第一种方法的基础上，添加事务操作：</p>\n<pre><code>// 开始\nsqlDatabase.beginTransaction();\n\n// 设置为成功\nsqlDatabase.setTransactionSuccessful();\n\n// 结束\nsqlDatabase.endTransaction();\n</code></pre>\n<p>在操作数据库之前设置为开始、数据库语句执行完毕后，设置数据库事务为Success，当执行到sqlDatabase.endTransaction()时，系统会判断之前是否有设置成功标志，如果没有则认为插入失败，数据库自动进行回滚操作。</p>\n<p>执行代码如下：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberThing()\n&#123;\n    String insertSQL = &quot;insert into &quot;\n            + SQLHelp.GROUP_MEMBER_TABLENAME\n            + &quot;(&quot;\n            + SQLHelp.GROUP_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBERS_SUBS_ID\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_NICK_NAME\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE\n            + &quot;,&quot;\n            + SQLHelp.MEMBER_JID\n            + &quot;,&quot;\n            + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot;\n            + SQLHelp.CREAT_TIME\n            + &quot;, &quot;\n            + SQLHelp.UPDATE_TIME\n            + &quot;,&quot;\n            + SQLHelp.ORDER_ID\n            + &quot;,&quot;\n            + SQLHelp.EXT\n            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;\n\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n\n    // 开始\n    sqlDatabase.beginTransaction();\n\n    // 循环一万次\n    for (int i = 0; i &lt; 10000; i++)\n    &#123;\n        // 执行语句\n        sqlDatabase.execSQL(insertSQL);\n    &#125;\n\n    // 成功\n    sqlDatabase.setTransactionSuccessful();\n\n    // 结束\n    sqlDatabase.endTransaction();\n\n    return null;\n&#125;\n</code></pre>\n<p>执行结束后，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016141825629.png\"></p>\n<h3 id=\"3-使用ContentValues方式\"><a href=\"#3-使用ContentValues方式\" class=\"headerlink\" title=\"3. 使用ContentValues方式\"></a>3. 使用ContentValues方式</h3><p>使用ContentValues的好处是可以动态拼接SQL语句进行执行，有更好的灵活性，可以直接使用对象进行赋值，代码如下：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberContentValues(CamTalkGroupMemberInfo memberInfo)\n&#123;\n    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();\n    try\n    &#123;\n        sqlDatabase.beginTransaction();\n\n        ContentValues values = new ContentValues();\n        if (memberInfo != null)\n        &#123;\n            values.put(SQLHelp.GROUP_ID, memberInfo.getGroupID());\n            values.put(SQLHelp.MEMBERS_SUBS_ID, memberInfo.getMemberSubsID());\n            values.put(SQLHelp.MEMBER_NICK_NAME, memberInfo.getMemberNickName());\n            values.put(SQLHelp.MEMBER_ROLE, memberInfo.getMemberRole());\n            values.put(SQLHelp.MEMBER_JID, memberInfo.getMemberJID());\n            values.put(SQLHelp.MEM_UNION_KEY, memberInfo.getMemUnionKey());\n            values.put(SQLHelp.CREAT_TIME, convertDate2String(memberInfo.getCreatTime()));\n            values.put(SQLHelp.UPDATE_TIME, convertDate2String(memberInfo.getUpdateTime()));\n            values.put(SQLHelp.ORDER_ID, memberInfo.getOrderID());\n            values.put(SQLHelp.EXT, memberInfo.getExt());\n\n            // 插入10000次\n            for (int i = 0; i &lt; 10000; i++)\n            &#123;\n                sqlDatabase.insert(SQLHelp.GROUP_MEMBER_TABLENAME, null, values);\n            &#125;\n        &#125;\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n    &#125;\n    catch (Exception e)\n    &#123;\n        e.printStackTrace();\n    &#125;\n    finally\n    &#123;\n        // 结束\n        sqlDatabase.endTransaction();\n        sqlDatabase.close();\n    &#125;\n\n    return null;\n&#125;\n</code></pre>\n<p>执行完毕后，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016142239726.png\"></p>\n<h3 id=\"4-使用SQLiteStatement方式\"><a href=\"#4-使用SQLiteStatement方式\" class=\"headerlink\" title=\"4. 使用SQLiteStatement方式\"></a>4. 使用SQLiteStatement方式</h3><p>这个方法与上边ContentValues方式实现大致类似，不同的是需要自己编写SQL语句：</p>\n<pre><code>@Override\npublic CommonResult addGroupMemberStatement(CamTalkGroupMemberInfo memberInfo)\n&#123;\n    SQLiteDatabase sqlDatabase = null;\n\n    String insertSQL = &quot;insert into &quot; + SQLHelp.GROUP_MEMBER_TABLENAME + &quot;(&quot; + SQLHelp.GROUP_ID\n            + &quot;,&quot; + SQLHelp.MEMBERS_SUBS_ID + &quot;,&quot; + SQLHelp.MEMBER_NICK_NAME + &quot;,&quot;\n            + SQLHelp.MEMBER_ROLE + &quot;,&quot; + SQLHelp.MEMBER_JID + &quot;,&quot; + SQLHelp.MEM_UNION_KEY\n            + &quot;,&quot; + SQLHelp.CREAT_TIME + &quot;, &quot; + SQLHelp.UPDATE_TIME + &quot;,&quot; + SQLHelp.ORDER_ID\n            + &quot;,&quot; + SQLHelp.EXT + &quot;) values &quot; + &quot;(?,?,?,?,?,?,?,?,?,?)&quot;;\n\n    try\n    &#123;\n        sqlDatabase = sqlHelp.getWritableDatabase();\n\n        // SQL事物控制-结束之前检测是否成功，没有成功则自动回滚\n        sqlDatabase.beginTransaction();\n\n        SQLiteStatement stat = sqlDatabase.compileStatement(insertSQL);\n        stat.bindLong(1, memberInfo.getGroupID());\n        stat.bindString(2, memberInfo.getMemberSubsID());\n        stat.bindString(3, memberInfo.getMemberNickName());\n        stat.bindLong(4, memberInfo.getMemberRole());\n        stat.bindString(5, memberInfo.getMemberJID());\n        stat.bindString(6, memberInfo.getMemUnionKey());\n        stat.bindString(7, convertDate2String(memberInfo.getCreatTime()));\n        stat.bindString(8, convertDate2String(memberInfo.getUpdateTime()));\n        stat.bindString(9, memberInfo.getOrderID());\n        stat.bindString(10, memberInfo.getExt());\n\n        // 插入10000次\n        for (int i = 0; i &lt; 10000; i++)\n        &#123;\n            stat.executeInsert();\n        &#125;\n\n        // 成功\n        sqlDatabase.setTransactionSuccessful();\n    &#125;\n    catch (SQLException e)\n    &#123;\n        e.printStackTrace();\n    &#125;\n    finally\n    &#123;\n        // 结束\n        sqlDatabase.endTransaction();\n        sqlDatabase.close();\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>执行结果如下： </p>\n<p><img src=\"http://image.jucaiwy.com/image/20151016/20151016142545977.png\"></p>\n<h3 id=\"5-总的对比图\"><a href=\"#5-总的对比图\" class=\"headerlink\" title=\"5. 总的对比图\"></a>5. 总的对比图</h3><p><img src=\"http://image.jucaiwy.com/image/20151016/sqlite.png\"></p>\n<p>综上，对比四种结果，使用SQLiteStatement 插入最快，插入一万条数据，只需三秒钟，性能最好。</p>\n"},{"title":"EventBus简介及使用","date":"2016-01-06T02:16:05.000Z","keywords":"EventBus , 观察者模式","description":"EventBus简介及使用","top_img":"http://image.jucaiwy.com/image/20160106/event_bus.png","cover":"http://image.jucaiwy.com/image/20160106/event_bus.png","_content":"\nEventBus是一个Android下典型的“订阅发布模式”框架，该模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听一个主题对象，通过这种方式对订阅者和主题发布者进行充分解耦，主要用于Android组件间相互通信、线程间互相通信及其他线程与UI线程之间互相通信等。代替了传统的Handler、BroadCastReceiver、Interface回调等通信方式，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。\n\n\n### 1. 项目地址\n\nEventBus开源项目的项目地址：[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n### 2. 相关概念\n\n#### 2.1 事件：\n我所理解的事件就是需要在订阅者和发布者之间进行传递的数据，可以为单个基本类型的值，也可以为一个自定义的对象。\n\n事件可以分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于：当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个sticky事件，与StickyBroadcast类似。\n\n事件可以在任意线程进行发布,EventBus会根据发布事件类型，调用相对应事件的处理函数进行处理。\n\n#### 2.2 订阅者：\n订阅者是订阅某种事件类型的对象，当发布者发布这类事件后，EventBus会执行订阅者中相对应的事件响应函数。\n\n普通事件订阅者通过register接口订阅某个事件类型，unregister接口退订。 \nSticky事件的订阅者通过registerSticky接口订阅某个事件类型，通过unregister接口退订。\n\n订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。\n\n#### 2.3 发布者：\n发布事件的对象。\n\n对于普通事件，使用post接口发布事件\n\n对于Sticky事件，则使用postSticky接口发布事件\n\n### 3. 基本使用\n以自定义对象为事件进行距离介绍\n\n#### 3.1 自定义对象\n定义传递事件的对象Message\n\n    public class Message\n    {\n    \t// 消息号\n    \tprivate int messageCode;\n    \n    \t// 消息内容\n    \tprivate int messageInfo;\n    }\n#### 3.2 注册监听者\n注册当前对象为监听者\n\n\tEventBus.getDefault().register(this);\n或者\n\n\tEventBus.getDefault().register(EventBusMsgDeal.class);\n对于监听Sticky事件：\n\n\tEventBus.getDefault().registerSticky(this);\n#### 3.3 发布事件\n发布事件时，分为两种事件进行发布 \n\n普通事件：\n\n\tEventBus.getDefault().post(msg);\nSticky事件：\n\n\tEventBus.getDefault().postSticky(msg);\n#### 3.4 解除监听\n\tEventBus.getDefault().unregister(this);\n\n这里特别需要注意这个东西，一般在Activity声明周期结束的时候，需要调用这个方法将监听解除，否则，不仅影响性能，还会出现很多问题\n\n#### 3.5 事件处理\n\n对于事件处理，可以按照普通事件和Sticky事件进行区分，对于普通事件，可以分为以下四种处理方式：\n\n##### 3.5.1 OnEvent():\n\n使用OnEvent作为订阅处理函数，则表示发布事件和接受处理事件将会在同一个线程中执行，因此在该方法中，不宜执行一些耗时的操作，否则会造成阻塞、延迟。\n\n##### 3.5.2 onEventMainThread():\n\n使用onEventMainThread作为订阅处理函数，表示事件无论是在哪一个线程中发布出来的，都会在UI线程中执行，意味着可以再该线程中更新UI，因此在该线程中同样不适宜执行一些比较耗时的操作，否则会造成UI线程阻塞，进而导致NAR。\n\n##### 3.5.3 onEventBackgroundThread():\n\n使用onEventBackgroundThread作为订阅处理函数，恰好与onEventMainThread相反，onEventMainThread是无论在哪一个线程中发送事件，都会在UI线程中执行。而onEventBackgroundThread意味着，无论在哪一个线程中发送事件，都会在子线程中执行，也就是说，若当前Post线程为UI线程，则处理函数会在子线程中执行，若当前Post线程为子线程，则直接在该线程中执行。\n\n##### 3.5.4 onEventAsync():\n\n使用onEventAsync作为订阅处理函数，意味着，无论当前在哪一个线程中Post事件出来，都会新起一个线程进行执行。\n\n\n### 4. 执行顺序\n\n写到这里，可能有同学会迷惑，这四个方法如果同时出现在同一个类中，执行的先后顺序应该是什么样子的，这里我做了一个测试，得到其调用顺序如下：\n\n\t1. onEvent();\n\t2. onEventMainThread();\n\t3. onEventAsync();\n\t4. onEventBackgroundThread();\n\n### 5. 结束\n\n至此，已经大致学会了使用EventBus的使用，如果需要学习更多关于EventBus的源码解析及设计思想，可以参考以下链接：\n\n源码解析：[http://www.codekk.com/](http://www.codekk.com/)\n\n设计思想：[http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html](http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html)\n\n同样和EventBus具有相似功能的还有：Otto\n\n项目地址：[https://github.com/square/otto](https://github.com/square/otto)\n\n主页：[http://square.github.io/otto/](http://square.github.io/otto/)\n\n\n","source":"_posts/20160106EventBus简介及使用.markdown","raw":"---\n\ntitle: EventBus简介及使用\n\ndate: 2016-01-06 10:16:05\n\ntags: [Android , EventBus , 观察者模式]\n\ncategories: Android\n\nkeywords: EventBus , 观察者模式\n\ndescription: EventBus简介及使用\n\ntop_img: http://image.jucaiwy.com/image/20160106/event_bus.png\n\ncover: http://image.jucaiwy.com/image/20160106/event_bus.png\n\n---\n\nEventBus是一个Android下典型的“订阅发布模式”框架，该模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听一个主题对象，通过这种方式对订阅者和主题发布者进行充分解耦，主要用于Android组件间相互通信、线程间互相通信及其他线程与UI线程之间互相通信等。代替了传统的Handler、BroadCastReceiver、Interface回调等通信方式，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。\n\n\n### 1. 项目地址\n\nEventBus开源项目的项目地址：[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n### 2. 相关概念\n\n#### 2.1 事件：\n我所理解的事件就是需要在订阅者和发布者之间进行传递的数据，可以为单个基本类型的值，也可以为一个自定义的对象。\n\n事件可以分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于：当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个sticky事件，与StickyBroadcast类似。\n\n事件可以在任意线程进行发布,EventBus会根据发布事件类型，调用相对应事件的处理函数进行处理。\n\n#### 2.2 订阅者：\n订阅者是订阅某种事件类型的对象，当发布者发布这类事件后，EventBus会执行订阅者中相对应的事件响应函数。\n\n普通事件订阅者通过register接口订阅某个事件类型，unregister接口退订。 \nSticky事件的订阅者通过registerSticky接口订阅某个事件类型，通过unregister接口退订。\n\n订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。\n\n#### 2.3 发布者：\n发布事件的对象。\n\n对于普通事件，使用post接口发布事件\n\n对于Sticky事件，则使用postSticky接口发布事件\n\n### 3. 基本使用\n以自定义对象为事件进行距离介绍\n\n#### 3.1 自定义对象\n定义传递事件的对象Message\n\n    public class Message\n    {\n    \t// 消息号\n    \tprivate int messageCode;\n    \n    \t// 消息内容\n    \tprivate int messageInfo;\n    }\n#### 3.2 注册监听者\n注册当前对象为监听者\n\n\tEventBus.getDefault().register(this);\n或者\n\n\tEventBus.getDefault().register(EventBusMsgDeal.class);\n对于监听Sticky事件：\n\n\tEventBus.getDefault().registerSticky(this);\n#### 3.3 发布事件\n发布事件时，分为两种事件进行发布 \n\n普通事件：\n\n\tEventBus.getDefault().post(msg);\nSticky事件：\n\n\tEventBus.getDefault().postSticky(msg);\n#### 3.4 解除监听\n\tEventBus.getDefault().unregister(this);\n\n这里特别需要注意这个东西，一般在Activity声明周期结束的时候，需要调用这个方法将监听解除，否则，不仅影响性能，还会出现很多问题\n\n#### 3.5 事件处理\n\n对于事件处理，可以按照普通事件和Sticky事件进行区分，对于普通事件，可以分为以下四种处理方式：\n\n##### 3.5.1 OnEvent():\n\n使用OnEvent作为订阅处理函数，则表示发布事件和接受处理事件将会在同一个线程中执行，因此在该方法中，不宜执行一些耗时的操作，否则会造成阻塞、延迟。\n\n##### 3.5.2 onEventMainThread():\n\n使用onEventMainThread作为订阅处理函数，表示事件无论是在哪一个线程中发布出来的，都会在UI线程中执行，意味着可以再该线程中更新UI，因此在该线程中同样不适宜执行一些比较耗时的操作，否则会造成UI线程阻塞，进而导致NAR。\n\n##### 3.5.3 onEventBackgroundThread():\n\n使用onEventBackgroundThread作为订阅处理函数，恰好与onEventMainThread相反，onEventMainThread是无论在哪一个线程中发送事件，都会在UI线程中执行。而onEventBackgroundThread意味着，无论在哪一个线程中发送事件，都会在子线程中执行，也就是说，若当前Post线程为UI线程，则处理函数会在子线程中执行，若当前Post线程为子线程，则直接在该线程中执行。\n\n##### 3.5.4 onEventAsync():\n\n使用onEventAsync作为订阅处理函数，意味着，无论当前在哪一个线程中Post事件出来，都会新起一个线程进行执行。\n\n\n### 4. 执行顺序\n\n写到这里，可能有同学会迷惑，这四个方法如果同时出现在同一个类中，执行的先后顺序应该是什么样子的，这里我做了一个测试，得到其调用顺序如下：\n\n\t1. onEvent();\n\t2. onEventMainThread();\n\t3. onEventAsync();\n\t4. onEventBackgroundThread();\n\n### 5. 结束\n\n至此，已经大致学会了使用EventBus的使用，如果需要学习更多关于EventBus的源码解析及设计思想，可以参考以下链接：\n\n源码解析：[http://www.codekk.com/](http://www.codekk.com/)\n\n设计思想：[http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html](http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html)\n\n同样和EventBus具有相似功能的还有：Otto\n\n项目地址：[https://github.com/square/otto](https://github.com/square/otto)\n\n主页：[http://square.github.io/otto/](http://square.github.io/otto/)\n\n\n","slug":"20160106EventBus简介及使用","published":1,"updated":"2020-12-09T06:28:42.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurl000ib3t13wnx2ilj","content":"<p>EventBus是一个Android下典型的“订阅发布模式”框架，该模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听一个主题对象，通过这种方式对订阅者和主题发布者进行充分解耦，主要用于Android组件间相互通信、线程间互相通信及其他线程与UI线程之间互相通信等。代替了传统的Handler、BroadCastReceiver、Interface回调等通信方式，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>\n<h3 id=\"1-项目地址\"><a href=\"#1-项目地址\" class=\"headerlink\" title=\"1. 项目地址\"></a>1. 项目地址</h3><p>EventBus开源项目的项目地址：<a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n<h3 id=\"2-相关概念\"><a href=\"#2-相关概念\" class=\"headerlink\" title=\"2. 相关概念\"></a>2. 相关概念</h3><h4 id=\"2-1-事件：\"><a href=\"#2-1-事件：\" class=\"headerlink\" title=\"2.1 事件：\"></a>2.1 事件：</h4><p>我所理解的事件就是需要在订阅者和发布者之间进行传递的数据，可以为单个基本类型的值，也可以为一个自定义的对象。</p>\n<p>事件可以分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于：当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个sticky事件，与StickyBroadcast类似。</p>\n<p>事件可以在任意线程进行发布,EventBus会根据发布事件类型，调用相对应事件的处理函数进行处理。</p>\n<h4 id=\"2-2-订阅者：\"><a href=\"#2-2-订阅者：\" class=\"headerlink\" title=\"2.2 订阅者：\"></a>2.2 订阅者：</h4><p>订阅者是订阅某种事件类型的对象，当发布者发布这类事件后，EventBus会执行订阅者中相对应的事件响应函数。</p>\n<p>普通事件订阅者通过register接口订阅某个事件类型，unregister接口退订。<br>Sticky事件的订阅者通过registerSticky接口订阅某个事件类型，通过unregister接口退订。</p>\n<p>订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。</p>\n<h4 id=\"2-3-发布者：\"><a href=\"#2-3-发布者：\" class=\"headerlink\" title=\"2.3 发布者：\"></a>2.3 发布者：</h4><p>发布事件的对象。</p>\n<p>对于普通事件，使用post接口发布事件</p>\n<p>对于Sticky事件，则使用postSticky接口发布事件</p>\n<h3 id=\"3-基本使用\"><a href=\"#3-基本使用\" class=\"headerlink\" title=\"3. 基本使用\"></a>3. 基本使用</h3><p>以自定义对象为事件进行距离介绍</p>\n<h4 id=\"3-1-自定义对象\"><a href=\"#3-1-自定义对象\" class=\"headerlink\" title=\"3.1 自定义对象\"></a>3.1 自定义对象</h4><p>定义传递事件的对象Message</p>\n<pre><code>public class Message\n&#123;\n    // 消息号\n    private int messageCode;\n\n    // 消息内容\n    private int messageInfo;\n&#125;\n</code></pre>\n<h4 id=\"3-2-注册监听者\"><a href=\"#3-2-注册监听者\" class=\"headerlink\" title=\"3.2 注册监听者\"></a>3.2 注册监听者</h4><p>注册当前对象为监听者</p>\n<pre><code>EventBus.getDefault().register(this);\n</code></pre>\n<p>或者</p>\n<pre><code>EventBus.getDefault().register(EventBusMsgDeal.class);\n</code></pre>\n<p>对于监听Sticky事件：</p>\n<pre><code>EventBus.getDefault().registerSticky(this);\n</code></pre>\n<h4 id=\"3-3-发布事件\"><a href=\"#3-3-发布事件\" class=\"headerlink\" title=\"3.3 发布事件\"></a>3.3 发布事件</h4><p>发布事件时，分为两种事件进行发布 </p>\n<p>普通事件：</p>\n<pre><code>EventBus.getDefault().post(msg);\n</code></pre>\n<p>Sticky事件：</p>\n<pre><code>EventBus.getDefault().postSticky(msg);\n</code></pre>\n<h4 id=\"3-4-解除监听\"><a href=\"#3-4-解除监听\" class=\"headerlink\" title=\"3.4 解除监听\"></a>3.4 解除监听</h4><pre><code>EventBus.getDefault().unregister(this);\n</code></pre>\n<p>这里特别需要注意这个东西，一般在Activity声明周期结束的时候，需要调用这个方法将监听解除，否则，不仅影响性能，还会出现很多问题</p>\n<h4 id=\"3-5-事件处理\"><a href=\"#3-5-事件处理\" class=\"headerlink\" title=\"3.5 事件处理\"></a>3.5 事件处理</h4><p>对于事件处理，可以按照普通事件和Sticky事件进行区分，对于普通事件，可以分为以下四种处理方式：</p>\n<h5 id=\"3-5-1-OnEvent\"><a href=\"#3-5-1-OnEvent\" class=\"headerlink\" title=\"3.5.1 OnEvent():\"></a>3.5.1 OnEvent():</h5><p>使用OnEvent作为订阅处理函数，则表示发布事件和接受处理事件将会在同一个线程中执行，因此在该方法中，不宜执行一些耗时的操作，否则会造成阻塞、延迟。</p>\n<h5 id=\"3-5-2-onEventMainThread\"><a href=\"#3-5-2-onEventMainThread\" class=\"headerlink\" title=\"3.5.2 onEventMainThread():\"></a>3.5.2 onEventMainThread():</h5><p>使用onEventMainThread作为订阅处理函数，表示事件无论是在哪一个线程中发布出来的，都会在UI线程中执行，意味着可以再该线程中更新UI，因此在该线程中同样不适宜执行一些比较耗时的操作，否则会造成UI线程阻塞，进而导致NAR。</p>\n<h5 id=\"3-5-3-onEventBackgroundThread\"><a href=\"#3-5-3-onEventBackgroundThread\" class=\"headerlink\" title=\"3.5.3 onEventBackgroundThread():\"></a>3.5.3 onEventBackgroundThread():</h5><p>使用onEventBackgroundThread作为订阅处理函数，恰好与onEventMainThread相反，onEventMainThread是无论在哪一个线程中发送事件，都会在UI线程中执行。而onEventBackgroundThread意味着，无论在哪一个线程中发送事件，都会在子线程中执行，也就是说，若当前Post线程为UI线程，则处理函数会在子线程中执行，若当前Post线程为子线程，则直接在该线程中执行。</p>\n<h5 id=\"3-5-4-onEventAsync\"><a href=\"#3-5-4-onEventAsync\" class=\"headerlink\" title=\"3.5.4 onEventAsync():\"></a>3.5.4 onEventAsync():</h5><p>使用onEventAsync作为订阅处理函数，意味着，无论当前在哪一个线程中Post事件出来，都会新起一个线程进行执行。</p>\n<h3 id=\"4-执行顺序\"><a href=\"#4-执行顺序\" class=\"headerlink\" title=\"4. 执行顺序\"></a>4. 执行顺序</h3><p>写到这里，可能有同学会迷惑，这四个方法如果同时出现在同一个类中，执行的先后顺序应该是什么样子的，这里我做了一个测试，得到其调用顺序如下：</p>\n<pre><code>1. onEvent();\n2. onEventMainThread();\n3. onEventAsync();\n4. onEventBackgroundThread();\n</code></pre>\n<h3 id=\"5-结束\"><a href=\"#5-结束\" class=\"headerlink\" title=\"5. 结束\"></a>5. 结束</h3><p>至此，已经大致学会了使用EventBus的使用，如果需要学习更多关于EventBus的源码解析及设计思想，可以参考以下链接：</p>\n<p>源码解析：<a href=\"http://www.codekk.com/\">http://www.codekk.com/</a></p>\n<p>设计思想：<a href=\"http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html\">http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html</a></p>\n<p>同样和EventBus具有相似功能的还有：Otto</p>\n<p>项目地址：<a href=\"https://github.com/square/otto\">https://github.com/square/otto</a></p>\n<p>主页：<a href=\"http://square.github.io/otto/\">http://square.github.io/otto/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>EventBus是一个Android下典型的“订阅发布模式”框架，该模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听一个主题对象，通过这种方式对订阅者和主题发布者进行充分解耦，主要用于Android组件间相互通信、线程间互相通信及其他线程与UI线程之间互相通信等。代替了传统的Handler、BroadCastReceiver、Interface回调等通信方式，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>\n<h3 id=\"1-项目地址\"><a href=\"#1-项目地址\" class=\"headerlink\" title=\"1. 项目地址\"></a>1. 项目地址</h3><p>EventBus开源项目的项目地址：<a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n<h3 id=\"2-相关概念\"><a href=\"#2-相关概念\" class=\"headerlink\" title=\"2. 相关概念\"></a>2. 相关概念</h3><h4 id=\"2-1-事件：\"><a href=\"#2-1-事件：\" class=\"headerlink\" title=\"2.1 事件：\"></a>2.1 事件：</h4><p>我所理解的事件就是需要在订阅者和发布者之间进行传递的数据，可以为单个基本类型的值，也可以为一个自定义的对象。</p>\n<p>事件可以分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于：当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个sticky事件，与StickyBroadcast类似。</p>\n<p>事件可以在任意线程进行发布,EventBus会根据发布事件类型，调用相对应事件的处理函数进行处理。</p>\n<h4 id=\"2-2-订阅者：\"><a href=\"#2-2-订阅者：\" class=\"headerlink\" title=\"2.2 订阅者：\"></a>2.2 订阅者：</h4><p>订阅者是订阅某种事件类型的对象，当发布者发布这类事件后，EventBus会执行订阅者中相对应的事件响应函数。</p>\n<p>普通事件订阅者通过register接口订阅某个事件类型，unregister接口退订。<br>Sticky事件的订阅者通过registerSticky接口订阅某个事件类型，通过unregister接口退订。</p>\n<p>订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。</p>\n<h4 id=\"2-3-发布者：\"><a href=\"#2-3-发布者：\" class=\"headerlink\" title=\"2.3 发布者：\"></a>2.3 发布者：</h4><p>发布事件的对象。</p>\n<p>对于普通事件，使用post接口发布事件</p>\n<p>对于Sticky事件，则使用postSticky接口发布事件</p>\n<h3 id=\"3-基本使用\"><a href=\"#3-基本使用\" class=\"headerlink\" title=\"3. 基本使用\"></a>3. 基本使用</h3><p>以自定义对象为事件进行距离介绍</p>\n<h4 id=\"3-1-自定义对象\"><a href=\"#3-1-自定义对象\" class=\"headerlink\" title=\"3.1 自定义对象\"></a>3.1 自定义对象</h4><p>定义传递事件的对象Message</p>\n<pre><code>public class Message\n&#123;\n    // 消息号\n    private int messageCode;\n\n    // 消息内容\n    private int messageInfo;\n&#125;\n</code></pre>\n<h4 id=\"3-2-注册监听者\"><a href=\"#3-2-注册监听者\" class=\"headerlink\" title=\"3.2 注册监听者\"></a>3.2 注册监听者</h4><p>注册当前对象为监听者</p>\n<pre><code>EventBus.getDefault().register(this);\n</code></pre>\n<p>或者</p>\n<pre><code>EventBus.getDefault().register(EventBusMsgDeal.class);\n</code></pre>\n<p>对于监听Sticky事件：</p>\n<pre><code>EventBus.getDefault().registerSticky(this);\n</code></pre>\n<h4 id=\"3-3-发布事件\"><a href=\"#3-3-发布事件\" class=\"headerlink\" title=\"3.3 发布事件\"></a>3.3 发布事件</h4><p>发布事件时，分为两种事件进行发布 </p>\n<p>普通事件：</p>\n<pre><code>EventBus.getDefault().post(msg);\n</code></pre>\n<p>Sticky事件：</p>\n<pre><code>EventBus.getDefault().postSticky(msg);\n</code></pre>\n<h4 id=\"3-4-解除监听\"><a href=\"#3-4-解除监听\" class=\"headerlink\" title=\"3.4 解除监听\"></a>3.4 解除监听</h4><pre><code>EventBus.getDefault().unregister(this);\n</code></pre>\n<p>这里特别需要注意这个东西，一般在Activity声明周期结束的时候，需要调用这个方法将监听解除，否则，不仅影响性能，还会出现很多问题</p>\n<h4 id=\"3-5-事件处理\"><a href=\"#3-5-事件处理\" class=\"headerlink\" title=\"3.5 事件处理\"></a>3.5 事件处理</h4><p>对于事件处理，可以按照普通事件和Sticky事件进行区分，对于普通事件，可以分为以下四种处理方式：</p>\n<h5 id=\"3-5-1-OnEvent\"><a href=\"#3-5-1-OnEvent\" class=\"headerlink\" title=\"3.5.1 OnEvent():\"></a>3.5.1 OnEvent():</h5><p>使用OnEvent作为订阅处理函数，则表示发布事件和接受处理事件将会在同一个线程中执行，因此在该方法中，不宜执行一些耗时的操作，否则会造成阻塞、延迟。</p>\n<h5 id=\"3-5-2-onEventMainThread\"><a href=\"#3-5-2-onEventMainThread\" class=\"headerlink\" title=\"3.5.2 onEventMainThread():\"></a>3.5.2 onEventMainThread():</h5><p>使用onEventMainThread作为订阅处理函数，表示事件无论是在哪一个线程中发布出来的，都会在UI线程中执行，意味着可以再该线程中更新UI，因此在该线程中同样不适宜执行一些比较耗时的操作，否则会造成UI线程阻塞，进而导致NAR。</p>\n<h5 id=\"3-5-3-onEventBackgroundThread\"><a href=\"#3-5-3-onEventBackgroundThread\" class=\"headerlink\" title=\"3.5.3 onEventBackgroundThread():\"></a>3.5.3 onEventBackgroundThread():</h5><p>使用onEventBackgroundThread作为订阅处理函数，恰好与onEventMainThread相反，onEventMainThread是无论在哪一个线程中发送事件，都会在UI线程中执行。而onEventBackgroundThread意味着，无论在哪一个线程中发送事件，都会在子线程中执行，也就是说，若当前Post线程为UI线程，则处理函数会在子线程中执行，若当前Post线程为子线程，则直接在该线程中执行。</p>\n<h5 id=\"3-5-4-onEventAsync\"><a href=\"#3-5-4-onEventAsync\" class=\"headerlink\" title=\"3.5.4 onEventAsync():\"></a>3.5.4 onEventAsync():</h5><p>使用onEventAsync作为订阅处理函数，意味着，无论当前在哪一个线程中Post事件出来，都会新起一个线程进行执行。</p>\n<h3 id=\"4-执行顺序\"><a href=\"#4-执行顺序\" class=\"headerlink\" title=\"4. 执行顺序\"></a>4. 执行顺序</h3><p>写到这里，可能有同学会迷惑，这四个方法如果同时出现在同一个类中，执行的先后顺序应该是什么样子的，这里我做了一个测试，得到其调用顺序如下：</p>\n<pre><code>1. onEvent();\n2. onEventMainThread();\n3. onEventAsync();\n4. onEventBackgroundThread();\n</code></pre>\n<h3 id=\"5-结束\"><a href=\"#5-结束\" class=\"headerlink\" title=\"5. 结束\"></a>5. 结束</h3><p>至此，已经大致学会了使用EventBus的使用，如果需要学习更多关于EventBus的源码解析及设计思想，可以参考以下链接：</p>\n<p>源码解析：<a href=\"http://www.codekk.com/\">http://www.codekk.com/</a></p>\n<p>设计思想：<a href=\"http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html\">http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html</a></p>\n<p>同样和EventBus具有相似功能的还有：Otto</p>\n<p>项目地址：<a href=\"https://github.com/square/otto\">https://github.com/square/otto</a></p>\n<p>主页：<a href=\"http://square.github.io/otto/\">http://square.github.io/otto/</a></p>\n"},{"title":"Android平台OCR工具之Tess-two使用","date":"2016-02-25T08:27:08.000Z","keywords":"Android , OCR , Tess-Two , Tesseract","description":"Android下使用Protobuf进行序列化","top_img":"http://image.jucaiwy.com/image/20160225/tess_two_head.jpeg","cover":"http://image.jucaiwy.com/image/20160225/tess_two_head.jpeg","_content":"\nOCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；\n\n### 1. Tesseract简介\nTesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。 \n现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。\n\n<!--more-->\n\n主页地址：[https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)\n\n在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为\n\n中文：[chi-sim.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n英文：[eng.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n### 2. Tess-two\n因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。\n\n#### 2.1 项目地址\nTess-two在git上地址为：[https://github.com/rmtheis/tess-two](https://github.com/rmtheis/tess-two)\n\n#### 2.2 编译\n我编译使用的环境：\n\n- Eclipse 4.2.1\n- ADT 23.0.2\n- NDK R10\n- Cygwin\n\nNDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：[Windows下Android NDK环境搭建](http://blog.csdn.net/pengchua/article/details/7582949)\n\n\n配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：\n\n- 第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。\n- 第二步：切换到tess-two目录下的jni目录\n- 第三步：输入命令进行编译\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_1.png)\n\n\n编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。\n\n也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。\n\n[tess-two下载](http://download.csdn.net/detail/duanbokan/9443521)\n\n### 3. tess-two使用\n编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_2.png)\n\n识别函数：\n\n\t/**\n     * 识别图片中文字,需要放入异步线程中进行执行\n     * \n     * @param bitmap\n     * @return\n     * @throws IOException\n     */\n    public String parseImageToString(String imagePath) throws IOException\n    {\n        // 检验图片地址是否正确\n        if (imagePath == null || imagePath.equals(\"\"))\n        {\n            return TessErrorCode.IMAGE_PATH_IS_NULL;\n        }\n\n        // 获取Bitmap\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inSampleSize = 2;\n        Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n        // 图片旋转角度\n        int rotate = 0;\n\n        ExifInterface exif = new ExifInterface(imagePath);\n\n        // 先获取当前图像的方向，判断是否需要旋转\n        int imageOrientation = exif\n                .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                        ExifInterface.ORIENTATION_NORMAL);\n\n        Log.i(TAG, \"Current image orientation is \" + imageOrientation);\n\n        switch (imageOrientation)\n        {\n            case ExifInterface.ORIENTATION_ROTATE_90:\n                rotate = 90;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_180:\n                rotate = 180;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_270:\n                rotate = 270;\n                break;\n            default:\n                break;\n        }\n\n        Log.i(TAG, \"Current image need rotate: \" + rotate);\n\n        // 获取当前图片的宽和高\n        int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n\n        // 使用Matrix对图片进行处理\n        Matrix mtx = new Matrix();\n        mtx.preRotate(rotate);\n\n        // 旋转图片\n        bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n        bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        // 开始调用Tess函数对图像进行识别\n        TessBaseAPI baseApi = new TessBaseAPI();\n        baseApi.setDebug(true);\n        // 使用默认语言初始化BaseApi\n        baseApi.init(TessConstantConfig.TESSBASE_PATH,\n                TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n        baseApi.setImage(bitmap);\n\n        // 获取返回值\n        String recognizedText = baseApi.getUTF8Text();\n        baseApi.end();\n        return recognizedText;\n    }\n\n使用之前，需要先下载数据包到/mnt/sdcard/tesseract/目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载\n\n[数据包下载地址](https://github.com/tesseract-ocr/tessdata)\n\n经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_3.png)\n\n### 4. 总结\n\n总结tess-two的使用方法，大致可分为以下几步：\n\n\t1. 下载并解压tess-two\n\t2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n\t3. 新建工程测试，训练\n\n\n### 5. 代码\n\n[我是代码](http://download.csdn.net/detail/duanbokan/9443595)","source":"_posts/20160225Android平台OCR工具之Tess-two使用.markdown","raw":"---\n\ntitle: Android平台OCR工具之Tess-two使用\n\ndate: 2016-02-25 16:27:08\n\ntags: [ Android , OCR , Tess-Two , Tesseract]\n\ncategories: Android\n\nkeywords: Android , OCR , Tess-Two , Tesseract\n\ndescription: Android下使用Protobuf进行序列化\n\ntop_img: http://image.jucaiwy.com/image/20160225/tess_two_head.jpeg\n\ncover: http://image.jucaiwy.com/image/20160225/tess_two_head.jpeg\n\n---\n\nOCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；\n\n### 1. Tesseract简介\nTesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。 \n现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。\n\n<!--more-->\n\n主页地址：[https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)\n\n在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为\n\n中文：[chi-sim.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n英文：[eng.traineddata](https://github.com/tesseract-ocr/tessdata)\n\n### 2. Tess-two\n因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。\n\n#### 2.1 项目地址\nTess-two在git上地址为：[https://github.com/rmtheis/tess-two](https://github.com/rmtheis/tess-two)\n\n#### 2.2 编译\n我编译使用的环境：\n\n- Eclipse 4.2.1\n- ADT 23.0.2\n- NDK R10\n- Cygwin\n\nNDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：[Windows下Android NDK环境搭建](http://blog.csdn.net/pengchua/article/details/7582949)\n\n\n配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：\n\n- 第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。\n- 第二步：切换到tess-two目录下的jni目录\n- 第三步：输入命令进行编译\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_1.png)\n\n\n编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。\n\n也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。\n\n[tess-two下载](http://download.csdn.net/detail/duanbokan/9443521)\n\n### 3. tess-two使用\n编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_2.png)\n\n识别函数：\n\n\t/**\n     * 识别图片中文字,需要放入异步线程中进行执行\n     * \n     * @param bitmap\n     * @return\n     * @throws IOException\n     */\n    public String parseImageToString(String imagePath) throws IOException\n    {\n        // 检验图片地址是否正确\n        if (imagePath == null || imagePath.equals(\"\"))\n        {\n            return TessErrorCode.IMAGE_PATH_IS_NULL;\n        }\n\n        // 获取Bitmap\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inSampleSize = 2;\n        Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n        // 图片旋转角度\n        int rotate = 0;\n\n        ExifInterface exif = new ExifInterface(imagePath);\n\n        // 先获取当前图像的方向，判断是否需要旋转\n        int imageOrientation = exif\n                .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                        ExifInterface.ORIENTATION_NORMAL);\n\n        Log.i(TAG, \"Current image orientation is \" + imageOrientation);\n\n        switch (imageOrientation)\n        {\n            case ExifInterface.ORIENTATION_ROTATE_90:\n                rotate = 90;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_180:\n                rotate = 180;\n                break;\n            case ExifInterface.ORIENTATION_ROTATE_270:\n                rotate = 270;\n                break;\n            default:\n                break;\n        }\n\n        Log.i(TAG, \"Current image need rotate: \" + rotate);\n\n        // 获取当前图片的宽和高\n        int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n\n        // 使用Matrix对图片进行处理\n        Matrix mtx = new Matrix();\n        mtx.preRotate(rotate);\n\n        // 旋转图片\n        bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n        bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n        // 开始调用Tess函数对图像进行识别\n        TessBaseAPI baseApi = new TessBaseAPI();\n        baseApi.setDebug(true);\n        // 使用默认语言初始化BaseApi\n        baseApi.init(TessConstantConfig.TESSBASE_PATH,\n                TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n        baseApi.setImage(bitmap);\n\n        // 获取返回值\n        String recognizedText = baseApi.getUTF8Text();\n        baseApi.end();\n        return recognizedText;\n    }\n\n使用之前，需要先下载数据包到/mnt/sdcard/tesseract/目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载\n\n[数据包下载地址](https://github.com/tesseract-ocr/tessdata)\n\n经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：\n\n![](http://image.jucaiwy.com/image/20160225/tess_two_3.png)\n\n### 4. 总结\n\n总结tess-two的使用方法，大致可分为以下几步：\n\n\t1. 下载并解压tess-two\n\t2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n\t3. 新建工程测试，训练\n\n\n### 5. 代码\n\n[我是代码](http://download.csdn.net/detail/duanbokan/9443595)","slug":"20160225Android平台OCR工具之Tess-two使用","published":1,"updated":"2020-12-09T06:29:20.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurn000mb3t1bx4vfxp6","content":"<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p>\n<h3 id=\"1-Tesseract简介\"><a href=\"#1-Tesseract简介\" class=\"headerlink\" title=\"1. Tesseract简介\"></a>1. Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p>\n<span id=\"more\"></span>\n\n<p>主页地址：<a href=\"https://github.com/tesseract-ocr\">https://github.com/tesseract-ocr</a></p>\n<p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p>\n<p>中文：<a href=\"https://github.com/tesseract-ocr/tessdata\">chi-sim.traineddata</a></p>\n<p>英文：<a href=\"https://github.com/tesseract-ocr/tessdata\">eng.traineddata</a></p>\n<h3 id=\"2-Tess-two\"><a href=\"#2-Tess-two\" class=\"headerlink\" title=\"2. Tess-two\"></a>2. Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p>\n<h4 id=\"2-1-项目地址\"><a href=\"#2-1-项目地址\" class=\"headerlink\" title=\"2.1 项目地址\"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href=\"https://github.com/rmtheis/tess-two\">https://github.com/rmtheis/tess-two</a></p>\n<h4 id=\"2-2-编译\"><a href=\"#2-2-编译\" class=\"headerlink\" title=\"2.2 编译\"></a>2.2 编译</h4><p>我编译使用的环境：</p>\n<ul>\n<li>Eclipse 4.2.1</li>\n<li>ADT 23.0.2</li>\n<li>NDK R10</li>\n<li>Cygwin</li>\n</ul>\n<p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href=\"http://blog.csdn.net/pengchua/article/details/7582949\">Windows下Android NDK环境搭建</a></p>\n<p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：</p>\n<ul>\n<li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li>\n<li>第二步：切换到tess-two目录下的jni目录</li>\n<li>第三步：输入命令进行编译</li>\n</ul>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_1.png\"></p>\n<p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p>\n<p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p>\n<p><a href=\"http://download.csdn.net/detail/duanbokan/9443521\">tess-two下载</a></p>\n<h3 id=\"3-tess-two使用\"><a href=\"#3-tess-two使用\" class=\"headerlink\" title=\"3. tess-two使用\"></a>3. tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_2.png\"></p>\n<p>识别函数：</p>\n<pre><code>/**\n * 识别图片中文字,需要放入异步线程中进行执行\n * \n * @param bitmap\n * @return\n * @throws IOException\n */\npublic String parseImageToString(String imagePath) throws IOException\n&#123;\n    // 检验图片地址是否正确\n    if (imagePath == null || imagePath.equals(&quot;&quot;))\n    &#123;\n        return TessErrorCode.IMAGE_PATH_IS_NULL;\n    &#125;\n\n    // 获取Bitmap\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inSampleSize = 2;\n    Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n    // 图片旋转角度\n    int rotate = 0;\n\n    ExifInterface exif = new ExifInterface(imagePath);\n\n    // 先获取当前图像的方向，判断是否需要旋转\n    int imageOrientation = exif\n            .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                    ExifInterface.ORIENTATION_NORMAL);\n\n    Log.i(TAG, &quot;Current image orientation is &quot; + imageOrientation);\n\n    switch (imageOrientation)\n    &#123;\n        case ExifInterface.ORIENTATION_ROTATE_90:\n            rotate = 90;\n            break;\n        case ExifInterface.ORIENTATION_ROTATE_180:\n            rotate = 180;\n            break;\n        case ExifInterface.ORIENTATION_ROTATE_270:\n            rotate = 270;\n            break;\n        default:\n            break;\n    &#125;\n\n    Log.i(TAG, &quot;Current image need rotate: &quot; + rotate);\n\n    // 获取当前图片的宽和高\n    int w = bitmap.getWidth();\n    int h = bitmap.getHeight();\n\n    // 使用Matrix对图片进行处理\n    Matrix mtx = new Matrix();\n    mtx.preRotate(rotate);\n\n    // 旋转图片\n    bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n    bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n    // 开始调用Tess函数对图像进行识别\n    TessBaseAPI baseApi = new TessBaseAPI();\n    baseApi.setDebug(true);\n    // 使用默认语言初始化BaseApi\n    baseApi.init(TessConstantConfig.TESSBASE_PATH,\n            TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n    baseApi.setImage(bitmap);\n\n    // 获取返回值\n    String recognizedText = baseApi.getUTF8Text();\n    baseApi.end();\n    return recognizedText;\n&#125;\n</code></pre>\n<p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p>\n<p><a href=\"https://github.com/tesseract-ocr/tessdata\">数据包下载地址</a></p>\n<p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_3.png\"></p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p>\n<pre><code>1. 下载并解压tess-two\n2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n3. 新建工程测试，训练\n</code></pre>\n<h3 id=\"5-代码\"><a href=\"#5-代码\" class=\"headerlink\" title=\"5. 代码\"></a>5. 代码</h3><p><a href=\"http://download.csdn.net/detail/duanbokan/9443595\">我是代码</a></p>\n","site":{"data":{}},"excerpt":"<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p>\n<h3 id=\"1-Tesseract简介\"><a href=\"#1-Tesseract简介\" class=\"headerlink\" title=\"1. Tesseract简介\"></a>1. Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p>","more":"<p>主页地址：<a href=\"https://github.com/tesseract-ocr\">https://github.com/tesseract-ocr</a></p>\n<p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p>\n<p>中文：<a href=\"https://github.com/tesseract-ocr/tessdata\">chi-sim.traineddata</a></p>\n<p>英文：<a href=\"https://github.com/tesseract-ocr/tessdata\">eng.traineddata</a></p>\n<h3 id=\"2-Tess-two\"><a href=\"#2-Tess-two\" class=\"headerlink\" title=\"2. Tess-two\"></a>2. Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p>\n<h4 id=\"2-1-项目地址\"><a href=\"#2-1-项目地址\" class=\"headerlink\" title=\"2.1 项目地址\"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href=\"https://github.com/rmtheis/tess-two\">https://github.com/rmtheis/tess-two</a></p>\n<h4 id=\"2-2-编译\"><a href=\"#2-2-编译\" class=\"headerlink\" title=\"2.2 编译\"></a>2.2 编译</h4><p>我编译使用的环境：</p>\n<ul>\n<li>Eclipse 4.2.1</li>\n<li>ADT 23.0.2</li>\n<li>NDK R10</li>\n<li>Cygwin</li>\n</ul>\n<p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href=\"http://blog.csdn.net/pengchua/article/details/7582949\">Windows下Android NDK环境搭建</a></p>\n<p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\\CooGame\\OCR\\TessTwo源码，下边开始进行编译：</p>\n<ul>\n<li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li>\n<li>第二步：切换到tess-two目录下的jni目录</li>\n<li>第三步：输入命令进行编译</li>\n</ul>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_1.png\"></p>\n<p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p>\n<p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p>\n<p><a href=\"http://download.csdn.net/detail/duanbokan/9443521\">tess-two下载</a></p>\n<h3 id=\"3-tess-two使用\"><a href=\"#3-tess-two使用\" class=\"headerlink\" title=\"3. tess-two使用\"></a>3. tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_2.png\"></p>\n<p>识别函数：</p>\n<pre><code>/**\n * 识别图片中文字,需要放入异步线程中进行执行\n * \n * @param bitmap\n * @return\n * @throws IOException\n */\npublic String parseImageToString(String imagePath) throws IOException\n&#123;\n    // 检验图片地址是否正确\n    if (imagePath == null || imagePath.equals(&quot;&quot;))\n    &#123;\n        return TessErrorCode.IMAGE_PATH_IS_NULL;\n    &#125;\n\n    // 获取Bitmap\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inSampleSize = 2;\n    Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);\n\n    // 图片旋转角度\n    int rotate = 0;\n\n    ExifInterface exif = new ExifInterface(imagePath);\n\n    // 先获取当前图像的方向，判断是否需要旋转\n    int imageOrientation = exif\n            .getAttributeInt(ExifInterface.TAG_ORIENTATION,\n                    ExifInterface.ORIENTATION_NORMAL);\n\n    Log.i(TAG, &quot;Current image orientation is &quot; + imageOrientation);\n\n    switch (imageOrientation)\n    &#123;\n        case ExifInterface.ORIENTATION_ROTATE_90:\n            rotate = 90;\n            break;\n        case ExifInterface.ORIENTATION_ROTATE_180:\n            rotate = 180;\n            break;\n        case ExifInterface.ORIENTATION_ROTATE_270:\n            rotate = 270;\n            break;\n        default:\n            break;\n    &#125;\n\n    Log.i(TAG, &quot;Current image need rotate: &quot; + rotate);\n\n    // 获取当前图片的宽和高\n    int w = bitmap.getWidth();\n    int h = bitmap.getHeight();\n\n    // 使用Matrix对图片进行处理\n    Matrix mtx = new Matrix();\n    mtx.preRotate(rotate);\n\n    // 旋转图片\n    bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);\n    bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n\n    // 开始调用Tess函数对图像进行识别\n    TessBaseAPI baseApi = new TessBaseAPI();\n    baseApi.setDebug(true);\n    // 使用默认语言初始化BaseApi\n    baseApi.init(TessConstantConfig.TESSBASE_PATH,\n            TessConstantConfig.DEFAULT_LANGUAGE_CHI);\n    baseApi.setImage(bitmap);\n\n    // 获取返回值\n    String recognizedText = baseApi.getUTF8Text();\n    baseApi.end();\n    return recognizedText;\n&#125;\n</code></pre>\n<p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p>\n<p><a href=\"https://github.com/tesseract-ocr/tessdata\">数据包下载地址</a></p>\n<p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160225/tess_two_3.png\"></p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p>\n<pre><code>1. 下载并解压tess-two\n2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码\n3. 新建工程测试，训练\n</code></pre>\n<h3 id=\"5-代码\"><a href=\"#5-代码\" class=\"headerlink\" title=\"5. 代码\"></a>5. 代码</h3><p><a href=\"http://download.csdn.net/detail/duanbokan/9443595\">我是代码</a></p>"},{"title":"Linux下搭建Bouncycastle加解密环境","date":"2016-03-03T08:31:09.000Z","keywords":"Bouncycast , Https证书生成","description":"Linux下搭建Bouncycastle环境","top_img":"http://image.jucaiwy.com/image/20160303/bouncycastle_head.jpeg","cover":"http://image.jucaiwy.com/image/20160303/bouncycastle_head.jpeg","_content":"\nBouncycastle是一种Java平台开放源码的轻量级密码术包，可用来管理Android的证书。此次因为需要自己生成Https的证书，因此，专门学习了一下搭建Bouncycastle环境的方法，对学习过程记录如下：\n\n### 1. 环境\n\n我使用的环境信息如下：\n\n- Linux版本：CentOS 5.8 64位操作系统\n- Java版本：1.6.0_35\n\n\n### 2. 搭建步骤\n\n具体搭建步骤记录如下：\n\n#### 2.1 下载Bouncycastle的Jar包\n\n官方网站地址是：[Bouncycastle官网](http://www.bouncycastle.org/latest_releases.html)，网页上有两个可以下载的：\n\n一个是crypto-154.tar.gZ(文件较小，但是我下载了以后，出现无法解压的现象，windows和linux下均无法解压)\n\n另外一个是crypto-154.zip,推荐下载该版本，文件较大，可以直接解压得到jar文件夹，这里因为我的java版本是1.6的所以选择了`bcprov-debug-jdk15on-154.jar`。\n\n或者也可以直接点击下载 [bcprov-jdk15on-146.jar](http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)\n\n#### 2.2 上传下载的安装包\n\n将下载得到的Jar包上传到linux服务器上，找到java的根目录，将其放在jre/lib/ext/目录下。如果找不到jre的路径，可以使用echo命令进行打印\n\n\techo $JAVA_HOME\n\n\n![](http://image.jucaiwy.com/image/20160303/bouncycastle1.png)\n\n\n#### 2.3 配置\n\n修改jre/lib/security/java.security文件，在其provider列表中添加一条：\n```\nsecurity.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider\n```\n\n安装到此结束\n\n![](http://image.jucaiwy.com/image/20160303/bouncycastle2.png)\n\n\n### 3. 测试\n\n新建Test.java文件，添加以下代码：\n    \n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.SecretKey;\n    \n    public class Test\n    {\n    \tpublic static final String stringToEncrypt = \"Thisis a test.\";\n    \t\n    \tpublic static void main(String[] args) throws Exception\n    \t{\n    \t\tSystem.out.print(\"Attemptingto get a Blowfish key...\");\n    \t\tKeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n    \t\tkeyGenerator.init(128);\n    \t\tSecretKey key = keyGenerator.generateKey();\n    \t\tSystem.out.println(\"OK\");\n    \t\tSystem.out.println(\"Attemptingto get a Cipher and encrypt...\");\n    \t\tCipher cipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\n    \t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n    \t\tbyte[] cipherText = cipher.doFinal(stringToEncrypt.getBytes(\"UTF8\"));\n    \t\tSystem.out.println(\"OK\");\n    \t\tSystem.out.println(\"Testcompleted successfully.\");\n    \t}\n    }\n    \n\n当输出结果为下文时，代表搭建成功\n\n\tAttemptingto get a Blowfish key...OK\n\tAttemptingto get a Cipher and encrypt...\n\tOK\n\tTestcompleted successfully.\n    \n\n\n\n\n\n","source":"_posts/20160303Linux下搭建Bouncycastle环境.md","raw":"---\n\ntitle: Linux下搭建Bouncycastle加解密环境\n\ndate: 2016-03-03 16:31:09\n\ntags: [ Bouncycast , Https证书生成]\n\ncategories: Android\n\nkeywords: Bouncycast , Https证书生成\n\ndescription: Linux下搭建Bouncycastle环境\n\ntop_img: http://image.jucaiwy.com/image/20160303/bouncycastle_head.jpeg\n\ncover: http://image.jucaiwy.com/image/20160303/bouncycastle_head.jpeg\n\n---\n\nBouncycastle是一种Java平台开放源码的轻量级密码术包，可用来管理Android的证书。此次因为需要自己生成Https的证书，因此，专门学习了一下搭建Bouncycastle环境的方法，对学习过程记录如下：\n\n### 1. 环境\n\n我使用的环境信息如下：\n\n- Linux版本：CentOS 5.8 64位操作系统\n- Java版本：1.6.0_35\n\n\n### 2. 搭建步骤\n\n具体搭建步骤记录如下：\n\n#### 2.1 下载Bouncycastle的Jar包\n\n官方网站地址是：[Bouncycastle官网](http://www.bouncycastle.org/latest_releases.html)，网页上有两个可以下载的：\n\n一个是crypto-154.tar.gZ(文件较小，但是我下载了以后，出现无法解压的现象，windows和linux下均无法解压)\n\n另外一个是crypto-154.zip,推荐下载该版本，文件较大，可以直接解压得到jar文件夹，这里因为我的java版本是1.6的所以选择了`bcprov-debug-jdk15on-154.jar`。\n\n或者也可以直接点击下载 [bcprov-jdk15on-146.jar](http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar)\n\n#### 2.2 上传下载的安装包\n\n将下载得到的Jar包上传到linux服务器上，找到java的根目录，将其放在jre/lib/ext/目录下。如果找不到jre的路径，可以使用echo命令进行打印\n\n\techo $JAVA_HOME\n\n\n![](http://image.jucaiwy.com/image/20160303/bouncycastle1.png)\n\n\n#### 2.3 配置\n\n修改jre/lib/security/java.security文件，在其provider列表中添加一条：\n```\nsecurity.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider\n```\n\n安装到此结束\n\n![](http://image.jucaiwy.com/image/20160303/bouncycastle2.png)\n\n\n### 3. 测试\n\n新建Test.java文件，添加以下代码：\n    \n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.SecretKey;\n    \n    public class Test\n    {\n    \tpublic static final String stringToEncrypt = \"Thisis a test.\";\n    \t\n    \tpublic static void main(String[] args) throws Exception\n    \t{\n    \t\tSystem.out.print(\"Attemptingto get a Blowfish key...\");\n    \t\tKeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n    \t\tkeyGenerator.init(128);\n    \t\tSecretKey key = keyGenerator.generateKey();\n    \t\tSystem.out.println(\"OK\");\n    \t\tSystem.out.println(\"Attemptingto get a Cipher and encrypt...\");\n    \t\tCipher cipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\n    \t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n    \t\tbyte[] cipherText = cipher.doFinal(stringToEncrypt.getBytes(\"UTF8\"));\n    \t\tSystem.out.println(\"OK\");\n    \t\tSystem.out.println(\"Testcompleted successfully.\");\n    \t}\n    }\n    \n\n当输出结果为下文时，代表搭建成功\n\n\tAttemptingto get a Blowfish key...OK\n\tAttemptingto get a Cipher and encrypt...\n\tOK\n\tTestcompleted successfully.\n    \n\n\n\n\n\n","slug":"20160303Linux下搭建Bouncycastle环境","published":1,"updated":"2020-12-09T06:29:49.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278juro000pb3t18ixn8wwj","content":"<p>Bouncycastle是一种Java平台开放源码的轻量级密码术包，可用来管理Android的证书。此次因为需要自己生成Https的证书，因此，专门学习了一下搭建Bouncycastle环境的方法，对学习过程记录如下：</p>\n<h3 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h3><p>我使用的环境信息如下：</p>\n<ul>\n<li>Linux版本：CentOS 5.8 64位操作系统</li>\n<li>Java版本：1.6.0_35</li>\n</ul>\n<h3 id=\"2-搭建步骤\"><a href=\"#2-搭建步骤\" class=\"headerlink\" title=\"2. 搭建步骤\"></a>2. 搭建步骤</h3><p>具体搭建步骤记录如下：</p>\n<h4 id=\"2-1-下载Bouncycastle的Jar包\"><a href=\"#2-1-下载Bouncycastle的Jar包\" class=\"headerlink\" title=\"2.1 下载Bouncycastle的Jar包\"></a>2.1 下载Bouncycastle的Jar包</h4><p>官方网站地址是：<a href=\"http://www.bouncycastle.org/latest_releases.html\">Bouncycastle官网</a>，网页上有两个可以下载的：</p>\n<p>一个是crypto-154.tar.gZ(文件较小，但是我下载了以后，出现无法解压的现象，windows和linux下均无法解压)</p>\n<p>另外一个是crypto-154.zip,推荐下载该版本，文件较大，可以直接解压得到jar文件夹，这里因为我的java版本是1.6的所以选择了<code>bcprov-debug-jdk15on-154.jar</code>。</p>\n<p>或者也可以直接点击下载 <a href=\"http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar\">bcprov-jdk15on-146.jar</a></p>\n<h4 id=\"2-2-上传下载的安装包\"><a href=\"#2-2-上传下载的安装包\" class=\"headerlink\" title=\"2.2 上传下载的安装包\"></a>2.2 上传下载的安装包</h4><p>将下载得到的Jar包上传到linux服务器上，找到java的根目录，将其放在jre&#x2F;lib&#x2F;ext&#x2F;目录下。如果找不到jre的路径，可以使用echo命令进行打印</p>\n<pre><code>echo $JAVA_HOME\n</code></pre>\n<p><img src=\"http://image.jucaiwy.com/image/20160303/bouncycastle1.png\"></p>\n<h4 id=\"2-3-配置\"><a href=\"#2-3-配置\" class=\"headerlink\" title=\"2.3 配置\"></a>2.3 配置</h4><p>修改jre&#x2F;lib&#x2F;security&#x2F;java.security文件，在其provider列表中添加一条：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">security.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider</span><br></pre></td></tr></table></figure>\n\n<p>安装到此结束</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160303/bouncycastle2.png\"></p>\n<h3 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h3><p>新建Test.java文件，添加以下代码：</p>\n<pre><code>import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class Test\n&#123;\n    public static final String stringToEncrypt = &quot;Thisis a test.&quot;;\n    \n    public static void main(String[] args) throws Exception\n    &#123;\n        System.out.print(&quot;Attemptingto get a Blowfish key...&quot;);\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;Blowfish&quot;);\n        keyGenerator.init(128);\n        SecretKey key = keyGenerator.generateKey();\n        System.out.println(&quot;OK&quot;);\n        System.out.println(&quot;Attemptingto get a Cipher and encrypt...&quot;);\n        Cipher cipher = Cipher.getInstance(&quot;Blowfish/ECB/PKCS5Padding&quot;);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] cipherText = cipher.doFinal(stringToEncrypt.getBytes(&quot;UTF8&quot;));\n        System.out.println(&quot;OK&quot;);\n        System.out.println(&quot;Testcompleted successfully.&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>当输出结果为下文时，代表搭建成功</p>\n<pre><code>Attemptingto get a Blowfish key...OK\nAttemptingto get a Cipher and encrypt...\nOK\nTestcompleted successfully.\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Bouncycastle是一种Java平台开放源码的轻量级密码术包，可用来管理Android的证书。此次因为需要自己生成Https的证书，因此，专门学习了一下搭建Bouncycastle环境的方法，对学习过程记录如下：</p>\n<h3 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h3><p>我使用的环境信息如下：</p>\n<ul>\n<li>Linux版本：CentOS 5.8 64位操作系统</li>\n<li>Java版本：1.6.0_35</li>\n</ul>\n<h3 id=\"2-搭建步骤\"><a href=\"#2-搭建步骤\" class=\"headerlink\" title=\"2. 搭建步骤\"></a>2. 搭建步骤</h3><p>具体搭建步骤记录如下：</p>\n<h4 id=\"2-1-下载Bouncycastle的Jar包\"><a href=\"#2-1-下载Bouncycastle的Jar包\" class=\"headerlink\" title=\"2.1 下载Bouncycastle的Jar包\"></a>2.1 下载Bouncycastle的Jar包</h4><p>官方网站地址是：<a href=\"http://www.bouncycastle.org/latest_releases.html\">Bouncycastle官网</a>，网页上有两个可以下载的：</p>\n<p>一个是crypto-154.tar.gZ(文件较小，但是我下载了以后，出现无法解压的现象，windows和linux下均无法解压)</p>\n<p>另外一个是crypto-154.zip,推荐下载该版本，文件较大，可以直接解压得到jar文件夹，这里因为我的java版本是1.6的所以选择了<code>bcprov-debug-jdk15on-154.jar</code>。</p>\n<p>或者也可以直接点击下载 <a href=\"http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar\">bcprov-jdk15on-146.jar</a></p>\n<h4 id=\"2-2-上传下载的安装包\"><a href=\"#2-2-上传下载的安装包\" class=\"headerlink\" title=\"2.2 上传下载的安装包\"></a>2.2 上传下载的安装包</h4><p>将下载得到的Jar包上传到linux服务器上，找到java的根目录，将其放在jre&#x2F;lib&#x2F;ext&#x2F;目录下。如果找不到jre的路径，可以使用echo命令进行打印</p>\n<pre><code>echo $JAVA_HOME\n</code></pre>\n<p><img src=\"http://image.jucaiwy.com/image/20160303/bouncycastle1.png\"></p>\n<h4 id=\"2-3-配置\"><a href=\"#2-3-配置\" class=\"headerlink\" title=\"2.3 配置\"></a>2.3 配置</h4><p>修改jre&#x2F;lib&#x2F;security&#x2F;java.security文件，在其provider列表中添加一条：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">security.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider</span><br></pre></td></tr></table></figure>\n\n<p>安装到此结束</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160303/bouncycastle2.png\"></p>\n<h3 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h3><p>新建Test.java文件，添加以下代码：</p>\n<pre><code>import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class Test\n&#123;\n    public static final String stringToEncrypt = &quot;Thisis a test.&quot;;\n    \n    public static void main(String[] args) throws Exception\n    &#123;\n        System.out.print(&quot;Attemptingto get a Blowfish key...&quot;);\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;Blowfish&quot;);\n        keyGenerator.init(128);\n        SecretKey key = keyGenerator.generateKey();\n        System.out.println(&quot;OK&quot;);\n        System.out.println(&quot;Attemptingto get a Cipher and encrypt...&quot;);\n        Cipher cipher = Cipher.getInstance(&quot;Blowfish/ECB/PKCS5Padding&quot;);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] cipherText = cipher.doFinal(stringToEncrypt.getBytes(&quot;UTF8&quot;));\n        System.out.println(&quot;OK&quot;);\n        System.out.println(&quot;Testcompleted successfully.&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>当输出结果为下文时，代表搭建成功</p>\n<pre><code>Attemptingto get a Blowfish key...OK\nAttemptingto get a Cipher and encrypt...\nOK\nTestcompleted successfully.\n</code></pre>\n"},{"title":"Https单双向认证","date":"2016-03-10T03:54:46.000Z","keywords":"Https单向认证，Https双向认证","description":"Https单双向认证","top_img":"http://image.jucaiwy.com/image/20160310/http_https.jpeg","cover":"http://image.jucaiwy.com/image/20160310/http_https.jpeg","_content":"\n\nHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。\n\n\n### 一、Http\nHyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。\n\n使用TCP端口为：80\n\n### 二、Https\n\nHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。\n\n使用TCP端口默认为443\n\n### 三、SSL协议加密方式\nSSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。\n\n1. 对称加密\n\t速度高，可加密内容较大，用来加密会话过程中的消息\n\n2. 公钥加密\n\t加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥\n\n### 四、单向认证\n\nHttps在建立Socket连接之前，需要进行握手，具体过程如下：\n\n![这里写图片描述](http://image.jucaiwy.com/image/20160310/single.jpg)\n\n1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。\n2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书\n3. 客户端使用服务端返回的信息验证服务器的合法性，包括：\n\n\t- 证书是否过期 \n\t- 发型服务器证书的CA是否可靠\n\t- 返回的公钥是否能正确解开返回证书中的数字签名\n\t- 服务器证书上的域名是否和服务器的实际域名相匹配\n \n\t以上四条，验证通过后，将继续进行通信，否则，终止通信\n4. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择\n5. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。\n6. 服务器将选择好的加密方案通过明文方式返回给客户端\n7. 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器\n8. 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。\n\n\n### 五、双向认证\n\n双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：\n\n![这里写图片描述](http://image.jucaiwy.com/image/20160310/two_way.jpg)\n\n\n1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。\n2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书\n3. 客户端使用服务端返回的信息验证服务器的合法性，包括：\n\n\t- 证书是否过期 \n\t- 发型服务器证书的CA是否可靠\n\t- 返回的公钥是否能正确解开返回证书中的数字签名\n\t- 服务器证书上的域名是否和服务器的实际域名相匹配\n \n\t以上四条，验证通过后，将继续进行通信，否则，终止通信\n4. 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端\n5. 验证客户端的证书，通过验证后，会获得客户端的公钥\n6. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择\n7. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式\n8. 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端\n9. 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端\n10. 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。\n","source":"_posts/20160310Https单双向认证.md","raw":"---\n\ntitle: Https单双向认证\n\ndate: 2016-03-10 11:54:46\n\ntags: [Https , Https单向认证 , Https双向认证]\n\ncategories: Https\n\nkeywords: Https单向认证，Https双向认证\n\ndescription: Https单双向认证\n\ntop_img: http://image.jucaiwy.com/image/20160310/http_https.jpeg\n\ncover: http://image.jucaiwy.com/image/20160310/http_https.jpeg\n\n---\n\n\nHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。\n\n\n### 一、Http\nHyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。\n\n使用TCP端口为：80\n\n### 二、Https\n\nHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。\n\n使用TCP端口默认为443\n\n### 三、SSL协议加密方式\nSSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。\n\n1. 对称加密\n\t速度高，可加密内容较大，用来加密会话过程中的消息\n\n2. 公钥加密\n\t加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥\n\n### 四、单向认证\n\nHttps在建立Socket连接之前，需要进行握手，具体过程如下：\n\n![这里写图片描述](http://image.jucaiwy.com/image/20160310/single.jpg)\n\n1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。\n2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书\n3. 客户端使用服务端返回的信息验证服务器的合法性，包括：\n\n\t- 证书是否过期 \n\t- 发型服务器证书的CA是否可靠\n\t- 返回的公钥是否能正确解开返回证书中的数字签名\n\t- 服务器证书上的域名是否和服务器的实际域名相匹配\n \n\t以上四条，验证通过后，将继续进行通信，否则，终止通信\n4. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择\n5. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。\n6. 服务器将选择好的加密方案通过明文方式返回给客户端\n7. 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器\n8. 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。\n\n\n### 五、双向认证\n\n双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：\n\n![这里写图片描述](http://image.jucaiwy.com/image/20160310/two_way.jpg)\n\n\n1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。\n2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书\n3. 客户端使用服务端返回的信息验证服务器的合法性，包括：\n\n\t- 证书是否过期 \n\t- 发型服务器证书的CA是否可靠\n\t- 返回的公钥是否能正确解开返回证书中的数字签名\n\t- 服务器证书上的域名是否和服务器的实际域名相匹配\n \n\t以上四条，验证通过后，将继续进行通信，否则，终止通信\n4. 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端\n5. 验证客户端的证书，通过验证后，会获得客户端的公钥\n6. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择\n7. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式\n8. 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端\n9. 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端\n10. 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。\n","slug":"20160310Https单双向认证","published":1,"updated":"2020-12-09T06:30:19.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurp000ub3t14q8a9ltb","content":"<p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p>\n<h3 id=\"一、Http\"><a href=\"#一、Http\" class=\"headerlink\" title=\"一、Http\"></a>一、Http</h3><p>HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。</p>\n<p>使用TCP端口为：80</p>\n<h3 id=\"二、Https\"><a href=\"#二、Https\" class=\"headerlink\" title=\"二、Https\"></a>二、Https</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p>\n<p>使用TCP端口默认为443</p>\n<h3 id=\"三、SSL协议加密方式\"><a href=\"#三、SSL协议加密方式\" class=\"headerlink\" title=\"三、SSL协议加密方式\"></a>三、SSL协议加密方式</h3><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p>\n<ol>\n<li><p>对称加密<br> 速度高，可加密内容较大，用来加密会话过程中的消息</p>\n</li>\n<li><p>公钥加密<br> 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p>\n</li>\n</ol>\n<h3 id=\"四、单向认证\"><a href=\"#四、单向认证\" class=\"headerlink\" title=\"四、单向认证\"></a>四、单向认证</h3><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160310/single.jpg\" alt=\"这里写图片描述\"></p>\n<ol>\n<li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>\n</li>\n<li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>\n</li>\n<li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p>\n<ul>\n<li>证书是否过期 </li>\n<li>发型服务器证书的CA是否可靠</li>\n<li>返回的公钥是否能正确解开返回证书中的数字签名</li>\n<li>服务器证书上的域名是否和服务器的实际域名相匹配</li>\n</ul>\n<p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p>\n</li>\n<li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>\n</li>\n<li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>\n</li>\n<li><p>服务器将选择好的加密方案通过明文方式返回给客户端</p>\n</li>\n<li><p>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</p>\n</li>\n<li><p>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>\n</li>\n</ol>\n<h3 id=\"五、双向认证\"><a href=\"#五、双向认证\" class=\"headerlink\" title=\"五、双向认证\"></a>五、双向认证</h3><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160310/two_way.jpg\" alt=\"这里写图片描述\"></p>\n<ol>\n<li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>\n</li>\n<li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>\n</li>\n<li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p>\n<ul>\n<li>证书是否过期 </li>\n<li>发型服务器证书的CA是否可靠</li>\n<li>返回的公钥是否能正确解开返回证书中的数字签名</li>\n<li>服务器证书上的域名是否和服务器的实际域名相匹配</li>\n</ul>\n<p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p>\n</li>\n<li><p>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</p>\n</li>\n<li><p>验证客户端的证书，通过验证后，会获得客户端的公钥</p>\n</li>\n<li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>\n</li>\n<li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</p>\n</li>\n<li><p>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</p>\n</li>\n<li><p>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</p>\n</li>\n<li><p>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p>\n<h3 id=\"一、Http\"><a href=\"#一、Http\" class=\"headerlink\" title=\"一、Http\"></a>一、Http</h3><p>HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。</p>\n<p>使用TCP端口为：80</p>\n<h3 id=\"二、Https\"><a href=\"#二、Https\" class=\"headerlink\" title=\"二、Https\"></a>二、Https</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p>\n<p>使用TCP端口默认为443</p>\n<h3 id=\"三、SSL协议加密方式\"><a href=\"#三、SSL协议加密方式\" class=\"headerlink\" title=\"三、SSL协议加密方式\"></a>三、SSL协议加密方式</h3><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p>\n<ol>\n<li><p>对称加密<br> 速度高，可加密内容较大，用来加密会话过程中的消息</p>\n</li>\n<li><p>公钥加密<br> 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p>\n</li>\n</ol>\n<h3 id=\"四、单向认证\"><a href=\"#四、单向认证\" class=\"headerlink\" title=\"四、单向认证\"></a>四、单向认证</h3><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160310/single.jpg\" alt=\"这里写图片描述\"></p>\n<ol>\n<li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>\n</li>\n<li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>\n</li>\n<li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p>\n<ul>\n<li>证书是否过期 </li>\n<li>发型服务器证书的CA是否可靠</li>\n<li>返回的公钥是否能正确解开返回证书中的数字签名</li>\n<li>服务器证书上的域名是否和服务器的实际域名相匹配</li>\n</ul>\n<p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p>\n</li>\n<li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>\n</li>\n<li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>\n</li>\n<li><p>服务器将选择好的加密方案通过明文方式返回给客户端</p>\n</li>\n<li><p>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</p>\n</li>\n<li><p>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>\n</li>\n</ol>\n<h3 id=\"五、双向认证\"><a href=\"#五、双向认证\" class=\"headerlink\" title=\"五、双向认证\"></a>五、双向认证</h3><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160310/two_way.jpg\" alt=\"这里写图片描述\"></p>\n<ol>\n<li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>\n</li>\n<li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>\n</li>\n<li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p>\n<ul>\n<li>证书是否过期 </li>\n<li>发型服务器证书的CA是否可靠</li>\n<li>返回的公钥是否能正确解开返回证书中的数字签名</li>\n<li>服务器证书上的域名是否和服务器的实际域名相匹配</li>\n</ul>\n<p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p>\n</li>\n<li><p>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</p>\n</li>\n<li><p>验证客户端的证书，通过验证后，会获得客户端的公钥</p>\n</li>\n<li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>\n</li>\n<li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</p>\n</li>\n<li><p>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</p>\n</li>\n<li><p>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</p>\n</li>\n<li><p>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>\n</li>\n</ol>\n"},{"title":"Android升级6.0后使用Https请求出现Handshake failed错误","date":"2016-04-29T10:34:46.000Z","keywords":"Android , CRC","description":"Android升级6.0后使用Https请求出现Handshake failed错误","top_img":"http://image.jucaiwy.com/image/20160317/hand_shack.jpeg","cover":"http://image.jucaiwy.com/image/20160317/hand_shack.jpeg","_content":"\n昨天手残，使用HTC M8升级了一下最新系统，Android6.0版本的，升级后，在测试我们的应用时，突然出现握手失败错误：\n\n![](http://image.jucaiwy.com/image/20160317/FPf2n91.png)\n\n即显示握手失败，但是在Android6.0以下版本中，并没有出现该问题。\n\n### 一、Android6.0的一些修改\n因为该问题仅仅出现在Android6.0版本中，因此，考虑是由版本升级引起的。查看Google给出的Android6.0修改文档，发现以下两点：\n\n![](http://image.jucaiwy.com/image/20160317/CMFFR7g.png)\n\n即：\n\n1. 从Android6.0之后将不再支持HttpClient的使用，建议使用HttpURLConnection代替。\n2. Android6.0之后，在Https请求中，SSL层将不再使用OpenSSL协议，改用自己的BoringSSL协议\n\n### 2. 分析\n\n#### 2.1 取消HttpClient\n在我们的项目中使用的是HttpClient执行Https请求，但是官方升级只是在API文档中删除了HttpClient相关的文件，但是并不影响其使用，用户可以通过以下两种方法继续使用：\n\n1. 使用Android6.0进行编译，则需要添加 org.apache.http.legacy.jar,文件目录：SDK\\platforms\\android-23\\optional；或者是在AndroidStudio中的build.gradle文件中加入：**android {useLibrary 'org.apache.http.legacy'}**\n\n2. 使用Android6.0以下版本进行编译。\n\n因此，排除该可能。\n\n#### 2.2 使用BoringSSL替换OpenSSL\n因为考虑到是该问题引起的，因此回过头重新对握手失败原因进行查看，发现在之前Log结尾部分忽略了一句话，也正是因为忽略这句话，导致之前思维一直停在可能是HttpClient被取消导致的，浪费了很多时间，握手失败后，在最后边Log中，出现这样的信息：\n\n![](http://image.jucaiwy.com/image/20160317/zUP4Cli.png)\n\n\n关键字：**BAD_DH_P_LENGTH** \n\n经过一番寻找，发现意思应该是Diffie-Hellman的p参数长度错误。主要参考文章：[谢谢大神——连接](http://bbs.csdn.net/topics/391843187)\n\n通过对帖子的阅读和资料的查找，总结其主要原因在于：\n\nHttps建立连接之前，会进行多次握手，即单向认证和双向认证。在该过程中，客户端会将自己支持的所有加密方式发送给服务端，供服务端选择，服务端选择好加密程度较高的加密方式后，会以明文或者是客户端私钥加密密文的方式发送给客户端。\n\n具体认证过程可参考我的上一篇文章：[Https单向认证和双向认证](http://blog.csdn.net/duanbokan/article/details/50847612)\n\n在握手过程中，必定会涉及到公钥加密，私钥解密的过程，而该过程中，当服务端选择使用诸如`TLS_DHE_RSA_WITH_AES_128_CBC_SHA`等算法进行加密时，需要使用到[Diffie-Hellman](http://baike.baidu.com/link?url=bXqyg5o-fpDYcqQ753nR659lJcU9TTxS9dP2SDxUVSHS_b0BURjiMAkBsQbocBDX9OMb0gosZHgsT9_Hlszt-q)算法进行加密解密，通过阅读Diffie-Hellman算法的介绍，发现在加密解密计算过程中，会使用到两个参数，一个是q，一个是a，而在JDK8之前，服务器端提供的q参数只是用了768bit的长度，而不足1024bit则存在相应的安全漏洞，会被替换后的BroingSSL拒绝，因此出现了Handshake failed错误。\n\n终于找到问题所在了,总结这个纠结的过程，我只想说：一定要认真看Log！！！\n\n\n### 3. 解决方案\n通过阅读上边提到的大神写的帖子，发现两种可以解决的办法：\n\n1. 升级JDK到8(条件限制，未经过测试)\n\n2. 配置Tomcat服务器，限制加密方式：\n\n\t修改Tomcat服务器conf/server.xml文件中和Https有关的Connector节点，添加ciphers用于指定密钥：\n    \n    \t<Connector \n    \t\tSSLEnabled=\"true\" \n    \t\tclientAuth=\"false\" \n\t    \tconnectionTimeout=\"20000\" \n\t    \tkeystoreFile=\"/usr/xinwei/tienlen/apache-tomcat-https/server.keystore\" \n\t    \tkeystorePass=\"xinwei\" \n\t    \tmaxThreads=\"150\" \n\t    \tport=\"443\" \n\t    \tprotocol=\"org.apache.coyote.http11.Http11Protocol\" \n\t    \tredirectPort=\"8443\" \n\t    \tscheme=\"https\" \n\t    \tsecure=\"true\" \n\t    \tciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA256,\n\t      \tTLS_RSA_WITH_AES_128_CBC_SHA,\n\t      \tTLS_RSA_WITH_AES_256_CBC_SHA256,\n\t      \tTLS_RSA_WITH_AES_256_CBC_SHA,\n\t      \tSSL_RSA_WITH_3DES_EDE_CBC_SHA\"\n\t    \tsslProtocol=\"TLS\" \n\t    \ttruststoreFile=\"/usr/xinwei/tienlen/apache-tomcat-https/server.keystore\" \n\t    \ttruststorePass=\"密码\"\n    \t/>\n\n添加完该配置后，重启，测试，Android6.0版本没有再发现Handshake failed错误。\n\n\n### 4. 总结\n这篇文章主要是记录了我解决该问题的过程和方法，没什么特别多的原创。主要是在原文作者的基础上，更深入的解释了一下出现该错误的原因。\n\n同时也因为我的疏忽，浪费了大量时间，引以为戒。","source":"_posts/20160317Android6.0握手失败问题.md","raw":"---\n\ntitle: Android升级6.0后使用Https请求出现Handshake failed错误\n\ndate: 2016-04-29 18:34:46\n\ntags: [ Android , HTTP]\n\ncategories: [ Android , 问题记录]\n\nkeywords: Android , CRC\n\ndescription: Android升级6.0后使用Https请求出现Handshake failed错误\n\ntop_img: http://image.jucaiwy.com/image/20160317/hand_shack.jpeg\n\ncover: http://image.jucaiwy.com/image/20160317/hand_shack.jpeg\n\n---\n\n昨天手残，使用HTC M8升级了一下最新系统，Android6.0版本的，升级后，在测试我们的应用时，突然出现握手失败错误：\n\n![](http://image.jucaiwy.com/image/20160317/FPf2n91.png)\n\n即显示握手失败，但是在Android6.0以下版本中，并没有出现该问题。\n\n### 一、Android6.0的一些修改\n因为该问题仅仅出现在Android6.0版本中，因此，考虑是由版本升级引起的。查看Google给出的Android6.0修改文档，发现以下两点：\n\n![](http://image.jucaiwy.com/image/20160317/CMFFR7g.png)\n\n即：\n\n1. 从Android6.0之后将不再支持HttpClient的使用，建议使用HttpURLConnection代替。\n2. Android6.0之后，在Https请求中，SSL层将不再使用OpenSSL协议，改用自己的BoringSSL协议\n\n### 2. 分析\n\n#### 2.1 取消HttpClient\n在我们的项目中使用的是HttpClient执行Https请求，但是官方升级只是在API文档中删除了HttpClient相关的文件，但是并不影响其使用，用户可以通过以下两种方法继续使用：\n\n1. 使用Android6.0进行编译，则需要添加 org.apache.http.legacy.jar,文件目录：SDK\\platforms\\android-23\\optional；或者是在AndroidStudio中的build.gradle文件中加入：**android {useLibrary 'org.apache.http.legacy'}**\n\n2. 使用Android6.0以下版本进行编译。\n\n因此，排除该可能。\n\n#### 2.2 使用BoringSSL替换OpenSSL\n因为考虑到是该问题引起的，因此回过头重新对握手失败原因进行查看，发现在之前Log结尾部分忽略了一句话，也正是因为忽略这句话，导致之前思维一直停在可能是HttpClient被取消导致的，浪费了很多时间，握手失败后，在最后边Log中，出现这样的信息：\n\n![](http://image.jucaiwy.com/image/20160317/zUP4Cli.png)\n\n\n关键字：**BAD_DH_P_LENGTH** \n\n经过一番寻找，发现意思应该是Diffie-Hellman的p参数长度错误。主要参考文章：[谢谢大神——连接](http://bbs.csdn.net/topics/391843187)\n\n通过对帖子的阅读和资料的查找，总结其主要原因在于：\n\nHttps建立连接之前，会进行多次握手，即单向认证和双向认证。在该过程中，客户端会将自己支持的所有加密方式发送给服务端，供服务端选择，服务端选择好加密程度较高的加密方式后，会以明文或者是客户端私钥加密密文的方式发送给客户端。\n\n具体认证过程可参考我的上一篇文章：[Https单向认证和双向认证](http://blog.csdn.net/duanbokan/article/details/50847612)\n\n在握手过程中，必定会涉及到公钥加密，私钥解密的过程，而该过程中，当服务端选择使用诸如`TLS_DHE_RSA_WITH_AES_128_CBC_SHA`等算法进行加密时，需要使用到[Diffie-Hellman](http://baike.baidu.com/link?url=bXqyg5o-fpDYcqQ753nR659lJcU9TTxS9dP2SDxUVSHS_b0BURjiMAkBsQbocBDX9OMb0gosZHgsT9_Hlszt-q)算法进行加密解密，通过阅读Diffie-Hellman算法的介绍，发现在加密解密计算过程中，会使用到两个参数，一个是q，一个是a，而在JDK8之前，服务器端提供的q参数只是用了768bit的长度，而不足1024bit则存在相应的安全漏洞，会被替换后的BroingSSL拒绝，因此出现了Handshake failed错误。\n\n终于找到问题所在了,总结这个纠结的过程，我只想说：一定要认真看Log！！！\n\n\n### 3. 解决方案\n通过阅读上边提到的大神写的帖子，发现两种可以解决的办法：\n\n1. 升级JDK到8(条件限制，未经过测试)\n\n2. 配置Tomcat服务器，限制加密方式：\n\n\t修改Tomcat服务器conf/server.xml文件中和Https有关的Connector节点，添加ciphers用于指定密钥：\n    \n    \t<Connector \n    \t\tSSLEnabled=\"true\" \n    \t\tclientAuth=\"false\" \n\t    \tconnectionTimeout=\"20000\" \n\t    \tkeystoreFile=\"/usr/xinwei/tienlen/apache-tomcat-https/server.keystore\" \n\t    \tkeystorePass=\"xinwei\" \n\t    \tmaxThreads=\"150\" \n\t    \tport=\"443\" \n\t    \tprotocol=\"org.apache.coyote.http11.Http11Protocol\" \n\t    \tredirectPort=\"8443\" \n\t    \tscheme=\"https\" \n\t    \tsecure=\"true\" \n\t    \tciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA256,\n\t      \tTLS_RSA_WITH_AES_128_CBC_SHA,\n\t      \tTLS_RSA_WITH_AES_256_CBC_SHA256,\n\t      \tTLS_RSA_WITH_AES_256_CBC_SHA,\n\t      \tSSL_RSA_WITH_3DES_EDE_CBC_SHA\"\n\t    \tsslProtocol=\"TLS\" \n\t    \ttruststoreFile=\"/usr/xinwei/tienlen/apache-tomcat-https/server.keystore\" \n\t    \ttruststorePass=\"密码\"\n    \t/>\n\n添加完该配置后，重启，测试，Android6.0版本没有再发现Handshake failed错误。\n\n\n### 4. 总结\n这篇文章主要是记录了我解决该问题的过程和方法，没什么特别多的原创。主要是在原文作者的基础上，更深入的解释了一下出现该错误的原因。\n\n同时也因为我的疏忽，浪费了大量时间，引以为戒。","slug":"20160317Android6.0握手失败问题","published":1,"updated":"2020-12-09T06:30:57.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurp000xb3t14kfs891n","content":"<p>昨天手残，使用HTC M8升级了一下最新系统，Android6.0版本的，升级后，在测试我们的应用时，突然出现握手失败错误：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/FPf2n91.png\"></p>\n<p>即显示握手失败，但是在Android6.0以下版本中，并没有出现该问题。</p>\n<h3 id=\"一、Android6-0的一些修改\"><a href=\"#一、Android6-0的一些修改\" class=\"headerlink\" title=\"一、Android6.0的一些修改\"></a>一、Android6.0的一些修改</h3><p>因为该问题仅仅出现在Android6.0版本中，因此，考虑是由版本升级引起的。查看Google给出的Android6.0修改文档，发现以下两点：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/CMFFR7g.png\"></p>\n<p>即：</p>\n<ol>\n<li>从Android6.0之后将不再支持HttpClient的使用，建议使用HttpURLConnection代替。</li>\n<li>Android6.0之后，在Https请求中，SSL层将不再使用OpenSSL协议，改用自己的BoringSSL协议</li>\n</ol>\n<h3 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2. 分析\"></a>2. 分析</h3><h4 id=\"2-1-取消HttpClient\"><a href=\"#2-1-取消HttpClient\" class=\"headerlink\" title=\"2.1 取消HttpClient\"></a>2.1 取消HttpClient</h4><p>在我们的项目中使用的是HttpClient执行Https请求，但是官方升级只是在API文档中删除了HttpClient相关的文件，但是并不影响其使用，用户可以通过以下两种方法继续使用：</p>\n<ol>\n<li><p>使用Android6.0进行编译，则需要添加 org.apache.http.legacy.jar,文件目录：SDK\\platforms\\android-23\\optional；或者是在AndroidStudio中的build.gradle文件中加入：<strong>android {useLibrary ‘org.apache.http.legacy’}</strong></p>\n</li>\n<li><p>使用Android6.0以下版本进行编译。</p>\n</li>\n</ol>\n<p>因此，排除该可能。</p>\n<h4 id=\"2-2-使用BoringSSL替换OpenSSL\"><a href=\"#2-2-使用BoringSSL替换OpenSSL\" class=\"headerlink\" title=\"2.2 使用BoringSSL替换OpenSSL\"></a>2.2 使用BoringSSL替换OpenSSL</h4><p>因为考虑到是该问题引起的，因此回过头重新对握手失败原因进行查看，发现在之前Log结尾部分忽略了一句话，也正是因为忽略这句话，导致之前思维一直停在可能是HttpClient被取消导致的，浪费了很多时间，握手失败后，在最后边Log中，出现这样的信息：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/zUP4Cli.png\"></p>\n<p>关键字：<strong>BAD_DH_P_LENGTH</strong> </p>\n<p>经过一番寻找，发现意思应该是Diffie-Hellman的p参数长度错误。主要参考文章：<a href=\"http://bbs.csdn.net/topics/391843187\">谢谢大神——连接</a></p>\n<p>通过对帖子的阅读和资料的查找，总结其主要原因在于：</p>\n<p>Https建立连接之前，会进行多次握手，即单向认证和双向认证。在该过程中，客户端会将自己支持的所有加密方式发送给服务端，供服务端选择，服务端选择好加密程度较高的加密方式后，会以明文或者是客户端私钥加密密文的方式发送给客户端。</p>\n<p>具体认证过程可参考我的上一篇文章：<a href=\"http://blog.csdn.net/duanbokan/article/details/50847612\">Https单向认证和双向认证</a></p>\n<p>在握手过程中，必定会涉及到公钥加密，私钥解密的过程，而该过程中，当服务端选择使用诸如<code>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</code>等算法进行加密时，需要使用到<a href=\"http://baike.baidu.com/link?url=bXqyg5o-fpDYcqQ753nR659lJcU9TTxS9dP2SDxUVSHS_b0BURjiMAkBsQbocBDX9OMb0gosZHgsT9_Hlszt-q\">Diffie-Hellman</a>算法进行加密解密，通过阅读Diffie-Hellman算法的介绍，发现在加密解密计算过程中，会使用到两个参数，一个是q，一个是a，而在JDK8之前，服务器端提供的q参数只是用了768bit的长度，而不足1024bit则存在相应的安全漏洞，会被替换后的BroingSSL拒绝，因此出现了Handshake failed错误。</p>\n<p>终于找到问题所在了,总结这个纠结的过程，我只想说：一定要认真看Log！！！</p>\n<h3 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h3><p>通过阅读上边提到的大神写的帖子，发现两种可以解决的办法：</p>\n<ol>\n<li><p>升级JDK到8(条件限制，未经过测试)</p>\n</li>\n<li><p>配置Tomcat服务器，限制加密方式：</p>\n<p> 修改Tomcat服务器conf&#x2F;server.xml文件中和Https有关的Connector节点，添加ciphers用于指定密钥：</p>\n<pre><code> &lt;Connector \n     SSLEnabled=&quot;true&quot; \n     clientAuth=&quot;false&quot; \n     connectionTimeout=&quot;20000&quot; \n     keystoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot; \n     keystorePass=&quot;xinwei&quot; \n     maxThreads=&quot;150&quot; \n     port=&quot;443&quot; \n     protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; \n     redirectPort=&quot;8443&quot; \n     scheme=&quot;https&quot; \n     secure=&quot;true&quot; \n     ciphers=&quot;TLS_RSA_WITH_AES_128_CBC_SHA256,\n       TLS_RSA_WITH_AES_128_CBC_SHA,\n       TLS_RSA_WITH_AES_256_CBC_SHA256,\n       TLS_RSA_WITH_AES_256_CBC_SHA,\n       SSL_RSA_WITH_3DES_EDE_CBC_SHA&quot;\n     sslProtocol=&quot;TLS&quot; \n     truststoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot; \n     truststorePass=&quot;密码&quot;\n /&gt;\n</code></pre>\n</li>\n</ol>\n<p>添加完该配置后，重启，测试，Android6.0版本没有再发现Handshake failed错误。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>这篇文章主要是记录了我解决该问题的过程和方法，没什么特别多的原创。主要是在原文作者的基础上，更深入的解释了一下出现该错误的原因。</p>\n<p>同时也因为我的疏忽，浪费了大量时间，引以为戒。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天手残，使用HTC M8升级了一下最新系统，Android6.0版本的，升级后，在测试我们的应用时，突然出现握手失败错误：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/FPf2n91.png\"></p>\n<p>即显示握手失败，但是在Android6.0以下版本中，并没有出现该问题。</p>\n<h3 id=\"一、Android6-0的一些修改\"><a href=\"#一、Android6-0的一些修改\" class=\"headerlink\" title=\"一、Android6.0的一些修改\"></a>一、Android6.0的一些修改</h3><p>因为该问题仅仅出现在Android6.0版本中，因此，考虑是由版本升级引起的。查看Google给出的Android6.0修改文档，发现以下两点：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/CMFFR7g.png\"></p>\n<p>即：</p>\n<ol>\n<li>从Android6.0之后将不再支持HttpClient的使用，建议使用HttpURLConnection代替。</li>\n<li>Android6.0之后，在Https请求中，SSL层将不再使用OpenSSL协议，改用自己的BoringSSL协议</li>\n</ol>\n<h3 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2. 分析\"></a>2. 分析</h3><h4 id=\"2-1-取消HttpClient\"><a href=\"#2-1-取消HttpClient\" class=\"headerlink\" title=\"2.1 取消HttpClient\"></a>2.1 取消HttpClient</h4><p>在我们的项目中使用的是HttpClient执行Https请求，但是官方升级只是在API文档中删除了HttpClient相关的文件，但是并不影响其使用，用户可以通过以下两种方法继续使用：</p>\n<ol>\n<li><p>使用Android6.0进行编译，则需要添加 org.apache.http.legacy.jar,文件目录：SDK\\platforms\\android-23\\optional；或者是在AndroidStudio中的build.gradle文件中加入：<strong>android {useLibrary ‘org.apache.http.legacy’}</strong></p>\n</li>\n<li><p>使用Android6.0以下版本进行编译。</p>\n</li>\n</ol>\n<p>因此，排除该可能。</p>\n<h4 id=\"2-2-使用BoringSSL替换OpenSSL\"><a href=\"#2-2-使用BoringSSL替换OpenSSL\" class=\"headerlink\" title=\"2.2 使用BoringSSL替换OpenSSL\"></a>2.2 使用BoringSSL替换OpenSSL</h4><p>因为考虑到是该问题引起的，因此回过头重新对握手失败原因进行查看，发现在之前Log结尾部分忽略了一句话，也正是因为忽略这句话，导致之前思维一直停在可能是HttpClient被取消导致的，浪费了很多时间，握手失败后，在最后边Log中，出现这样的信息：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160317/zUP4Cli.png\"></p>\n<p>关键字：<strong>BAD_DH_P_LENGTH</strong> </p>\n<p>经过一番寻找，发现意思应该是Diffie-Hellman的p参数长度错误。主要参考文章：<a href=\"http://bbs.csdn.net/topics/391843187\">谢谢大神——连接</a></p>\n<p>通过对帖子的阅读和资料的查找，总结其主要原因在于：</p>\n<p>Https建立连接之前，会进行多次握手，即单向认证和双向认证。在该过程中，客户端会将自己支持的所有加密方式发送给服务端，供服务端选择，服务端选择好加密程度较高的加密方式后，会以明文或者是客户端私钥加密密文的方式发送给客户端。</p>\n<p>具体认证过程可参考我的上一篇文章：<a href=\"http://blog.csdn.net/duanbokan/article/details/50847612\">Https单向认证和双向认证</a></p>\n<p>在握手过程中，必定会涉及到公钥加密，私钥解密的过程，而该过程中，当服务端选择使用诸如<code>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</code>等算法进行加密时，需要使用到<a href=\"http://baike.baidu.com/link?url=bXqyg5o-fpDYcqQ753nR659lJcU9TTxS9dP2SDxUVSHS_b0BURjiMAkBsQbocBDX9OMb0gosZHgsT9_Hlszt-q\">Diffie-Hellman</a>算法进行加密解密，通过阅读Diffie-Hellman算法的介绍，发现在加密解密计算过程中，会使用到两个参数，一个是q，一个是a，而在JDK8之前，服务器端提供的q参数只是用了768bit的长度，而不足1024bit则存在相应的安全漏洞，会被替换后的BroingSSL拒绝，因此出现了Handshake failed错误。</p>\n<p>终于找到问题所在了,总结这个纠结的过程，我只想说：一定要认真看Log！！！</p>\n<h3 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h3><p>通过阅读上边提到的大神写的帖子，发现两种可以解决的办法：</p>\n<ol>\n<li><p>升级JDK到8(条件限制，未经过测试)</p>\n</li>\n<li><p>配置Tomcat服务器，限制加密方式：</p>\n<p> 修改Tomcat服务器conf&#x2F;server.xml文件中和Https有关的Connector节点，添加ciphers用于指定密钥：</p>\n<pre><code> &lt;Connector \n     SSLEnabled=&quot;true&quot; \n     clientAuth=&quot;false&quot; \n     connectionTimeout=&quot;20000&quot; \n     keystoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot; \n     keystorePass=&quot;xinwei&quot; \n     maxThreads=&quot;150&quot; \n     port=&quot;443&quot; \n     protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; \n     redirectPort=&quot;8443&quot; \n     scheme=&quot;https&quot; \n     secure=&quot;true&quot; \n     ciphers=&quot;TLS_RSA_WITH_AES_128_CBC_SHA256,\n       TLS_RSA_WITH_AES_128_CBC_SHA,\n       TLS_RSA_WITH_AES_256_CBC_SHA256,\n       TLS_RSA_WITH_AES_256_CBC_SHA,\n       SSL_RSA_WITH_3DES_EDE_CBC_SHA&quot;\n     sslProtocol=&quot;TLS&quot; \n     truststoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot; \n     truststorePass=&quot;密码&quot;\n /&gt;\n</code></pre>\n</li>\n</ol>\n<p>添加完该配置后，重启，测试，Android6.0版本没有再发现Handshake failed错误。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>这篇文章主要是记录了我解决该问题的过程和方法，没什么特别多的原创。主要是在原文作者的基础上，更深入的解释了一下出现该错误的原因。</p>\n<p>同时也因为我的疏忽，浪费了大量时间，引以为戒。</p>\n"},{"title":"Android下使用Protobuf进行序列化","date":"2016-03-31T10:34:46.000Z","keywords":"Android , Protobuf","description":"Android下使用Protobuf进行序列化","top_img":"http://image.jucaiwy.com/image/20160331/proto_google.jpg","cover":"http://image.jucaiwy.com/image/20160331/proto_google.jpg","_content":"\n\nProtocol Buffer是Google发起的，一个语言无关、平台无关的序列化/反序列化结构化数据的通用机制（框架），可用于通信协议，数据存储等。\n\n\n近期在做一柬埔寨的小项目，上线后在运行过程中，总是有用户反映应用在网络请求时，速度较慢，影响用户体验。对该问题结合使用环境及代码进行分析，发现存在以下问题：\n\n1. App中使用Json进行数据传输，存在很多冗余字段的传输，而且经过查阅资料，Json对数据进行序列化以后，数据包仍然很大。\n2. 柬埔寨存在网络信号问题，很多情况下，信号较差，大数据包的传输存在压力\n\n综合来说，网络环境不稳定和传输数据包过大应该是导致网络请求过程中吃力、或者是超时的主要原因，因此，在优化时，主要考虑如何压缩传输过程中数据包。\n\n\n### 1. 什么是Protobuf\n\nprotobuf，全称：Google Protocol Buffer，是Google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据的串行化，也称作序列化，主要用于数据存储或是RPC数据交换，支持多语言，可拓展\n\n\n### 2. 项目主页\n\nprotobuf主页：   [主页地址](https://developers.google.com/protocol-buffers/)\n\nprotobuf下载(Java)：\t [下载地址](https://developers.google.com/protocol-buffers/docs/downloads#release-packages)\n\nprotobuf Github：   [Git地址](https://github.com/google/protobuf)\n\n### 3. 使用\n因为Android环境下使用Java语言进行开发，因此我们选择Java版本进行下载。\n\n首先需要到Protobuf主页上下载最新的源码包：[下载地址](https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz)\n\n或者是下载Google打包好的Windows下可执行文件：[下载地址](https://github.com/google/protobuf/releases/download/v2.6.1/protoc-2.6.1-win32.zip)\n\n#### 3.1 源码编译\n\n首先，在Eclipse中开发，需要引入protobuf需要的Jar包，而官方只给出了相应源码，因此需要自己进行编译。编译方法如下：\n\n1. 安装Maven环境，具体安装过程，参考网上：[连接](http://jingyan.baidu.com/article/295430f136e8e00c7e0050b9.html)\n2. 安装好Maven后，需要进行编译，才能生成需要引入的Jar文件，具体操作为：首先将下载好的protoc.exe文件复制到\\protobuf-2.6.1\\src目录下。然后进入protobuf-2.6.1\\java目录下，直接运行命令：\n\t\n```bash\nmvn install\n```\n如下：\n\n ![](http://image.jucaiwy.com/image/20160331/D14jNhV.png)\n\n\t编译完成后，会在\\protobuf-2.6.1\\java\\target\\目录下生成文件：protobuf-java-2.6.1.jar。可以直接导入Eclipse中进行使用\n\n#### 3.2 构建对象\n即定义数据模型，需要新建一个文件，后缀名为.proto,例如，我需要生成对象如下：\n\t\n\tpublic class ProductInfo\n\t{\n\t\tprivate String productID;\n\t\t\n\t\tprivate String productName;\n\t\t\n\t\tprivate String productAmount;\n\t\t\n\t\tprivate String productDate;\n\t\t\n\t\tprivate String productMessage;\n\t}\n\n\n需要按照以下步骤进行\n\n1. 新建文件，名为：ProductInfo.proto\n2. 使用UE或者NotePad++等编辑软件打开该文件，对需要录入的字段进行编辑，如下(UE直接写出来，太难排版了，只能上图)\n\n\t![](http://image.jucaiwy.com/image/20160331/7hiJIcM.png)\n\t\n说明：该文件中：\n\n- java_package：包名\n- java_outer_classname：类名\n- ProductInfo：对象名\t\n- required：必须有值\n- optional：可以不写值\n- string：相当于Java中的String\n- int32：相当于Java中的int\n\n具体proto文件类型、Java类型及C++类型对比如下：\n\n![](http://image.jucaiwy.com/image/20160331/hF1WG8K.png)\t\n\n具体还可以参考连接： [ Protobuf语言指南](http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html)\n\n3. 使用protoc进行编译，语句为：\n\n\t**protoc --java_out=E:\\Android开源项目\\Protobuf数据传输协议\\protobuf ProductInfo.proto**\n\n注：\n\t\n\n- protoc：指使用下载好的protoc.exe进行编译\n\n- java_out:编译器编译时，生成的语言同样的参数也可以是cpp_out\n\n- \"=\" 后边内容为需要编译的文件路径和文件名\n\n\t编译完成后，会在编译文件位置相同的路径下，生成编译完成的文件，Java的以包的形式存放，即以文件夹的形式存放。\n\n至此，已经完成了Jar包的编译和需要传输的对象的编译，接下来举例说明如何进行使用。\n\n#### 3.3 在Java中使用\n\n新建Android工程，将生成的Jar文件拷贝到工程目录下的libs文件夹里边，将生成的模型文件拷贝到工程中对应的包下边，可以进行创建和使用对象：\n\n示例代码：\n\n```java\nprivate void testProto() {\n    ProductInfo.Product.Builder builder = ProductInfo.Product.newBuilder();\n    builder.setAmount(\"100\");\n    builder.setUid(10010);\n    builder.setProductCode(\"Product1\");\n    builder.setLuckNum(\"12345\");\n    builder.setAllPhoneNum(\"10086\");\n\n    // 生成product对象\n    ProductInfo.Product product = builder.build();\n\n    // 转换为Byte\n    byte[] products = product.toByteArray();\n\n    // 反解\n    try {\n         Product productParse = ProductInfo.Product.parseFrom(products);\n    } catch (InvalidProtocolBufferException e) {\n         e.printStackTrace();\n    }\n}\n```\n","source":"_posts/20160331Android下使用Protobuf进行序列化.md","raw":"---\n\ntitle: Android下使用Protobuf进行序列化\n\ndate: 2016-03-31 18:34:46\n\ntags: [ Android , Protobuf]\n\ncategories: Android\n\nkeywords: Android , Protobuf\n\ndescription: Android下使用Protobuf进行序列化\n\ntop_img: http://image.jucaiwy.com/image/20160331/proto_google.jpg\n\ncover: http://image.jucaiwy.com/image/20160331/proto_google.jpg\n\n---\n\n\nProtocol Buffer是Google发起的，一个语言无关、平台无关的序列化/反序列化结构化数据的通用机制（框架），可用于通信协议，数据存储等。\n\n\n近期在做一柬埔寨的小项目，上线后在运行过程中，总是有用户反映应用在网络请求时，速度较慢，影响用户体验。对该问题结合使用环境及代码进行分析，发现存在以下问题：\n\n1. App中使用Json进行数据传输，存在很多冗余字段的传输，而且经过查阅资料，Json对数据进行序列化以后，数据包仍然很大。\n2. 柬埔寨存在网络信号问题，很多情况下，信号较差，大数据包的传输存在压力\n\n综合来说，网络环境不稳定和传输数据包过大应该是导致网络请求过程中吃力、或者是超时的主要原因，因此，在优化时，主要考虑如何压缩传输过程中数据包。\n\n\n### 1. 什么是Protobuf\n\nprotobuf，全称：Google Protocol Buffer，是Google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据的串行化，也称作序列化，主要用于数据存储或是RPC数据交换，支持多语言，可拓展\n\n\n### 2. 项目主页\n\nprotobuf主页：   [主页地址](https://developers.google.com/protocol-buffers/)\n\nprotobuf下载(Java)：\t [下载地址](https://developers.google.com/protocol-buffers/docs/downloads#release-packages)\n\nprotobuf Github：   [Git地址](https://github.com/google/protobuf)\n\n### 3. 使用\n因为Android环境下使用Java语言进行开发，因此我们选择Java版本进行下载。\n\n首先需要到Protobuf主页上下载最新的源码包：[下载地址](https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz)\n\n或者是下载Google打包好的Windows下可执行文件：[下载地址](https://github.com/google/protobuf/releases/download/v2.6.1/protoc-2.6.1-win32.zip)\n\n#### 3.1 源码编译\n\n首先，在Eclipse中开发，需要引入protobuf需要的Jar包，而官方只给出了相应源码，因此需要自己进行编译。编译方法如下：\n\n1. 安装Maven环境，具体安装过程，参考网上：[连接](http://jingyan.baidu.com/article/295430f136e8e00c7e0050b9.html)\n2. 安装好Maven后，需要进行编译，才能生成需要引入的Jar文件，具体操作为：首先将下载好的protoc.exe文件复制到\\protobuf-2.6.1\\src目录下。然后进入protobuf-2.6.1\\java目录下，直接运行命令：\n\t\n```bash\nmvn install\n```\n如下：\n\n ![](http://image.jucaiwy.com/image/20160331/D14jNhV.png)\n\n\t编译完成后，会在\\protobuf-2.6.1\\java\\target\\目录下生成文件：protobuf-java-2.6.1.jar。可以直接导入Eclipse中进行使用\n\n#### 3.2 构建对象\n即定义数据模型，需要新建一个文件，后缀名为.proto,例如，我需要生成对象如下：\n\t\n\tpublic class ProductInfo\n\t{\n\t\tprivate String productID;\n\t\t\n\t\tprivate String productName;\n\t\t\n\t\tprivate String productAmount;\n\t\t\n\t\tprivate String productDate;\n\t\t\n\t\tprivate String productMessage;\n\t}\n\n\n需要按照以下步骤进行\n\n1. 新建文件，名为：ProductInfo.proto\n2. 使用UE或者NotePad++等编辑软件打开该文件，对需要录入的字段进行编辑，如下(UE直接写出来，太难排版了，只能上图)\n\n\t![](http://image.jucaiwy.com/image/20160331/7hiJIcM.png)\n\t\n说明：该文件中：\n\n- java_package：包名\n- java_outer_classname：类名\n- ProductInfo：对象名\t\n- required：必须有值\n- optional：可以不写值\n- string：相当于Java中的String\n- int32：相当于Java中的int\n\n具体proto文件类型、Java类型及C++类型对比如下：\n\n![](http://image.jucaiwy.com/image/20160331/hF1WG8K.png)\t\n\n具体还可以参考连接： [ Protobuf语言指南](http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html)\n\n3. 使用protoc进行编译，语句为：\n\n\t**protoc --java_out=E:\\Android开源项目\\Protobuf数据传输协议\\protobuf ProductInfo.proto**\n\n注：\n\t\n\n- protoc：指使用下载好的protoc.exe进行编译\n\n- java_out:编译器编译时，生成的语言同样的参数也可以是cpp_out\n\n- \"=\" 后边内容为需要编译的文件路径和文件名\n\n\t编译完成后，会在编译文件位置相同的路径下，生成编译完成的文件，Java的以包的形式存放，即以文件夹的形式存放。\n\n至此，已经完成了Jar包的编译和需要传输的对象的编译，接下来举例说明如何进行使用。\n\n#### 3.3 在Java中使用\n\n新建Android工程，将生成的Jar文件拷贝到工程目录下的libs文件夹里边，将生成的模型文件拷贝到工程中对应的包下边，可以进行创建和使用对象：\n\n示例代码：\n\n```java\nprivate void testProto() {\n    ProductInfo.Product.Builder builder = ProductInfo.Product.newBuilder();\n    builder.setAmount(\"100\");\n    builder.setUid(10010);\n    builder.setProductCode(\"Product1\");\n    builder.setLuckNum(\"12345\");\n    builder.setAllPhoneNum(\"10086\");\n\n    // 生成product对象\n    ProductInfo.Product product = builder.build();\n\n    // 转换为Byte\n    byte[] products = product.toByteArray();\n\n    // 反解\n    try {\n         Product productParse = ProductInfo.Product.parseFrom(products);\n    } catch (InvalidProtocolBufferException e) {\n         e.printStackTrace();\n    }\n}\n```\n","slug":"20160331Android下使用Protobuf进行序列化","published":1,"updated":"2020-12-09T06:31:31.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurq0010b3t136yrg4ur","content":"<p>Protocol Buffer是Google发起的，一个语言无关、平台无关的序列化&#x2F;反序列化结构化数据的通用机制（框架），可用于通信协议，数据存储等。</p>\n<p>近期在做一柬埔寨的小项目，上线后在运行过程中，总是有用户反映应用在网络请求时，速度较慢，影响用户体验。对该问题结合使用环境及代码进行分析，发现存在以下问题：</p>\n<ol>\n<li>App中使用Json进行数据传输，存在很多冗余字段的传输，而且经过查阅资料，Json对数据进行序列化以后，数据包仍然很大。</li>\n<li>柬埔寨存在网络信号问题，很多情况下，信号较差，大数据包的传输存在压力</li>\n</ol>\n<p>综合来说，网络环境不稳定和传输数据包过大应该是导致网络请求过程中吃力、或者是超时的主要原因，因此，在优化时，主要考虑如何压缩传输过程中数据包。</p>\n<h3 id=\"1-什么是Protobuf\"><a href=\"#1-什么是Protobuf\" class=\"headerlink\" title=\"1. 什么是Protobuf\"></a>1. 什么是Protobuf</h3><p>protobuf，全称：Google Protocol Buffer，是Google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据的串行化，也称作序列化，主要用于数据存储或是RPC数据交换，支持多语言，可拓展</p>\n<h3 id=\"2-项目主页\"><a href=\"#2-项目主页\" class=\"headerlink\" title=\"2. 项目主页\"></a>2. 项目主页</h3><p>protobuf主页：   <a href=\"https://developers.google.com/protocol-buffers/\">主页地址</a></p>\n<p>protobuf下载(Java)：\t <a href=\"https://developers.google.com/protocol-buffers/docs/downloads#release-packages\">下载地址</a></p>\n<p>protobuf Github：   <a href=\"https://github.com/google/protobuf\">Git地址</a></p>\n<h3 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h3><p>因为Android环境下使用Java语言进行开发，因此我们选择Java版本进行下载。</p>\n<p>首先需要到Protobuf主页上下载最新的源码包：<a href=\"https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz\">下载地址</a></p>\n<p>或者是下载Google打包好的Windows下可执行文件：<a href=\"https://github.com/google/protobuf/releases/download/v2.6.1/protoc-2.6.1-win32.zip\">下载地址</a></p>\n<h4 id=\"3-1-源码编译\"><a href=\"#3-1-源码编译\" class=\"headerlink\" title=\"3.1 源码编译\"></a>3.1 源码编译</h4><p>首先，在Eclipse中开发，需要引入protobuf需要的Jar包，而官方只给出了相应源码，因此需要自己进行编译。编译方法如下：</p>\n<ol>\n<li>安装Maven环境，具体安装过程，参考网上：<a href=\"http://jingyan.baidu.com/article/295430f136e8e00c7e0050b9.html\">连接</a></li>\n<li>安装好Maven后，需要进行编译，才能生成需要引入的Jar文件，具体操作为：首先将下载好的protoc.exe文件复制到\\protobuf-2.6.1\\src目录下。然后进入protobuf-2.6.1\\java目录下，直接运行命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install</span><br></pre></td></tr></table></figure>\n<p>如下：</p>\n<p> <img src=\"http://image.jucaiwy.com/image/20160331/D14jNhV.png\"></p>\n<pre><code>编译完成后，会在\\protobuf-2.6.1\\java\\target\\目录下生成文件：protobuf-java-2.6.1.jar。可以直接导入Eclipse中进行使用\n</code></pre>\n<h4 id=\"3-2-构建对象\"><a href=\"#3-2-构建对象\" class=\"headerlink\" title=\"3.2 构建对象\"></a>3.2 构建对象</h4><p>即定义数据模型，需要新建一个文件，后缀名为.proto,例如，我需要生成对象如下：</p>\n<pre><code>public class ProductInfo\n&#123;\n    private String productID;\n    \n    private String productName;\n    \n    private String productAmount;\n    \n    private String productDate;\n    \n    private String productMessage;\n&#125;\n</code></pre>\n<p>需要按照以下步骤进行</p>\n<ol>\n<li><p>新建文件，名为：ProductInfo.proto</p>\n</li>\n<li><p>使用UE或者NotePad++等编辑软件打开该文件，对需要录入的字段进行编辑，如下(UE直接写出来，太难排版了，只能上图)</p>\n<p> <img src=\"http://image.jucaiwy.com/image/20160331/7hiJIcM.png\"></p>\n</li>\n</ol>\n<p>说明：该文件中：</p>\n<ul>\n<li>java_package：包名</li>\n<li>java_outer_classname：类名</li>\n<li>ProductInfo：对象名\t</li>\n<li>required：必须有值</li>\n<li>optional：可以不写值</li>\n<li>string：相当于Java中的String</li>\n<li>int32：相当于Java中的int</li>\n</ul>\n<p>具体proto文件类型、Java类型及C++类型对比如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160331/hF1WG8K.png\">\t</p>\n<p>具体还可以参考连接： <a href=\"http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html\"> Protobuf语言指南</a></p>\n<ol start=\"3\">\n<li><p>使用protoc进行编译，语句为：</p>\n<p> <strong>protoc –java_out&#x3D;E:\\Android开源项目\\Protobuf数据传输协议\\protobuf ProductInfo.proto</strong></p>\n</li>\n</ol>\n<p>注：</p>\n<ul>\n<li><p>protoc：指使用下载好的protoc.exe进行编译</p>\n</li>\n<li><p>java_out:编译器编译时，生成的语言同样的参数也可以是cpp_out</p>\n</li>\n<li><p>“&#x3D;” 后边内容为需要编译的文件路径和文件名</p>\n<p>  编译完成后，会在编译文件位置相同的路径下，生成编译完成的文件，Java的以包的形式存放，即以文件夹的形式存放。</p>\n</li>\n</ul>\n<p>至此，已经完成了Jar包的编译和需要传输的对象的编译，接下来举例说明如何进行使用。</p>\n<h4 id=\"3-3-在Java中使用\"><a href=\"#3-3-在Java中使用\" class=\"headerlink\" title=\"3.3 在Java中使用\"></a>3.3 在Java中使用</h4><p>新建Android工程，将生成的Jar文件拷贝到工程目录下的libs文件夹里边，将生成的模型文件拷贝到工程中对应的包下边，可以进行创建和使用对象：</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testProto</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ProductInfo.Product.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> ProductInfo.Product.newBuilder();</span><br><span class=\"line\">    builder.setAmount(<span class=\"string\">&quot;100&quot;</span>);</span><br><span class=\"line\">    builder.setUid(<span class=\"number\">10010</span>);</span><br><span class=\"line\">    builder.setProductCode(<span class=\"string\">&quot;Product1&quot;</span>);</span><br><span class=\"line\">    builder.setLuckNum(<span class=\"string\">&quot;12345&quot;</span>);</span><br><span class=\"line\">    builder.setAllPhoneNum(<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成product对象</span></span><br><span class=\"line\">    ProductInfo.<span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> builder.build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换为Byte</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] products = product.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 反解</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         <span class=\"type\">Product</span> <span class=\"variable\">productParse</span> <span class=\"operator\">=</span> ProductInfo.Product.parseFrom(products);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class=\"line\">         e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Protocol Buffer是Google发起的，一个语言无关、平台无关的序列化&#x2F;反序列化结构化数据的通用机制（框架），可用于通信协议，数据存储等。</p>\n<p>近期在做一柬埔寨的小项目，上线后在运行过程中，总是有用户反映应用在网络请求时，速度较慢，影响用户体验。对该问题结合使用环境及代码进行分析，发现存在以下问题：</p>\n<ol>\n<li>App中使用Json进行数据传输，存在很多冗余字段的传输，而且经过查阅资料，Json对数据进行序列化以后，数据包仍然很大。</li>\n<li>柬埔寨存在网络信号问题，很多情况下，信号较差，大数据包的传输存在压力</li>\n</ol>\n<p>综合来说，网络环境不稳定和传输数据包过大应该是导致网络请求过程中吃力、或者是超时的主要原因，因此，在优化时，主要考虑如何压缩传输过程中数据包。</p>\n<h3 id=\"1-什么是Protobuf\"><a href=\"#1-什么是Protobuf\" class=\"headerlink\" title=\"1. 什么是Protobuf\"></a>1. 什么是Protobuf</h3><p>protobuf，全称：Google Protocol Buffer，是Google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据的串行化，也称作序列化，主要用于数据存储或是RPC数据交换，支持多语言，可拓展</p>\n<h3 id=\"2-项目主页\"><a href=\"#2-项目主页\" class=\"headerlink\" title=\"2. 项目主页\"></a>2. 项目主页</h3><p>protobuf主页：   <a href=\"https://developers.google.com/protocol-buffers/\">主页地址</a></p>\n<p>protobuf下载(Java)：\t <a href=\"https://developers.google.com/protocol-buffers/docs/downloads#release-packages\">下载地址</a></p>\n<p>protobuf Github：   <a href=\"https://github.com/google/protobuf\">Git地址</a></p>\n<h3 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h3><p>因为Android环境下使用Java语言进行开发，因此我们选择Java版本进行下载。</p>\n<p>首先需要到Protobuf主页上下载最新的源码包：<a href=\"https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz\">下载地址</a></p>\n<p>或者是下载Google打包好的Windows下可执行文件：<a href=\"https://github.com/google/protobuf/releases/download/v2.6.1/protoc-2.6.1-win32.zip\">下载地址</a></p>\n<h4 id=\"3-1-源码编译\"><a href=\"#3-1-源码编译\" class=\"headerlink\" title=\"3.1 源码编译\"></a>3.1 源码编译</h4><p>首先，在Eclipse中开发，需要引入protobuf需要的Jar包，而官方只给出了相应源码，因此需要自己进行编译。编译方法如下：</p>\n<ol>\n<li>安装Maven环境，具体安装过程，参考网上：<a href=\"http://jingyan.baidu.com/article/295430f136e8e00c7e0050b9.html\">连接</a></li>\n<li>安装好Maven后，需要进行编译，才能生成需要引入的Jar文件，具体操作为：首先将下载好的protoc.exe文件复制到\\protobuf-2.6.1\\src目录下。然后进入protobuf-2.6.1\\java目录下，直接运行命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install</span><br></pre></td></tr></table></figure>\n<p>如下：</p>\n<p> <img src=\"http://image.jucaiwy.com/image/20160331/D14jNhV.png\"></p>\n<pre><code>编译完成后，会在\\protobuf-2.6.1\\java\\target\\目录下生成文件：protobuf-java-2.6.1.jar。可以直接导入Eclipse中进行使用\n</code></pre>\n<h4 id=\"3-2-构建对象\"><a href=\"#3-2-构建对象\" class=\"headerlink\" title=\"3.2 构建对象\"></a>3.2 构建对象</h4><p>即定义数据模型，需要新建一个文件，后缀名为.proto,例如，我需要生成对象如下：</p>\n<pre><code>public class ProductInfo\n&#123;\n    private String productID;\n    \n    private String productName;\n    \n    private String productAmount;\n    \n    private String productDate;\n    \n    private String productMessage;\n&#125;\n</code></pre>\n<p>需要按照以下步骤进行</p>\n<ol>\n<li><p>新建文件，名为：ProductInfo.proto</p>\n</li>\n<li><p>使用UE或者NotePad++等编辑软件打开该文件，对需要录入的字段进行编辑，如下(UE直接写出来，太难排版了，只能上图)</p>\n<p> <img src=\"http://image.jucaiwy.com/image/20160331/7hiJIcM.png\"></p>\n</li>\n</ol>\n<p>说明：该文件中：</p>\n<ul>\n<li>java_package：包名</li>\n<li>java_outer_classname：类名</li>\n<li>ProductInfo：对象名\t</li>\n<li>required：必须有值</li>\n<li>optional：可以不写值</li>\n<li>string：相当于Java中的String</li>\n<li>int32：相当于Java中的int</li>\n</ul>\n<p>具体proto文件类型、Java类型及C++类型对比如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160331/hF1WG8K.png\">\t</p>\n<p>具体还可以参考连接： <a href=\"http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html\"> Protobuf语言指南</a></p>\n<ol start=\"3\">\n<li><p>使用protoc进行编译，语句为：</p>\n<p> <strong>protoc –java_out&#x3D;E:\\Android开源项目\\Protobuf数据传输协议\\protobuf ProductInfo.proto</strong></p>\n</li>\n</ol>\n<p>注：</p>\n<ul>\n<li><p>protoc：指使用下载好的protoc.exe进行编译</p>\n</li>\n<li><p>java_out:编译器编译时，生成的语言同样的参数也可以是cpp_out</p>\n</li>\n<li><p>“&#x3D;” 后边内容为需要编译的文件路径和文件名</p>\n<p>  编译完成后，会在编译文件位置相同的路径下，生成编译完成的文件，Java的以包的形式存放，即以文件夹的形式存放。</p>\n</li>\n</ul>\n<p>至此，已经完成了Jar包的编译和需要传输的对象的编译，接下来举例说明如何进行使用。</p>\n<h4 id=\"3-3-在Java中使用\"><a href=\"#3-3-在Java中使用\" class=\"headerlink\" title=\"3.3 在Java中使用\"></a>3.3 在Java中使用</h4><p>新建Android工程，将生成的Jar文件拷贝到工程目录下的libs文件夹里边，将生成的模型文件拷贝到工程中对应的包下边，可以进行创建和使用对象：</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testProto</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ProductInfo.Product.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> ProductInfo.Product.newBuilder();</span><br><span class=\"line\">    builder.setAmount(<span class=\"string\">&quot;100&quot;</span>);</span><br><span class=\"line\">    builder.setUid(<span class=\"number\">10010</span>);</span><br><span class=\"line\">    builder.setProductCode(<span class=\"string\">&quot;Product1&quot;</span>);</span><br><span class=\"line\">    builder.setLuckNum(<span class=\"string\">&quot;12345&quot;</span>);</span><br><span class=\"line\">    builder.setAllPhoneNum(<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成product对象</span></span><br><span class=\"line\">    ProductInfo.<span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> builder.build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换为Byte</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] products = product.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 反解</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         <span class=\"type\">Product</span> <span class=\"variable\">productParse</span> <span class=\"operator\">=</span> ProductInfo.Product.parseFrom(products);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class=\"line\">         e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates","date":"2016-04-22T10:34:46.000Z","keywords":"Android , Eclipse","description":"在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates","top_img":"http://image.jucaiwy.com/image/20160422/AndroidStudio.jpeg","cover":"http://image.jucaiwy.com/image/20160422/AndroidStudio.jpeg","_content":"\n换Eclipse为AndroidStudio后，需要将之前Eclipse中的CodeStyle和Formatter导入AndroidStudio中使用。具体操作步骤如下：\n\n### 导入Formatter\n\n想要在AndroidStudio中使用Eclipse风格的Formatter，首先需要安装插件：\n\n1. 点击File——>Setting\n\n![](http://i.imgur.com/7hxJGk8.png)\n\n\n2. 在打开的Setting界面中，点击Plugins，然后在搜索框中输入Eclipse Code Formatter，搜索结果中点击安装（因为我之前已经安装过了，所以这里只显示Uninstall）\n\n![](http://i.imgur.com/yhdJ8iy.png)\n\n3. 安装完毕后，再次打开File——>Setting，会出现Eclipse Code Formatter 选项，一般在OtherSetting中，若没有可以使用上边的搜索框进行搜索。\n4. 打开后，选择 Use the Eclipse code formatter 然后在下边的Eclipse Java Formatter config file中设置自己Formatter的文件路径，然后点击Apply，即可生效。\n\n![](http://i.imgur.com/tL8oWxu.png)\n\n\n5. 配置完成后，需要进行激活才能使用Eclipse的Formatter，如图，将该图标切换至Eclipse图标，即表示当前使用Eclipse进行Formatter。且每一次Formatter，均会打印一条Log\n\n![](http://i.imgur.com/j3Xu95R.png)\n\n\n\n### 使用CodeTemplates\n\n找了半天，都没有找到直接导入Eclipse下CodeTemplates文件的方法，所以，只能自己动手去写了，现在只是找到了，如何为新建的java类添加注释，其余方法，愿大家共同探讨。\n\n![](http://i.imgur.com/khPnucm.png)\n\n这里，需要说明一下，不知道是不是我打开的方式不对，这里添加CopyRight后，需要每一次都Generate一下，才会在文件中生成，不知道有没有自动Generate的，这样就不需要添加HeadFile了\n\n\n### 直接导入\n\n除了上述两个方法之外，当然也可以直接导入我自己已经配置好的配置文件，文件会在附件中出现，如图，进行导入\n\n\n![](http://i.imgur.com/dVHhUKU.png)\n\n\n\n\n当然导入时，可以不选择UI之类的东西，因为个人喜好么。\n\n","source":"_posts/20160422AndroidStudio中使用Eclipse配置.md","raw":"---\n\ntitle: 在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates\n\ndate: 2016-04-22 18:34:46\n\ntags: [ Android , Eclipse]\n\ncategories: Android\n\nkeywords: Android , Eclipse\n\ndescription: 在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates\n\ntop_img: http://image.jucaiwy.com/image/20160422/AndroidStudio.jpeg\n\ncover: http://image.jucaiwy.com/image/20160422/AndroidStudio.jpeg\n\n---\n\n换Eclipse为AndroidStudio后，需要将之前Eclipse中的CodeStyle和Formatter导入AndroidStudio中使用。具体操作步骤如下：\n\n### 导入Formatter\n\n想要在AndroidStudio中使用Eclipse风格的Formatter，首先需要安装插件：\n\n1. 点击File——>Setting\n\n![](http://i.imgur.com/7hxJGk8.png)\n\n\n2. 在打开的Setting界面中，点击Plugins，然后在搜索框中输入Eclipse Code Formatter，搜索结果中点击安装（因为我之前已经安装过了，所以这里只显示Uninstall）\n\n![](http://i.imgur.com/yhdJ8iy.png)\n\n3. 安装完毕后，再次打开File——>Setting，会出现Eclipse Code Formatter 选项，一般在OtherSetting中，若没有可以使用上边的搜索框进行搜索。\n4. 打开后，选择 Use the Eclipse code formatter 然后在下边的Eclipse Java Formatter config file中设置自己Formatter的文件路径，然后点击Apply，即可生效。\n\n![](http://i.imgur.com/tL8oWxu.png)\n\n\n5. 配置完成后，需要进行激活才能使用Eclipse的Formatter，如图，将该图标切换至Eclipse图标，即表示当前使用Eclipse进行Formatter。且每一次Formatter，均会打印一条Log\n\n![](http://i.imgur.com/j3Xu95R.png)\n\n\n\n### 使用CodeTemplates\n\n找了半天，都没有找到直接导入Eclipse下CodeTemplates文件的方法，所以，只能自己动手去写了，现在只是找到了，如何为新建的java类添加注释，其余方法，愿大家共同探讨。\n\n![](http://i.imgur.com/khPnucm.png)\n\n这里，需要说明一下，不知道是不是我打开的方式不对，这里添加CopyRight后，需要每一次都Generate一下，才会在文件中生成，不知道有没有自动Generate的，这样就不需要添加HeadFile了\n\n\n### 直接导入\n\n除了上述两个方法之外，当然也可以直接导入我自己已经配置好的配置文件，文件会在附件中出现，如图，进行导入\n\n\n![](http://i.imgur.com/dVHhUKU.png)\n\n\n\n\n当然导入时，可以不选择UI之类的东西，因为个人喜好么。\n\n","slug":"20160422AndroidStudio中使用Eclipse配置","published":1,"updated":"2020-12-09T06:31:57.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurr0014b3t1ethsfjqp","content":"<p>换Eclipse为AndroidStudio后，需要将之前Eclipse中的CodeStyle和Formatter导入AndroidStudio中使用。具体操作步骤如下：</p>\n<h3 id=\"导入Formatter\"><a href=\"#导入Formatter\" class=\"headerlink\" title=\"导入Formatter\"></a>导入Formatter</h3><p>想要在AndroidStudio中使用Eclipse风格的Formatter，首先需要安装插件：</p>\n<ol>\n<li>点击File——&gt;Setting</li>\n</ol>\n<p><img src=\"http://i.imgur.com/7hxJGk8.png\"></p>\n<ol start=\"2\">\n<li>在打开的Setting界面中，点击Plugins，然后在搜索框中输入Eclipse Code Formatter，搜索结果中点击安装（因为我之前已经安装过了，所以这里只显示Uninstall）</li>\n</ol>\n<p><img src=\"http://i.imgur.com/yhdJ8iy.png\"></p>\n<ol start=\"3\">\n<li>安装完毕后，再次打开File——&gt;Setting，会出现Eclipse Code Formatter 选项，一般在OtherSetting中，若没有可以使用上边的搜索框进行搜索。</li>\n<li>打开后，选择 Use the Eclipse code formatter 然后在下边的Eclipse Java Formatter config file中设置自己Formatter的文件路径，然后点击Apply，即可生效。</li>\n</ol>\n<p><img src=\"http://i.imgur.com/tL8oWxu.png\"></p>\n<ol start=\"5\">\n<li>配置完成后，需要进行激活才能使用Eclipse的Formatter，如图，将该图标切换至Eclipse图标，即表示当前使用Eclipse进行Formatter。且每一次Formatter，均会打印一条Log</li>\n</ol>\n<p><img src=\"http://i.imgur.com/j3Xu95R.png\"></p>\n<h3 id=\"使用CodeTemplates\"><a href=\"#使用CodeTemplates\" class=\"headerlink\" title=\"使用CodeTemplates\"></a>使用CodeTemplates</h3><p>找了半天，都没有找到直接导入Eclipse下CodeTemplates文件的方法，所以，只能自己动手去写了，现在只是找到了，如何为新建的java类添加注释，其余方法，愿大家共同探讨。</p>\n<p><img src=\"http://i.imgur.com/khPnucm.png\"></p>\n<p>这里，需要说明一下，不知道是不是我打开的方式不对，这里添加CopyRight后，需要每一次都Generate一下，才会在文件中生成，不知道有没有自动Generate的，这样就不需要添加HeadFile了</p>\n<h3 id=\"直接导入\"><a href=\"#直接导入\" class=\"headerlink\" title=\"直接导入\"></a>直接导入</h3><p>除了上述两个方法之外，当然也可以直接导入我自己已经配置好的配置文件，文件会在附件中出现，如图，进行导入</p>\n<p><img src=\"http://i.imgur.com/dVHhUKU.png\"></p>\n<p>当然导入时，可以不选择UI之类的东西，因为个人喜好么。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>换Eclipse为AndroidStudio后，需要将之前Eclipse中的CodeStyle和Formatter导入AndroidStudio中使用。具体操作步骤如下：</p>\n<h3 id=\"导入Formatter\"><a href=\"#导入Formatter\" class=\"headerlink\" title=\"导入Formatter\"></a>导入Formatter</h3><p>想要在AndroidStudio中使用Eclipse风格的Formatter，首先需要安装插件：</p>\n<ol>\n<li>点击File——&gt;Setting</li>\n</ol>\n<p><img src=\"http://i.imgur.com/7hxJGk8.png\"></p>\n<ol start=\"2\">\n<li>在打开的Setting界面中，点击Plugins，然后在搜索框中输入Eclipse Code Formatter，搜索结果中点击安装（因为我之前已经安装过了，所以这里只显示Uninstall）</li>\n</ol>\n<p><img src=\"http://i.imgur.com/yhdJ8iy.png\"></p>\n<ol start=\"3\">\n<li>安装完毕后，再次打开File——&gt;Setting，会出现Eclipse Code Formatter 选项，一般在OtherSetting中，若没有可以使用上边的搜索框进行搜索。</li>\n<li>打开后，选择 Use the Eclipse code formatter 然后在下边的Eclipse Java Formatter config file中设置自己Formatter的文件路径，然后点击Apply，即可生效。</li>\n</ol>\n<p><img src=\"http://i.imgur.com/tL8oWxu.png\"></p>\n<ol start=\"5\">\n<li>配置完成后，需要进行激活才能使用Eclipse的Formatter，如图，将该图标切换至Eclipse图标，即表示当前使用Eclipse进行Formatter。且每一次Formatter，均会打印一条Log</li>\n</ol>\n<p><img src=\"http://i.imgur.com/j3Xu95R.png\"></p>\n<h3 id=\"使用CodeTemplates\"><a href=\"#使用CodeTemplates\" class=\"headerlink\" title=\"使用CodeTemplates\"></a>使用CodeTemplates</h3><p>找了半天，都没有找到直接导入Eclipse下CodeTemplates文件的方法，所以，只能自己动手去写了，现在只是找到了，如何为新建的java类添加注释，其余方法，愿大家共同探讨。</p>\n<p><img src=\"http://i.imgur.com/khPnucm.png\"></p>\n<p>这里，需要说明一下，不知道是不是我打开的方式不对，这里添加CopyRight后，需要每一次都Generate一下，才会在文件中生成，不知道有没有自动Generate的，这样就不需要添加HeadFile了</p>\n<h3 id=\"直接导入\"><a href=\"#直接导入\" class=\"headerlink\" title=\"直接导入\"></a>直接导入</h3><p>除了上述两个方法之外，当然也可以直接导入我自己已经配置好的配置文件，文件会在附件中出现，如图，进行导入</p>\n<p><img src=\"http://i.imgur.com/dVHhUKU.png\"></p>\n<p>当然导入时，可以不选择UI之类的东西，因为个人喜好么。</p>\n"},{"title":"Android使用CRC校验","date":"2016-04-29T10:34:46.000Z","keywords":"Android , CRC","description":"Android使用CRC校验","top_img":"http://image.jucaiwy.com/image/20160429/crc.jpeg","cover":"http://image.jucaiwy.com/image/20160429/crc.jpeg","_content":"\n\n最近手头的一个项目，客户端和服务端之间进行通讯时，由于受到当地网络等问题的限制，使用Json传输，数据内容过于庞大，需要对该信息进行压缩，以便实现快速传输。这里使用Byte数组进行传输，前后台对协议进行商定，而后编码、传输、解码实现通信，传输过程中，为保证传输内容的完整性，需要使用CRC进行校验。\n\n\n### CRC概念——百度百科\nCRC即循环冗余校验码（Cyclic Redundancy Check[1]  ）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。\n\n\n### CRC编码\n\n编码：根据传输内容逐位计算，得到CRC编码，附加在该Byte数组后边。 \n\n```java\n\t/**\n     * 为Byte数组添加两位CRC校验\n     *\n     * @param buf\n     * @return\n     */\n    public static byte[] setParamCRC(byte[] buf) {\n        int MASK = 0x0001, CRCSEED = 0x0810;\n        int remain = 0;\n\n        byte val;\n        for (int i = 0; i < buf.length; i++) {\n            val = buf[i];\n            for (int j = 0; j < 8; j++) {\n                if (((val ^ remain) & MASK) != 0) {\n                    remain ^= CRCSEED;\n                    remain >>= 1;\n                    remain |= 0x8000;\n                } else {\n                    remain >>= 1;\n                }\n                val >>= 1;\n            }\n        }\n\n        byte[] crcByte = new byte[2];\n        crcByte[0] = (byte) ((remain >> 8) & 0xff);\n        crcByte[1] = (byte) (remain & 0xff);\n\n        // 将新生成的byte数组添加到原数据结尾并返回\n        return concatAll(buf, crcByte);\n    }\n\n```\n\n\n### CRC解码\n\n在服务端接受到客户端传输过来的byte数组，然后先进行CRC校验，通过后，才能确定数据在传输过程中未发生改变，才能进行下一步业务操作。\n\n```java\n    /***\n\t * CRC校验是否通过\n\t * \n\t * @param srcByte\n\t * @param length\n\t * @return\n\t */\n\tpublic static boolean isPassCRC(byte[] srcByte, int length)\n\t{\n\t\t// 取出除crc校验位的其他数组，进行计算，得到CRC校验结果\n\t\tint calcCRC = calcCRC(srcByte, 0, srcByte.length - length);\n\t\t\n\t\t// 取出CRC校验位，进行计算\n\t\tint receive = toInt(getBytesByindex(srcByte, srcByte.length - length, srcByte.length - 1));\n\t\t\n\t\t// 比较\n\t\treturn calcCRC == receive;\n\t}\n\t\n```\n\n在这中间  计算CRC的方法和之前的基本是一致的。只是第二步中，取到两位CRC校验值以后，将其转为int，然后进行比较\n\n\n### Demo\n\n这里有一个我写的CRC校验的Demo，没有使用jar包，可以进行修改。\n\n[CRC校验Demo](http://download.csdn.net/detail/duanbokan/9506690)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/20160429Android开发中使用CRC校验.md","raw":"---\n\ntitle: Android使用CRC校验\n\ndate: 2016-04-29 18:34:46\n\ntags: [ Android , CRC]\n\ncategories: Android\n\nkeywords: Android , CRC\n\ndescription: Android使用CRC校验\n\ntop_img: http://image.jucaiwy.com/image/20160429/crc.jpeg\n\ncover: http://image.jucaiwy.com/image/20160429/crc.jpeg\n\n---\n\n\n最近手头的一个项目，客户端和服务端之间进行通讯时，由于受到当地网络等问题的限制，使用Json传输，数据内容过于庞大，需要对该信息进行压缩，以便实现快速传输。这里使用Byte数组进行传输，前后台对协议进行商定，而后编码、传输、解码实现通信，传输过程中，为保证传输内容的完整性，需要使用CRC进行校验。\n\n\n### CRC概念——百度百科\nCRC即循环冗余校验码（Cyclic Redundancy Check[1]  ）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。\n\n\n### CRC编码\n\n编码：根据传输内容逐位计算，得到CRC编码，附加在该Byte数组后边。 \n\n```java\n\t/**\n     * 为Byte数组添加两位CRC校验\n     *\n     * @param buf\n     * @return\n     */\n    public static byte[] setParamCRC(byte[] buf) {\n        int MASK = 0x0001, CRCSEED = 0x0810;\n        int remain = 0;\n\n        byte val;\n        for (int i = 0; i < buf.length; i++) {\n            val = buf[i];\n            for (int j = 0; j < 8; j++) {\n                if (((val ^ remain) & MASK) != 0) {\n                    remain ^= CRCSEED;\n                    remain >>= 1;\n                    remain |= 0x8000;\n                } else {\n                    remain >>= 1;\n                }\n                val >>= 1;\n            }\n        }\n\n        byte[] crcByte = new byte[2];\n        crcByte[0] = (byte) ((remain >> 8) & 0xff);\n        crcByte[1] = (byte) (remain & 0xff);\n\n        // 将新生成的byte数组添加到原数据结尾并返回\n        return concatAll(buf, crcByte);\n    }\n\n```\n\n\n### CRC解码\n\n在服务端接受到客户端传输过来的byte数组，然后先进行CRC校验，通过后，才能确定数据在传输过程中未发生改变，才能进行下一步业务操作。\n\n```java\n    /***\n\t * CRC校验是否通过\n\t * \n\t * @param srcByte\n\t * @param length\n\t * @return\n\t */\n\tpublic static boolean isPassCRC(byte[] srcByte, int length)\n\t{\n\t\t// 取出除crc校验位的其他数组，进行计算，得到CRC校验结果\n\t\tint calcCRC = calcCRC(srcByte, 0, srcByte.length - length);\n\t\t\n\t\t// 取出CRC校验位，进行计算\n\t\tint receive = toInt(getBytesByindex(srcByte, srcByte.length - length, srcByte.length - 1));\n\t\t\n\t\t// 比较\n\t\treturn calcCRC == receive;\n\t}\n\t\n```\n\n在这中间  计算CRC的方法和之前的基本是一致的。只是第二步中，取到两位CRC校验值以后，将其转为int，然后进行比较\n\n\n### Demo\n\n这里有一个我写的CRC校验的Demo，没有使用jar包，可以进行修改。\n\n[CRC校验Demo](http://download.csdn.net/detail/duanbokan/9506690)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"20160429Android开发中使用CRC校验","published":1,"updated":"2020-12-09T06:32:16.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurs0017b3t16sly86sy","content":"<p>最近手头的一个项目，客户端和服务端之间进行通讯时，由于受到当地网络等问题的限制，使用Json传输，数据内容过于庞大，需要对该信息进行压缩，以便实现快速传输。这里使用Byte数组进行传输，前后台对协议进行商定，而后编码、传输、解码实现通信，传输过程中，为保证传输内容的完整性，需要使用CRC进行校验。</p>\n<h3 id=\"CRC概念——百度百科\"><a href=\"#CRC概念——百度百科\" class=\"headerlink\" title=\"CRC概念——百度百科\"></a>CRC概念——百度百科</h3><p>CRC即循环冗余校验码（Cyclic Redundancy Check[1]  ）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>\n<h3 id=\"CRC编码\"><a href=\"#CRC编码\" class=\"headerlink\" title=\"CRC编码\"></a>CRC编码</h3><p>编码：根据传输内容逐位计算，得到CRC编码，附加在该Byte数组后边。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 为Byte数组添加两位CRC校验</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> buf</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">byte</span>[] setParamCRC(<span class=\"type\">byte</span>[] buf) &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">MASK</span> <span class=\"operator\">=</span> <span class=\"number\">0x0001</span>, CRCSEED = <span class=\"number\">0x0810</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">remain</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">byte</span> val;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class=\"line\">           val = buf[i];</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (((val ^ remain) &amp; MASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   remain ^= CRCSEED;</span><br><span class=\"line\">                   remain &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">                   remain |= <span class=\"number\">0x8000</span>;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   remain &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               val &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">byte</span>[] crcByte = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">       crcByte[<span class=\"number\">0</span>] = (<span class=\"type\">byte</span>) ((remain &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</span><br><span class=\"line\">       crcByte[<span class=\"number\">1</span>] = (<span class=\"type\">byte</span>) (remain &amp; <span class=\"number\">0xff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将新生成的byte数组添加到原数据结尾并返回</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> concatAll(buf, crcByte);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"CRC解码\"><a href=\"#CRC解码\" class=\"headerlink\" title=\"CRC解码\"></a>CRC解码</h3><p>在服务端接受到客户端传输过来的byte数组，然后先进行CRC校验，通过后，才能确定数据在传输过程中未发生改变，才能进行下一步业务操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * CRC校验是否通过</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcByte</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> length</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPassCRC</span><span class=\"params\">(<span class=\"type\">byte</span>[] srcByte, <span class=\"type\">int</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 取出除crc校验位的其他数组，进行计算，得到CRC校验结果</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">calcCRC</span> <span class=\"operator\">=</span> calcCRC(srcByte, <span class=\"number\">0</span>, srcByte.length - length);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 取出CRC校验位，进行计算</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">receive</span> <span class=\"operator\">=</span> toInt(getBytesByindex(srcByte, srcByte.length - length, srcByte.length - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 比较</span></span><br><span class=\"line\">\t<span class=\"type\">return</span> <span class=\"variable\">calcCRC</span> <span class=\"operator\">=</span>= receive;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这中间  计算CRC的方法和之前的基本是一致的。只是第二步中，取到两位CRC校验值以后，将其转为int，然后进行比较</p>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><p>这里有一个我写的CRC校验的Demo，没有使用jar包，可以进行修改。</p>\n<p><a href=\"http://download.csdn.net/detail/duanbokan/9506690\">CRC校验Demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近手头的一个项目，客户端和服务端之间进行通讯时，由于受到当地网络等问题的限制，使用Json传输，数据内容过于庞大，需要对该信息进行压缩，以便实现快速传输。这里使用Byte数组进行传输，前后台对协议进行商定，而后编码、传输、解码实现通信，传输过程中，为保证传输内容的完整性，需要使用CRC进行校验。</p>\n<h3 id=\"CRC概念——百度百科\"><a href=\"#CRC概念——百度百科\" class=\"headerlink\" title=\"CRC概念——百度百科\"></a>CRC概念——百度百科</h3><p>CRC即循环冗余校验码（Cyclic Redundancy Check[1]  ）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>\n<h3 id=\"CRC编码\"><a href=\"#CRC编码\" class=\"headerlink\" title=\"CRC编码\"></a>CRC编码</h3><p>编码：根据传输内容逐位计算，得到CRC编码，附加在该Byte数组后边。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 为Byte数组添加两位CRC校验</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> buf</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">byte</span>[] setParamCRC(<span class=\"type\">byte</span>[] buf) &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">MASK</span> <span class=\"operator\">=</span> <span class=\"number\">0x0001</span>, CRCSEED = <span class=\"number\">0x0810</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">remain</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">byte</span> val;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class=\"line\">           val = buf[i];</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (((val ^ remain) &amp; MASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   remain ^= CRCSEED;</span><br><span class=\"line\">                   remain &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">                   remain |= <span class=\"number\">0x8000</span>;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   remain &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               val &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">byte</span>[] crcByte = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">       crcByte[<span class=\"number\">0</span>] = (<span class=\"type\">byte</span>) ((remain &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>);</span><br><span class=\"line\">       crcByte[<span class=\"number\">1</span>] = (<span class=\"type\">byte</span>) (remain &amp; <span class=\"number\">0xff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将新生成的byte数组添加到原数据结尾并返回</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> concatAll(buf, crcByte);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"CRC解码\"><a href=\"#CRC解码\" class=\"headerlink\" title=\"CRC解码\"></a>CRC解码</h3><p>在服务端接受到客户端传输过来的byte数组，然后先进行CRC校验，通过后，才能确定数据在传输过程中未发生改变，才能进行下一步业务操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * CRC校验是否通过</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcByte</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> length</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPassCRC</span><span class=\"params\">(<span class=\"type\">byte</span>[] srcByte, <span class=\"type\">int</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 取出除crc校验位的其他数组，进行计算，得到CRC校验结果</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">calcCRC</span> <span class=\"operator\">=</span> calcCRC(srcByte, <span class=\"number\">0</span>, srcByte.length - length);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 取出CRC校验位，进行计算</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">receive</span> <span class=\"operator\">=</span> toInt(getBytesByindex(srcByte, srcByte.length - length, srcByte.length - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 比较</span></span><br><span class=\"line\">\t<span class=\"type\">return</span> <span class=\"variable\">calcCRC</span> <span class=\"operator\">=</span>= receive;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这中间  计算CRC的方法和之前的基本是一致的。只是第二步中，取到两位CRC校验值以后，将其转为int，然后进行比较</p>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><p>这里有一个我写的CRC校验的Demo，没有使用jar包，可以进行修改。</p>\n<p><a href=\"http://download.csdn.net/detail/duanbokan/9506690\">CRC校验Demo</a></p>\n"},{"title":"Android更新机制（自己服务器和GooglePlay更新）","date":"2016-05-13T10:34:46.000Z","keywords":"App更新 , Google更新","description":"Android更新机制（自己服务器和GooglePlay更新）","top_img":"http://image.jucaiwy.com/image/20160310/google_play1.jpeg","cover":"http://image.jucaiwy.com/image/20160310/google_play1.jpeg","_content":"\n\n本片文章主要介绍了自己服务器更新和GooglePlay更新的解决方案，不包含其他第三方（如Umeng、其他应用市场等）更新。之所以要区分GooglePlay更新和自己搭建服务器更新，是因为GooglePlay在13年修改其开发者中心对Dangerous Products的定义时，有提示如下文字：\n\n   ![](http://image.jucaiwy.com/image/20150513/update_title.png)\n\n即：凡是从GooglePlay中下载的应用，不得GooglePlay的更新机制，自行更改、替换、升级Apk二进制代码。因此对于在GooglePlay上线的应用，只能交由GooglePlay维护版本更新。\n\n\n这样，我们在开发过程中，若使用自己搭建服务器维护更新的，需要对自己服务器版本和GooglePlay版本进行区分。包括**打包**和**更新**区分。\n\n\n\n### 更新机制\n\n我们在自己的应用中，使用如下更新机制\n\n![](http://image.jucaiwy.com/image/20150513/update1.png)\n\n\n总的来说，自己服务器需要配置三个信息，\n\n1. 当前最新版本号\n2. 是否强制更新（不建议使用强制更新，用户体验实在太差）\n3. CooGame服务端最新版本下载地址\n\n\n检测更新步骤\n\n1. 无论GooglePlay版本还是CooGame版本，打开时均从CooGame版本请求最新版本信息，返回最新版本号和下载地址\n2. 当发现有新版本时，提示用户\n3. 用户选择更新后，CooGame版本直接从返回的下载地址中下载文件。GooglePlay则是打开GooglePlay商店，若打开失败，则启动一个WebView，打开该软件在GooglePlay上的地址。\n4. 更新完成\n\n\n### 注意\n\n在开发过程中，注意服务端的版本兼容，尽量避免出现强制更新的情况。\n\n","source":"_posts/20160513Android更新机制.md","raw":"---\n\ntitle: Android更新机制（自己服务器和GooglePlay更新）\n\ndate: 2016-05-13 18:34:46\n\ntags: [ App更新 , Google更新]\n\ncategories: Android\n\nkeywords: App更新 , Google更新\n\ndescription: Android更新机制（自己服务器和GooglePlay更新）\n\ntop_img: http://image.jucaiwy.com/image/20160310/google_play1.jpeg\n\ncover: http://image.jucaiwy.com/image/20160310/google_play1.jpeg\n\n---\n\n\n本片文章主要介绍了自己服务器更新和GooglePlay更新的解决方案，不包含其他第三方（如Umeng、其他应用市场等）更新。之所以要区分GooglePlay更新和自己搭建服务器更新，是因为GooglePlay在13年修改其开发者中心对Dangerous Products的定义时，有提示如下文字：\n\n   ![](http://image.jucaiwy.com/image/20150513/update_title.png)\n\n即：凡是从GooglePlay中下载的应用，不得GooglePlay的更新机制，自行更改、替换、升级Apk二进制代码。因此对于在GooglePlay上线的应用，只能交由GooglePlay维护版本更新。\n\n\n这样，我们在开发过程中，若使用自己搭建服务器维护更新的，需要对自己服务器版本和GooglePlay版本进行区分。包括**打包**和**更新**区分。\n\n\n\n### 更新机制\n\n我们在自己的应用中，使用如下更新机制\n\n![](http://image.jucaiwy.com/image/20150513/update1.png)\n\n\n总的来说，自己服务器需要配置三个信息，\n\n1. 当前最新版本号\n2. 是否强制更新（不建议使用强制更新，用户体验实在太差）\n3. CooGame服务端最新版本下载地址\n\n\n检测更新步骤\n\n1. 无论GooglePlay版本还是CooGame版本，打开时均从CooGame版本请求最新版本信息，返回最新版本号和下载地址\n2. 当发现有新版本时，提示用户\n3. 用户选择更新后，CooGame版本直接从返回的下载地址中下载文件。GooglePlay则是打开GooglePlay商店，若打开失败，则启动一个WebView，打开该软件在GooglePlay上的地址。\n4. 更新完成\n\n\n### 注意\n\n在开发过程中，注意服务端的版本兼容，尽量避免出现强制更新的情况。\n\n","slug":"20160513Android更新机制","published":1,"updated":"2020-12-09T06:32:43.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurs001ab3t1gzhof7wx","content":"<p>本片文章主要介绍了自己服务器更新和GooglePlay更新的解决方案，不包含其他第三方（如Umeng、其他应用市场等）更新。之所以要区分GooglePlay更新和自己搭建服务器更新，是因为GooglePlay在13年修改其开发者中心对Dangerous Products的定义时，有提示如下文字：</p>\n<p>   <img src=\"http://image.jucaiwy.com/image/20150513/update_title.png\"></p>\n<p>即：凡是从GooglePlay中下载的应用，不得GooglePlay的更新机制，自行更改、替换、升级Apk二进制代码。因此对于在GooglePlay上线的应用，只能交由GooglePlay维护版本更新。</p>\n<p>这样，我们在开发过程中，若使用自己搭建服务器维护更新的，需要对自己服务器版本和GooglePlay版本进行区分。包括<strong>打包</strong>和<strong>更新</strong>区分。</p>\n<h3 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h3><p>我们在自己的应用中，使用如下更新机制</p>\n<p><img src=\"http://image.jucaiwy.com/image/20150513/update1.png\"></p>\n<p>总的来说，自己服务器需要配置三个信息，</p>\n<ol>\n<li>当前最新版本号</li>\n<li>是否强制更新（不建议使用强制更新，用户体验实在太差）</li>\n<li>CooGame服务端最新版本下载地址</li>\n</ol>\n<p>检测更新步骤</p>\n<ol>\n<li>无论GooglePlay版本还是CooGame版本，打开时均从CooGame版本请求最新版本信息，返回最新版本号和下载地址</li>\n<li>当发现有新版本时，提示用户</li>\n<li>用户选择更新后，CooGame版本直接从返回的下载地址中下载文件。GooglePlay则是打开GooglePlay商店，若打开失败，则启动一个WebView，打开该软件在GooglePlay上的地址。</li>\n<li>更新完成</li>\n</ol>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>在开发过程中，注意服务端的版本兼容，尽量避免出现强制更新的情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本片文章主要介绍了自己服务器更新和GooglePlay更新的解决方案，不包含其他第三方（如Umeng、其他应用市场等）更新。之所以要区分GooglePlay更新和自己搭建服务器更新，是因为GooglePlay在13年修改其开发者中心对Dangerous Products的定义时，有提示如下文字：</p>\n<p>   <img src=\"http://image.jucaiwy.com/image/20150513/update_title.png\"></p>\n<p>即：凡是从GooglePlay中下载的应用，不得GooglePlay的更新机制，自行更改、替换、升级Apk二进制代码。因此对于在GooglePlay上线的应用，只能交由GooglePlay维护版本更新。</p>\n<p>这样，我们在开发过程中，若使用自己搭建服务器维护更新的，需要对自己服务器版本和GooglePlay版本进行区分。包括<strong>打包</strong>和<strong>更新</strong>区分。</p>\n<h3 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h3><p>我们在自己的应用中，使用如下更新机制</p>\n<p><img src=\"http://image.jucaiwy.com/image/20150513/update1.png\"></p>\n<p>总的来说，自己服务器需要配置三个信息，</p>\n<ol>\n<li>当前最新版本号</li>\n<li>是否强制更新（不建议使用强制更新，用户体验实在太差）</li>\n<li>CooGame服务端最新版本下载地址</li>\n</ol>\n<p>检测更新步骤</p>\n<ol>\n<li>无论GooglePlay版本还是CooGame版本，打开时均从CooGame版本请求最新版本信息，返回最新版本号和下载地址</li>\n<li>当发现有新版本时，提示用户</li>\n<li>用户选择更新后，CooGame版本直接从返回的下载地址中下载文件。GooglePlay则是打开GooglePlay商店，若打开失败，则启动一个WebView，打开该软件在GooglePlay上的地址。</li>\n<li>更新完成</li>\n</ol>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>在开发过程中，注意服务端的版本兼容，尽量避免出现强制更新的情况。</p>\n"},{"title":"Android自动化测试——Money","date":"2016-06-23T10:34:46.000Z","keywords":"Android , 自动化测试 , Monkey","description":"Android自动化测试——Money","top_img":"http://image.jucaiwy.com/image/20160623/monkey.jpeg","cover":"http://image.jucaiwy.com/image/20160623/monkey.jpeg","_content":"\n\n之前有和公司同事一起研究过Android的一些自动化测试工具，当时记得花费了大半天时间去研究怎么使用，但是却忘记整理了，趁着最近不太忙，整理下Android的自动化测试工具吧。\n\n当前最常用的Android自动化测试工具主要有以下几个：\n\n1. Monkey：    [主页地址(Google)](https://developer.android.com/studio/test/monkey.html)\n\n2. MonkeyRunner：  [主页地址(Google)](https://developer.android.com/studio/test/monkeyrunner/index.html)\n3. Robotium：    [主页地址(Git)](https://github.com/RobotiumTech/robotium)\n\n这三个中，Monkey和MonkeyRunner均在Google的开发者中心有介绍，上边也有给出连接，需要翻墙，下边将逐个进行介绍。\n\n\n\n\n### 1.Monkey\n\nMonkey是Android系统自带的测试工具，谷歌官方给出的介绍是：Monkey是一款可以运行在虚拟机或是真机上的测试程序，主要原理是通过发送一系列的伪随机流事件，模拟用户点击滑动等操作，测试应用程序的健壮性。\n\n\n#### 1.1 Monkey命令\nMonkey的使用方法比较简单，使用adb连接上客户端以后，可以直接使用Monkey命令进行测试\n\n\n![](http://image.jucaiwy.com/image/20160623/SiXKOPD.png)\n\n\n图中红线圈出来的为一些常用命令：\n\n 1. -p\t\t\t\t\t指定应用程序包名\n \n 2. --pct-touch\t\t\t指定输入touch事件所占百分比\n 3. --pct-trackball\t\t指定输入轨迹事件所占百分比\n 4. -s\t种子，生成伪随机数的Seed，两次Monkey的Seed一致时，将产生相同的随机事件\t\t\n 5. --throttle\t\t\t每一次事假与下一次事件之间的延时，单位为毫秒\n\n#### 1.2 Monkey使用方法\n\n为了更加清晰的演示Monkey的随机事件，我写了一个简单的画板，这样每一次输入，将会直观的呈现在屏幕上。画板测试代码：我是测试画板\n\n![](http://image.jucaiwy.com/image/20160623/942rGkm.png)\n\n\n上图为Monkey基本命令使用方法，分为两步：\n\n1. 使用adb shell 连接客户端\n2. 执行monkey命令\n\n其中 \n\n1. **-p** 指定我需要测试的应用的包名：com.xinwei.test.monkey 如果没有安装这个应用，也可以直接使用系统自带的计算器进行测试，更加直观。系统计算器包名:com.android.calculator2\n\n2. **--pct-motion 100** 表示输入事件中动作事件占100%\n\n3. **throttle** 延时 200毫秒，即每一次动作之间均延时200ms\n\n4. **1000** 最后一位 一千次随机事件\n\n当然，也可以不指定包名输入事件等，只需要指定随机事件个数，试试吧，有惊喜的。\n\n### 1.3 测试结果\n\n使用上述命令，测试自定义画板应用，设置输入事件全部为动作事件，结果如下：\n\n![](http://image.jucaiwy.com/image/20160623/itdOHEF.gif)\n\n\n\n\n当没有指定事件类型时，即输入事件全部为随机事件时：\n\n\n\n\n![](http://image.jucaiwy.com/image/20160623/pvaNYeI.gif)\n\n\n\n\n\n","source":"_posts/20160623Android自动化测试——Monkey.md","raw":"---\n\ntitle: Android自动化测试——Money\n\ndate: 2016-06-23 18:34:46\n\ntags: [ Android , 自动化测试 , Monkey]\n\ncategories: Android\n\nkeywords: Android , 自动化测试 , Monkey\n\ndescription: Android自动化测试——Money\n\ntop_img: http://image.jucaiwy.com/image/20160623/monkey.jpeg\n\ncover: http://image.jucaiwy.com/image/20160623/monkey.jpeg\n\n---\n\n\n之前有和公司同事一起研究过Android的一些自动化测试工具，当时记得花费了大半天时间去研究怎么使用，但是却忘记整理了，趁着最近不太忙，整理下Android的自动化测试工具吧。\n\n当前最常用的Android自动化测试工具主要有以下几个：\n\n1. Monkey：    [主页地址(Google)](https://developer.android.com/studio/test/monkey.html)\n\n2. MonkeyRunner：  [主页地址(Google)](https://developer.android.com/studio/test/monkeyrunner/index.html)\n3. Robotium：    [主页地址(Git)](https://github.com/RobotiumTech/robotium)\n\n这三个中，Monkey和MonkeyRunner均在Google的开发者中心有介绍，上边也有给出连接，需要翻墙，下边将逐个进行介绍。\n\n\n\n\n### 1.Monkey\n\nMonkey是Android系统自带的测试工具，谷歌官方给出的介绍是：Monkey是一款可以运行在虚拟机或是真机上的测试程序，主要原理是通过发送一系列的伪随机流事件，模拟用户点击滑动等操作，测试应用程序的健壮性。\n\n\n#### 1.1 Monkey命令\nMonkey的使用方法比较简单，使用adb连接上客户端以后，可以直接使用Monkey命令进行测试\n\n\n![](http://image.jucaiwy.com/image/20160623/SiXKOPD.png)\n\n\n图中红线圈出来的为一些常用命令：\n\n 1. -p\t\t\t\t\t指定应用程序包名\n \n 2. --pct-touch\t\t\t指定输入touch事件所占百分比\n 3. --pct-trackball\t\t指定输入轨迹事件所占百分比\n 4. -s\t种子，生成伪随机数的Seed，两次Monkey的Seed一致时，将产生相同的随机事件\t\t\n 5. --throttle\t\t\t每一次事假与下一次事件之间的延时，单位为毫秒\n\n#### 1.2 Monkey使用方法\n\n为了更加清晰的演示Monkey的随机事件，我写了一个简单的画板，这样每一次输入，将会直观的呈现在屏幕上。画板测试代码：我是测试画板\n\n![](http://image.jucaiwy.com/image/20160623/942rGkm.png)\n\n\n上图为Monkey基本命令使用方法，分为两步：\n\n1. 使用adb shell 连接客户端\n2. 执行monkey命令\n\n其中 \n\n1. **-p** 指定我需要测试的应用的包名：com.xinwei.test.monkey 如果没有安装这个应用，也可以直接使用系统自带的计算器进行测试，更加直观。系统计算器包名:com.android.calculator2\n\n2. **--pct-motion 100** 表示输入事件中动作事件占100%\n\n3. **throttle** 延时 200毫秒，即每一次动作之间均延时200ms\n\n4. **1000** 最后一位 一千次随机事件\n\n当然，也可以不指定包名输入事件等，只需要指定随机事件个数，试试吧，有惊喜的。\n\n### 1.3 测试结果\n\n使用上述命令，测试自定义画板应用，设置输入事件全部为动作事件，结果如下：\n\n![](http://image.jucaiwy.com/image/20160623/itdOHEF.gif)\n\n\n\n\n当没有指定事件类型时，即输入事件全部为随机事件时：\n\n\n\n\n![](http://image.jucaiwy.com/image/20160623/pvaNYeI.gif)\n\n\n\n\n\n","slug":"20160623Android自动化测试——Monkey","published":1,"updated":"2020-12-09T06:33:20.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurt001cb3t1339f4usa","content":"<p>之前有和公司同事一起研究过Android的一些自动化测试工具，当时记得花费了大半天时间去研究怎么使用，但是却忘记整理了，趁着最近不太忙，整理下Android的自动化测试工具吧。</p>\n<p>当前最常用的Android自动化测试工具主要有以下几个：</p>\n<ol>\n<li><p>Monkey：    <a href=\"https://developer.android.com/studio/test/monkey.html\">主页地址(Google)</a></p>\n</li>\n<li><p>MonkeyRunner：  <a href=\"https://developer.android.com/studio/test/monkeyrunner/index.html\">主页地址(Google)</a></p>\n</li>\n<li><p>Robotium：    <a href=\"https://github.com/RobotiumTech/robotium\">主页地址(Git)</a></p>\n</li>\n</ol>\n<p>这三个中，Monkey和MonkeyRunner均在Google的开发者中心有介绍，上边也有给出连接，需要翻墙，下边将逐个进行介绍。</p>\n<h3 id=\"1-Monkey\"><a href=\"#1-Monkey\" class=\"headerlink\" title=\"1.Monkey\"></a>1.Monkey</h3><p>Monkey是Android系统自带的测试工具，谷歌官方给出的介绍是：Monkey是一款可以运行在虚拟机或是真机上的测试程序，主要原理是通过发送一系列的伪随机流事件，模拟用户点击滑动等操作，测试应用程序的健壮性。</p>\n<h4 id=\"1-1-Monkey命令\"><a href=\"#1-1-Monkey命令\" class=\"headerlink\" title=\"1.1 Monkey命令\"></a>1.1 Monkey命令</h4><p>Monkey的使用方法比较简单，使用adb连接上客户端以后，可以直接使用Monkey命令进行测试</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/SiXKOPD.png\"></p>\n<p>图中红线圈出来的为一些常用命令：</p>\n<ol>\n<li><p>-p\t\t\t\t\t指定应用程序包名</p>\n</li>\n<li><p>–pct-touch\t\t\t指定输入touch事件所占百分比</p>\n</li>\n<li><p>–pct-trackball\t\t指定输入轨迹事件所占百分比</p>\n</li>\n<li><p>-s\t种子，生成伪随机数的Seed，两次Monkey的Seed一致时，将产生相同的随机事件\t\t</p>\n</li>\n<li><p>–throttle\t\t\t每一次事假与下一次事件之间的延时，单位为毫秒</p>\n</li>\n</ol>\n<h4 id=\"1-2-Monkey使用方法\"><a href=\"#1-2-Monkey使用方法\" class=\"headerlink\" title=\"1.2 Monkey使用方法\"></a>1.2 Monkey使用方法</h4><p>为了更加清晰的演示Monkey的随机事件，我写了一个简单的画板，这样每一次输入，将会直观的呈现在屏幕上。画板测试代码：我是测试画板</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/942rGkm.png\"></p>\n<p>上图为Monkey基本命令使用方法，分为两步：</p>\n<ol>\n<li>使用adb shell 连接客户端</li>\n<li>执行monkey命令</li>\n</ol>\n<p>其中 </p>\n<ol>\n<li><p><strong>-p</strong> 指定我需要测试的应用的包名：com.xinwei.test.monkey 如果没有安装这个应用，也可以直接使用系统自带的计算器进行测试，更加直观。系统计算器包名:com.android.calculator2</p>\n</li>\n<li><p><strong>–pct-motion 100</strong> 表示输入事件中动作事件占100%</p>\n</li>\n<li><p><strong>throttle</strong> 延时 200毫秒，即每一次动作之间均延时200ms</p>\n</li>\n<li><p><strong>1000</strong> 最后一位 一千次随机事件</p>\n</li>\n</ol>\n<p>当然，也可以不指定包名输入事件等，只需要指定随机事件个数，试试吧，有惊喜的。</p>\n<h3 id=\"1-3-测试结果\"><a href=\"#1-3-测试结果\" class=\"headerlink\" title=\"1.3 测试结果\"></a>1.3 测试结果</h3><p>使用上述命令，测试自定义画板应用，设置输入事件全部为动作事件，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/itdOHEF.gif\"></p>\n<p>当没有指定事件类型时，即输入事件全部为随机事件时：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/pvaNYeI.gif\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前有和公司同事一起研究过Android的一些自动化测试工具，当时记得花费了大半天时间去研究怎么使用，但是却忘记整理了，趁着最近不太忙，整理下Android的自动化测试工具吧。</p>\n<p>当前最常用的Android自动化测试工具主要有以下几个：</p>\n<ol>\n<li><p>Monkey：    <a href=\"https://developer.android.com/studio/test/monkey.html\">主页地址(Google)</a></p>\n</li>\n<li><p>MonkeyRunner：  <a href=\"https://developer.android.com/studio/test/monkeyrunner/index.html\">主页地址(Google)</a></p>\n</li>\n<li><p>Robotium：    <a href=\"https://github.com/RobotiumTech/robotium\">主页地址(Git)</a></p>\n</li>\n</ol>\n<p>这三个中，Monkey和MonkeyRunner均在Google的开发者中心有介绍，上边也有给出连接，需要翻墙，下边将逐个进行介绍。</p>\n<h3 id=\"1-Monkey\"><a href=\"#1-Monkey\" class=\"headerlink\" title=\"1.Monkey\"></a>1.Monkey</h3><p>Monkey是Android系统自带的测试工具，谷歌官方给出的介绍是：Monkey是一款可以运行在虚拟机或是真机上的测试程序，主要原理是通过发送一系列的伪随机流事件，模拟用户点击滑动等操作，测试应用程序的健壮性。</p>\n<h4 id=\"1-1-Monkey命令\"><a href=\"#1-1-Monkey命令\" class=\"headerlink\" title=\"1.1 Monkey命令\"></a>1.1 Monkey命令</h4><p>Monkey的使用方法比较简单，使用adb连接上客户端以后，可以直接使用Monkey命令进行测试</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/SiXKOPD.png\"></p>\n<p>图中红线圈出来的为一些常用命令：</p>\n<ol>\n<li><p>-p\t\t\t\t\t指定应用程序包名</p>\n</li>\n<li><p>–pct-touch\t\t\t指定输入touch事件所占百分比</p>\n</li>\n<li><p>–pct-trackball\t\t指定输入轨迹事件所占百分比</p>\n</li>\n<li><p>-s\t种子，生成伪随机数的Seed，两次Monkey的Seed一致时，将产生相同的随机事件\t\t</p>\n</li>\n<li><p>–throttle\t\t\t每一次事假与下一次事件之间的延时，单位为毫秒</p>\n</li>\n</ol>\n<h4 id=\"1-2-Monkey使用方法\"><a href=\"#1-2-Monkey使用方法\" class=\"headerlink\" title=\"1.2 Monkey使用方法\"></a>1.2 Monkey使用方法</h4><p>为了更加清晰的演示Monkey的随机事件，我写了一个简单的画板，这样每一次输入，将会直观的呈现在屏幕上。画板测试代码：我是测试画板</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/942rGkm.png\"></p>\n<p>上图为Monkey基本命令使用方法，分为两步：</p>\n<ol>\n<li>使用adb shell 连接客户端</li>\n<li>执行monkey命令</li>\n</ol>\n<p>其中 </p>\n<ol>\n<li><p><strong>-p</strong> 指定我需要测试的应用的包名：com.xinwei.test.monkey 如果没有安装这个应用，也可以直接使用系统自带的计算器进行测试，更加直观。系统计算器包名:com.android.calculator2</p>\n</li>\n<li><p><strong>–pct-motion 100</strong> 表示输入事件中动作事件占100%</p>\n</li>\n<li><p><strong>throttle</strong> 延时 200毫秒，即每一次动作之间均延时200ms</p>\n</li>\n<li><p><strong>1000</strong> 最后一位 一千次随机事件</p>\n</li>\n</ol>\n<p>当然，也可以不指定包名输入事件等，只需要指定随机事件个数，试试吧，有惊喜的。</p>\n<h3 id=\"1-3-测试结果\"><a href=\"#1-3-测试结果\" class=\"headerlink\" title=\"1.3 测试结果\"></a>1.3 测试结果</h3><p>使用上述命令，测试自定义画板应用，设置输入事件全部为动作事件，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/itdOHEF.gif\"></p>\n<p>当没有指定事件类型时，即输入事件全部为随机事件时：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/pvaNYeI.gif\"></p>\n"},{"title":"Android自动化测试——MoneyRunner","date":"2016-06-23T10:34:46.000Z","keywords":"Android , 自动化测试 , MonkeyRunner","description":"Android自动化测试——MoneyRunner","top_img":"http://image.jucaiwy.com/image/20160623/monkey_runner.jpeg","cover":"http://image.jucaiwy.com/image/20160623/monkey_runner.jpeg","_content":"\n\n接着上一篇文章继续写，上篇文章中，主要对[Android自动化测试——Monkey](http://blog.csdn.net/duanbokan/article/details/51742893)的概念和使用方法进行了简单介绍，，这篇文章中，我们继续探讨MonkeyRunner的使用\n\n有人之前问过我，Monkey和MonkeyRunner之间有什么区别，我用这样一个比喻来回答他，Monkey就是一只猴子，放养的猴子，未经训练的猴子，所以它在测试的时候，只会胡乱点、胡乱划(随机事件)；而MonkeyRunner则不同于Monkey，它属于家养的，经过训练的，可以按照主人的命令，做出各种动作(自定义事件)。\n\nok，下边直接讲如何使用MonkeyRunner\n\n\n### 1.1 MonkeyRunner环境搭建\n搭建MonKeyRunner环境需要以下三部分：\n\n1. Java环境，及Java环境变量配置\n\n2. Android SDK Monkey是Google提供的自动化测试工具，在SDK根路径的tools文件夹中可以找到，因此，使用MonkeyRunner需要下载安装SDK。 下载完成后，直接解压，绿色，无需安装，注意解压路径不能有中文或空格。\n\t\n\t[SDK下载路径](http://www.android-doc.com/sdk/index.html)\n\n3. 安装Python编译环境  ：Python用于支持MonkeyRunner的运行，安装Python，同时配置其环境变量。\n\n\t[Python下载路径](https://www.python.org/downloads/)\n\n检查Python和MonkeyRunner是否配置正确：\n\n![](http://i.imgur.com/liqPDX8.png)\n\n\n\n### 1.2 录制脚本\n\n与其他自动化测试工具相似，MonkeyRunner也可以进行脚本录制。这里需要使用Python命令打开MonkeyRunner脚本录制界面：\n\n**第一步**： 新建文本文档，命名为record.py，编辑其内容：\n\n```python\nfrom com.android.monkeyrunner import MonkeyRunner as mr  \nfrom com.android.monkeyrunner.recorder import MonkeyRecorder as recorder  \n      \ndevice = mr.waitForConnection()  \nrecorder.start(device) \n```\n编辑完成后，将该文件放在monkeyrunner平级的目录下(这里注明放在和SDK平级的目录下，是为了方便执行，不用输入绝对路径)，即 **E:\\Android\\sdk\\tools**(注意自己的SDK路径)\n\n\n**第二步**： 在cmd命令行，执行该文件：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/glI0yVI.png)\n\n\n\n执行成功后，会出现MonkeyRunner的录制界面：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/2wgySa6.png)\n\n界面中：\n\n1. 左侧为当前屏幕界面\n2. 右侧为当前操作类型及位置\n3. 标题栏中：\n\t1. Wait:设置输入时间间隔，单位为秒\n\t2. Press a Button: 硬件按钮，包括menu、home、search，以及对按钮的press、down、up属性\n\t3. Type Something: 输入内容\n\t4. Fling: 滑动输入，可设置方向和操作范围\n\t5. Export Actions:导出录制脚本\n\t6. Refresh Display:界面刷新，或者叫做界面同步\n\n至此，已经学会了如何使用MonkeyRunner进行脚本录制，接下来将如何回放录制的脚本。\n我们仍然使用之前的自定义画板进行录制（因为之前画板代码存在问题，没有绘制点，只是绘制线，因此需要输入滑动事件），我们使用MonkeyRecoder的Fling功能，随便绘制两条线，结果如下：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/BzLeUro.png)\n\n左侧为绘制线条，右侧为动作，录制完成后，可以将脚本导出并保存。\n\n### 1.3 脚本回放\n\n使用MonkeyRecoder录制完脚本后，可以对脚本进行回放。\n\n\n回放时，需要使用MonkeyRunner执行Python脚本，内容固定：\n\n```python\nimport sys\nfrom com.android.monkeyrunner import MonkeyRunner\nCMD_MAP = {\n'TOUCH': lambda dev, arg: dev.touch(**arg),\n'DRAG': lambda dev, arg: dev.drag(**arg),\n'PRESS': lambda dev, arg: dev.press(**arg),\n'TYPE': lambda dev, arg: dev.type(**arg),\n'WAIT': lambda dev, arg: MonkeyRunner.sleep(**arg)\n}\n\t\t\n# Process a single file for the specified device.\ndef process_file(fp, device):\nfor line in fp:\n(cmd, rest) = line.split('|')\ntry:\n# Parse the pydict\nrest = eval(rest)\nexcept:\nprint 'unable to parse options'\ncontinue\n\t\t\nif cmd not in CMD_MAP:\nprint 'unknown command: ' + cmd\ncontinue\nCMD_MAP[cmd](device, rest)\ndef main():\nfile = sys.argv[1]\nfp = open(file, 'r')\ndevice = MonkeyRunner.waitForConnection()\nprocess_file(fp, device)\nfp.close();\n\t\t\nif __name__ == '__main__':\nmain()\n```\n\n同样的操作，新建python文档，将这个脚本粘贴至该文档中，文档路径与MonkeyRunner路径相同(避免使用绝对路径进行操作)\n\n然后执行该脚本，得到结果与之前绘制效果一致。\n\n![](http://image.jucaiwy.com/image/20160623/monkey/GluioC1.gif)\n\n\n\n\n### 1.4 自定义脚本\n\n对之前录制脚本文件使用编辑器打开，会发现，生成脚本其实就是一系列语句，所以我们可以对该脚本进行修改，完成自定义，下面我们通过修改脚本，绘制一个正方形，修改后脚本如下：\n\n```python\nWAIT|{'seconds':5.0,} \nDRAG|{'start':(100,100),'end':(100,1000),'duration':1.0,'steps':10,}\nDRAG|{'start':(100,1000),'end':(1000,1000),'duration':1.0,'steps':10,}\nWAIT|{'seconds':1.0,} \nDRAG|{'start':(1000,1000),'end':(1000,100),'duration':1.0,'steps':10,}\nDRAG|{'start':(1000,100),'end':(100,100),'duration':1.0,'steps':10,}\n```\n\n回放该脚本：\n\n![](http://image.jucaiwy.com/image/20160623/monkey/6KGGXc2.gif)\n\n这里仅仅只是用了DRAG和WAIT两个动作。同样的还有很多：\n\n```python\nPRESS|{'name':'MENU','type':'downAndUp',}\nPRESS|{'name':'HOME','type':'downAndUp',}\nPRESS|{'name':'SEARCH','type':'downAndUp',}\nPRESS|{'name':'MENU','type':'down',}\nTYPE|{'message':'hello',}\nTOUCH|{'x':469,'y':836,'type':'downAndUp',}\n```\n\n## 2. 结束\n\n至此已经大致讲完了MonkeyRunner的基本使用方法，至于后边想到什么了，记得使用MonkeyRunner时有个takePicture的命令，想起来了再进行补充吧。\n\n\n","source":"_posts/20160623Android自动化测试——MonkeyRunner.md","raw":"---\n\ntitle: Android自动化测试——MoneyRunner\n\ndate: 2016-06-23 18:34:46\n\ntags: [ Android , 自动化测试 , MonkeyRunner]\n\ncategories: Android\n\nkeywords: Android , 自动化测试 , MonkeyRunner\n\ndescription: Android自动化测试——MoneyRunner\n\ntop_img: http://image.jucaiwy.com/image/20160623/monkey_runner.jpeg\n\ncover: http://image.jucaiwy.com/image/20160623/monkey_runner.jpeg\n\n---\n\n\n接着上一篇文章继续写，上篇文章中，主要对[Android自动化测试——Monkey](http://blog.csdn.net/duanbokan/article/details/51742893)的概念和使用方法进行了简单介绍，，这篇文章中，我们继续探讨MonkeyRunner的使用\n\n有人之前问过我，Monkey和MonkeyRunner之间有什么区别，我用这样一个比喻来回答他，Monkey就是一只猴子，放养的猴子，未经训练的猴子，所以它在测试的时候，只会胡乱点、胡乱划(随机事件)；而MonkeyRunner则不同于Monkey，它属于家养的，经过训练的，可以按照主人的命令，做出各种动作(自定义事件)。\n\nok，下边直接讲如何使用MonkeyRunner\n\n\n### 1.1 MonkeyRunner环境搭建\n搭建MonKeyRunner环境需要以下三部分：\n\n1. Java环境，及Java环境变量配置\n\n2. Android SDK Monkey是Google提供的自动化测试工具，在SDK根路径的tools文件夹中可以找到，因此，使用MonkeyRunner需要下载安装SDK。 下载完成后，直接解压，绿色，无需安装，注意解压路径不能有中文或空格。\n\t\n\t[SDK下载路径](http://www.android-doc.com/sdk/index.html)\n\n3. 安装Python编译环境  ：Python用于支持MonkeyRunner的运行，安装Python，同时配置其环境变量。\n\n\t[Python下载路径](https://www.python.org/downloads/)\n\n检查Python和MonkeyRunner是否配置正确：\n\n![](http://i.imgur.com/liqPDX8.png)\n\n\n\n### 1.2 录制脚本\n\n与其他自动化测试工具相似，MonkeyRunner也可以进行脚本录制。这里需要使用Python命令打开MonkeyRunner脚本录制界面：\n\n**第一步**： 新建文本文档，命名为record.py，编辑其内容：\n\n```python\nfrom com.android.monkeyrunner import MonkeyRunner as mr  \nfrom com.android.monkeyrunner.recorder import MonkeyRecorder as recorder  \n      \ndevice = mr.waitForConnection()  \nrecorder.start(device) \n```\n编辑完成后，将该文件放在monkeyrunner平级的目录下(这里注明放在和SDK平级的目录下，是为了方便执行，不用输入绝对路径)，即 **E:\\Android\\sdk\\tools**(注意自己的SDK路径)\n\n\n**第二步**： 在cmd命令行，执行该文件：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/glI0yVI.png)\n\n\n\n执行成功后，会出现MonkeyRunner的录制界面：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/2wgySa6.png)\n\n界面中：\n\n1. 左侧为当前屏幕界面\n2. 右侧为当前操作类型及位置\n3. 标题栏中：\n\t1. Wait:设置输入时间间隔，单位为秒\n\t2. Press a Button: 硬件按钮，包括menu、home、search，以及对按钮的press、down、up属性\n\t3. Type Something: 输入内容\n\t4. Fling: 滑动输入，可设置方向和操作范围\n\t5. Export Actions:导出录制脚本\n\t6. Refresh Display:界面刷新，或者叫做界面同步\n\n至此，已经学会了如何使用MonkeyRunner进行脚本录制，接下来将如何回放录制的脚本。\n我们仍然使用之前的自定义画板进行录制（因为之前画板代码存在问题，没有绘制点，只是绘制线，因此需要输入滑动事件），我们使用MonkeyRecoder的Fling功能，随便绘制两条线，结果如下：\n\n\n![](http://image.jucaiwy.com/image/20160623/monkey/BzLeUro.png)\n\n左侧为绘制线条，右侧为动作，录制完成后，可以将脚本导出并保存。\n\n### 1.3 脚本回放\n\n使用MonkeyRecoder录制完脚本后，可以对脚本进行回放。\n\n\n回放时，需要使用MonkeyRunner执行Python脚本，内容固定：\n\n```python\nimport sys\nfrom com.android.monkeyrunner import MonkeyRunner\nCMD_MAP = {\n'TOUCH': lambda dev, arg: dev.touch(**arg),\n'DRAG': lambda dev, arg: dev.drag(**arg),\n'PRESS': lambda dev, arg: dev.press(**arg),\n'TYPE': lambda dev, arg: dev.type(**arg),\n'WAIT': lambda dev, arg: MonkeyRunner.sleep(**arg)\n}\n\t\t\n# Process a single file for the specified device.\ndef process_file(fp, device):\nfor line in fp:\n(cmd, rest) = line.split('|')\ntry:\n# Parse the pydict\nrest = eval(rest)\nexcept:\nprint 'unable to parse options'\ncontinue\n\t\t\nif cmd not in CMD_MAP:\nprint 'unknown command: ' + cmd\ncontinue\nCMD_MAP[cmd](device, rest)\ndef main():\nfile = sys.argv[1]\nfp = open(file, 'r')\ndevice = MonkeyRunner.waitForConnection()\nprocess_file(fp, device)\nfp.close();\n\t\t\nif __name__ == '__main__':\nmain()\n```\n\n同样的操作，新建python文档，将这个脚本粘贴至该文档中，文档路径与MonkeyRunner路径相同(避免使用绝对路径进行操作)\n\n然后执行该脚本，得到结果与之前绘制效果一致。\n\n![](http://image.jucaiwy.com/image/20160623/monkey/GluioC1.gif)\n\n\n\n\n### 1.4 自定义脚本\n\n对之前录制脚本文件使用编辑器打开，会发现，生成脚本其实就是一系列语句，所以我们可以对该脚本进行修改，完成自定义，下面我们通过修改脚本，绘制一个正方形，修改后脚本如下：\n\n```python\nWAIT|{'seconds':5.0,} \nDRAG|{'start':(100,100),'end':(100,1000),'duration':1.0,'steps':10,}\nDRAG|{'start':(100,1000),'end':(1000,1000),'duration':1.0,'steps':10,}\nWAIT|{'seconds':1.0,} \nDRAG|{'start':(1000,1000),'end':(1000,100),'duration':1.0,'steps':10,}\nDRAG|{'start':(1000,100),'end':(100,100),'duration':1.0,'steps':10,}\n```\n\n回放该脚本：\n\n![](http://image.jucaiwy.com/image/20160623/monkey/6KGGXc2.gif)\n\n这里仅仅只是用了DRAG和WAIT两个动作。同样的还有很多：\n\n```python\nPRESS|{'name':'MENU','type':'downAndUp',}\nPRESS|{'name':'HOME','type':'downAndUp',}\nPRESS|{'name':'SEARCH','type':'downAndUp',}\nPRESS|{'name':'MENU','type':'down',}\nTYPE|{'message':'hello',}\nTOUCH|{'x':469,'y':836,'type':'downAndUp',}\n```\n\n## 2. 结束\n\n至此已经大致讲完了MonkeyRunner的基本使用方法，至于后边想到什么了，记得使用MonkeyRunner时有个takePicture的命令，想起来了再进行补充吧。\n\n\n","slug":"20160623Android自动化测试——MonkeyRunner","published":1,"updated":"2020-12-09T06:34:26.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278juru001fb3t1eu0d1kfo","content":"<p>接着上一篇文章继续写，上篇文章中，主要对<a href=\"http://blog.csdn.net/duanbokan/article/details/51742893\">Android自动化测试——Monkey</a>的概念和使用方法进行了简单介绍，，这篇文章中，我们继续探讨MonkeyRunner的使用</p>\n<p>有人之前问过我，Monkey和MonkeyRunner之间有什么区别，我用这样一个比喻来回答他，Monkey就是一只猴子，放养的猴子，未经训练的猴子，所以它在测试的时候，只会胡乱点、胡乱划(随机事件)；而MonkeyRunner则不同于Monkey，它属于家养的，经过训练的，可以按照主人的命令，做出各种动作(自定义事件)。</p>\n<p>ok，下边直接讲如何使用MonkeyRunner</p>\n<h3 id=\"1-1-MonkeyRunner环境搭建\"><a href=\"#1-1-MonkeyRunner环境搭建\" class=\"headerlink\" title=\"1.1 MonkeyRunner环境搭建\"></a>1.1 MonkeyRunner环境搭建</h3><p>搭建MonKeyRunner环境需要以下三部分：</p>\n<ol>\n<li><p>Java环境，及Java环境变量配置</p>\n</li>\n<li><p>Android SDK Monkey是Google提供的自动化测试工具，在SDK根路径的tools文件夹中可以找到，因此，使用MonkeyRunner需要下载安装SDK。 下载完成后，直接解压，绿色，无需安装，注意解压路径不能有中文或空格。</p>\n<p> <a href=\"http://www.android-doc.com/sdk/index.html\">SDK下载路径</a></p>\n</li>\n<li><p>安装Python编译环境  ：Python用于支持MonkeyRunner的运行，安装Python，同时配置其环境变量。</p>\n<p> <a href=\"https://www.python.org/downloads/\">Python下载路径</a></p>\n</li>\n</ol>\n<p>检查Python和MonkeyRunner是否配置正确：</p>\n<p><img src=\"http://i.imgur.com/liqPDX8.png\"></p>\n<h3 id=\"1-2-录制脚本\"><a href=\"#1-2-录制脚本\" class=\"headerlink\" title=\"1.2 录制脚本\"></a>1.2 录制脚本</h3><p>与其他自动化测试工具相似，MonkeyRunner也可以进行脚本录制。这里需要使用Python命令打开MonkeyRunner脚本录制界面：</p>\n<p><strong>第一步</strong>： 新建文本文档，命名为record.py，编辑其内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner <span class=\"keyword\">import</span> MonkeyRunner <span class=\"keyword\">as</span> mr  </span><br><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner.recorder <span class=\"keyword\">import</span> MonkeyRecorder <span class=\"keyword\">as</span> recorder  </span><br><span class=\"line\">      </span><br><span class=\"line\">device = mr.waitForConnection()  </span><br><span class=\"line\">recorder.start(device) </span><br></pre></td></tr></table></figure>\n<p>编辑完成后，将该文件放在monkeyrunner平级的目录下(这里注明放在和SDK平级的目录下，是为了方便执行，不用输入绝对路径)，即 <strong>E:\\Android\\sdk\\tools</strong>(注意自己的SDK路径)</p>\n<p><strong>第二步</strong>： 在cmd命令行，执行该文件：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/glI0yVI.png\"></p>\n<p>执行成功后，会出现MonkeyRunner的录制界面：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/2wgySa6.png\"></p>\n<p>界面中：</p>\n<ol>\n<li>左侧为当前屏幕界面</li>\n<li>右侧为当前操作类型及位置</li>\n<li>标题栏中：<ol>\n<li>Wait:设置输入时间间隔，单位为秒</li>\n<li>Press a Button: 硬件按钮，包括menu、home、search，以及对按钮的press、down、up属性</li>\n<li>Type Something: 输入内容</li>\n<li>Fling: 滑动输入，可设置方向和操作范围</li>\n<li>Export Actions:导出录制脚本</li>\n<li>Refresh Display:界面刷新，或者叫做界面同步</li>\n</ol>\n</li>\n</ol>\n<p>至此，已经学会了如何使用MonkeyRunner进行脚本录制，接下来将如何回放录制的脚本。<br>我们仍然使用之前的自定义画板进行录制（因为之前画板代码存在问题，没有绘制点，只是绘制线，因此需要输入滑动事件），我们使用MonkeyRecoder的Fling功能，随便绘制两条线，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/BzLeUro.png\"></p>\n<p>左侧为绘制线条，右侧为动作，录制完成后，可以将脚本导出并保存。</p>\n<h3 id=\"1-3-脚本回放\"><a href=\"#1-3-脚本回放\" class=\"headerlink\" title=\"1.3 脚本回放\"></a>1.3 脚本回放</h3><p>使用MonkeyRecoder录制完脚本后，可以对脚本进行回放。</p>\n<p>回放时，需要使用MonkeyRunner执行Python脚本，内容固定：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner <span class=\"keyword\">import</span> MonkeyRunner</span><br><span class=\"line\">CMD_MAP = &#123;</span><br><span class=\"line\"><span class=\"string\">&#x27;TOUCH&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.touch(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;DRAG&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.drag(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;PRESS&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.press(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;TYPE&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.<span class=\"built_in\">type</span>(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;WAIT&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: MonkeyRunner.sleep(**arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\"># Process a single file for the specified device.</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">process_file</span>(<span class=\"params\">fp, device</span>):</span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> fp:</span><br><span class=\"line\">(cmd, rest) = line.split(<span class=\"string\">&#x27;|&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\"><span class=\"comment\"># Parse the pydict</span></span><br><span class=\"line\">rest = <span class=\"built_in\">eval</span>(rest)</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;unable to parse options&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> cmd <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> CMD_MAP:</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;unknown command: &#x27;</span> + cmd</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">CMD_MAP[cmd](device, rest)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">file = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">device = MonkeyRunner.waitForConnection()</span><br><span class=\"line\">process_file(fp, device)</span><br><span class=\"line\">fp.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure>\n\n<p>同样的操作，新建python文档，将这个脚本粘贴至该文档中，文档路径与MonkeyRunner路径相同(避免使用绝对路径进行操作)</p>\n<p>然后执行该脚本，得到结果与之前绘制效果一致。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/GluioC1.gif\"></p>\n<h3 id=\"1-4-自定义脚本\"><a href=\"#1-4-自定义脚本\" class=\"headerlink\" title=\"1.4 自定义脚本\"></a>1.4 自定义脚本</h3><p>对之前录制脚本文件使用编辑器打开，会发现，生成脚本其实就是一系列语句，所以我们可以对该脚本进行修改，完成自定义，下面我们通过修改脚本，绘制一个正方形，修改后脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WAIT|&#123;<span class=\"string\">&#x27;seconds&#x27;</span>:<span class=\"number\">5.0</span>,&#125; </span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">WAIT|&#123;<span class=\"string\">&#x27;seconds&#x27;</span>:<span class=\"number\">1.0</span>,&#125; </span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回放该脚本：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/6KGGXc2.gif\"></p>\n<p>这里仅仅只是用了DRAG和WAIT两个动作。同样的还有很多：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;MENU&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;HOME&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;SEARCH&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;MENU&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;down&#x27;</span>,&#125;</span><br><span class=\"line\">TYPE|&#123;<span class=\"string\">&#x27;message&#x27;</span>:<span class=\"string\">&#x27;hello&#x27;</span>,&#125;</span><br><span class=\"line\">TOUCH|&#123;<span class=\"string\">&#x27;x&#x27;</span>:<span class=\"number\">469</span>,<span class=\"string\">&#x27;y&#x27;</span>:<span class=\"number\">836</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-结束\"><a href=\"#2-结束\" class=\"headerlink\" title=\"2. 结束\"></a>2. 结束</h2><p>至此已经大致讲完了MonkeyRunner的基本使用方法，至于后边想到什么了，记得使用MonkeyRunner时有个takePicture的命令，想起来了再进行补充吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>接着上一篇文章继续写，上篇文章中，主要对<a href=\"http://blog.csdn.net/duanbokan/article/details/51742893\">Android自动化测试——Monkey</a>的概念和使用方法进行了简单介绍，，这篇文章中，我们继续探讨MonkeyRunner的使用</p>\n<p>有人之前问过我，Monkey和MonkeyRunner之间有什么区别，我用这样一个比喻来回答他，Monkey就是一只猴子，放养的猴子，未经训练的猴子，所以它在测试的时候，只会胡乱点、胡乱划(随机事件)；而MonkeyRunner则不同于Monkey，它属于家养的，经过训练的，可以按照主人的命令，做出各种动作(自定义事件)。</p>\n<p>ok，下边直接讲如何使用MonkeyRunner</p>\n<h3 id=\"1-1-MonkeyRunner环境搭建\"><a href=\"#1-1-MonkeyRunner环境搭建\" class=\"headerlink\" title=\"1.1 MonkeyRunner环境搭建\"></a>1.1 MonkeyRunner环境搭建</h3><p>搭建MonKeyRunner环境需要以下三部分：</p>\n<ol>\n<li><p>Java环境，及Java环境变量配置</p>\n</li>\n<li><p>Android SDK Monkey是Google提供的自动化测试工具，在SDK根路径的tools文件夹中可以找到，因此，使用MonkeyRunner需要下载安装SDK。 下载完成后，直接解压，绿色，无需安装，注意解压路径不能有中文或空格。</p>\n<p> <a href=\"http://www.android-doc.com/sdk/index.html\">SDK下载路径</a></p>\n</li>\n<li><p>安装Python编译环境  ：Python用于支持MonkeyRunner的运行，安装Python，同时配置其环境变量。</p>\n<p> <a href=\"https://www.python.org/downloads/\">Python下载路径</a></p>\n</li>\n</ol>\n<p>检查Python和MonkeyRunner是否配置正确：</p>\n<p><img src=\"http://i.imgur.com/liqPDX8.png\"></p>\n<h3 id=\"1-2-录制脚本\"><a href=\"#1-2-录制脚本\" class=\"headerlink\" title=\"1.2 录制脚本\"></a>1.2 录制脚本</h3><p>与其他自动化测试工具相似，MonkeyRunner也可以进行脚本录制。这里需要使用Python命令打开MonkeyRunner脚本录制界面：</p>\n<p><strong>第一步</strong>： 新建文本文档，命名为record.py，编辑其内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner <span class=\"keyword\">import</span> MonkeyRunner <span class=\"keyword\">as</span> mr  </span><br><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner.recorder <span class=\"keyword\">import</span> MonkeyRecorder <span class=\"keyword\">as</span> recorder  </span><br><span class=\"line\">      </span><br><span class=\"line\">device = mr.waitForConnection()  </span><br><span class=\"line\">recorder.start(device) </span><br></pre></td></tr></table></figure>\n<p>编辑完成后，将该文件放在monkeyrunner平级的目录下(这里注明放在和SDK平级的目录下，是为了方便执行，不用输入绝对路径)，即 <strong>E:\\Android\\sdk\\tools</strong>(注意自己的SDK路径)</p>\n<p><strong>第二步</strong>： 在cmd命令行，执行该文件：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/glI0yVI.png\"></p>\n<p>执行成功后，会出现MonkeyRunner的录制界面：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/2wgySa6.png\"></p>\n<p>界面中：</p>\n<ol>\n<li>左侧为当前屏幕界面</li>\n<li>右侧为当前操作类型及位置</li>\n<li>标题栏中：<ol>\n<li>Wait:设置输入时间间隔，单位为秒</li>\n<li>Press a Button: 硬件按钮，包括menu、home、search，以及对按钮的press、down、up属性</li>\n<li>Type Something: 输入内容</li>\n<li>Fling: 滑动输入，可设置方向和操作范围</li>\n<li>Export Actions:导出录制脚本</li>\n<li>Refresh Display:界面刷新，或者叫做界面同步</li>\n</ol>\n</li>\n</ol>\n<p>至此，已经学会了如何使用MonkeyRunner进行脚本录制，接下来将如何回放录制的脚本。<br>我们仍然使用之前的自定义画板进行录制（因为之前画板代码存在问题，没有绘制点，只是绘制线，因此需要输入滑动事件），我们使用MonkeyRecoder的Fling功能，随便绘制两条线，结果如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/BzLeUro.png\"></p>\n<p>左侧为绘制线条，右侧为动作，录制完成后，可以将脚本导出并保存。</p>\n<h3 id=\"1-3-脚本回放\"><a href=\"#1-3-脚本回放\" class=\"headerlink\" title=\"1.3 脚本回放\"></a>1.3 脚本回放</h3><p>使用MonkeyRecoder录制完脚本后，可以对脚本进行回放。</p>\n<p>回放时，需要使用MonkeyRunner执行Python脚本，内容固定：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">from</span> com.android.monkeyrunner <span class=\"keyword\">import</span> MonkeyRunner</span><br><span class=\"line\">CMD_MAP = &#123;</span><br><span class=\"line\"><span class=\"string\">&#x27;TOUCH&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.touch(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;DRAG&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.drag(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;PRESS&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.press(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;TYPE&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: dev.<span class=\"built_in\">type</span>(**arg),</span><br><span class=\"line\"><span class=\"string\">&#x27;WAIT&#x27;</span>: <span class=\"keyword\">lambda</span> dev, arg: MonkeyRunner.sleep(**arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\"># Process a single file for the specified device.</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">process_file</span>(<span class=\"params\">fp, device</span>):</span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> fp:</span><br><span class=\"line\">(cmd, rest) = line.split(<span class=\"string\">&#x27;|&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\"><span class=\"comment\"># Parse the pydict</span></span><br><span class=\"line\">rest = <span class=\"built_in\">eval</span>(rest)</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;unable to parse options&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> cmd <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> CMD_MAP:</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;unknown command: &#x27;</span> + cmd</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">CMD_MAP[cmd](device, rest)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">file = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">device = MonkeyRunner.waitForConnection()</span><br><span class=\"line\">process_file(fp, device)</span><br><span class=\"line\">fp.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure>\n\n<p>同样的操作，新建python文档，将这个脚本粘贴至该文档中，文档路径与MonkeyRunner路径相同(避免使用绝对路径进行操作)</p>\n<p>然后执行该脚本，得到结果与之前绘制效果一致。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/GluioC1.gif\"></p>\n<h3 id=\"1-4-自定义脚本\"><a href=\"#1-4-自定义脚本\" class=\"headerlink\" title=\"1.4 自定义脚本\"></a>1.4 自定义脚本</h3><p>对之前录制脚本文件使用编辑器打开，会发现，生成脚本其实就是一系列语句，所以我们可以对该脚本进行修改，完成自定义，下面我们通过修改脚本，绘制一个正方形，修改后脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WAIT|&#123;<span class=\"string\">&#x27;seconds&#x27;</span>:<span class=\"number\">5.0</span>,&#125; </span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">WAIT|&#123;<span class=\"string\">&#x27;seconds&#x27;</span>:<span class=\"number\">1.0</span>,&#125; </span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">1000</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br><span class=\"line\">DRAG|&#123;<span class=\"string\">&#x27;start&#x27;</span>:(<span class=\"number\">1000</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;end&#x27;</span>:(<span class=\"number\">100</span>,<span class=\"number\">100</span>),<span class=\"string\">&#x27;duration&#x27;</span>:<span class=\"number\">1.0</span>,<span class=\"string\">&#x27;steps&#x27;</span>:<span class=\"number\">10</span>,&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回放该脚本：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20160623/monkey/6KGGXc2.gif\"></p>\n<p>这里仅仅只是用了DRAG和WAIT两个动作。同样的还有很多：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;MENU&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;HOME&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;SEARCH&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class=\"line\">PRESS|&#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;MENU&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;down&#x27;</span>,&#125;</span><br><span class=\"line\">TYPE|&#123;<span class=\"string\">&#x27;message&#x27;</span>:<span class=\"string\">&#x27;hello&#x27;</span>,&#125;</span><br><span class=\"line\">TOUCH|&#123;<span class=\"string\">&#x27;x&#x27;</span>:<span class=\"number\">469</span>,<span class=\"string\">&#x27;y&#x27;</span>:<span class=\"number\">836</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;downAndUp&#x27;</span>,&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-结束\"><a href=\"#2-结束\" class=\"headerlink\" title=\"2. 结束\"></a>2. 结束</h2><p>至此已经大致讲完了MonkeyRunner的基本使用方法，至于后边想到什么了，记得使用MonkeyRunner时有个takePicture的命令，想起来了再进行补充吧。</p>\n"},{"title":"斗地主算法","date":"2017-07-10T10:34:46.000Z","keywords":"Android , 斗地主 , 算法","description":"斗地主算法","top_img":"http://image.jucaiwy.com/image/20160710/tienlen_width.jpg","cover":"http://image.jucaiwy.com/image/20160710/tienlen_small.jpg","_content":"\n\n\n\n最近需要做一个类似于斗地主的游戏，由于只是类似斗地主的游戏，因此，规则方面和斗地主存在一些不同，但是在算法上，也是大同小异，现对该游戏算法进行总结：\n\n\n### 1.定义牌对象\n 首先需要对牌对象进行定义，正常斗地主玩法下，一张牌只有一个属性，就是数字大小，而不管花色，而在我们的游戏中，同样数字的牌，不同花色之间还可以比较，因此，我们的牌一共有两个基本属性，分别为花色和大小。\n\n#### 1.1 规则\n\n对于花色，规则定义如下：黑桃>梅花>方片>红桃\n \n对于数字，规则定义如下：2最大，3最小\n\n#### 1.2 建模\n\n我们将牌的牌面实际数字使用数字进行标记，使用数字3到15表示真实牌的3到2，其中11表示J，12表示Q，13表示K，14表示A，15表示2，其余数字分别代表真实牌面数字。\n\n将牌的牌面花色同样使用数字进行标记：根据从大到小，分别标记为：4——黑桃，3——梅花，2——方片，1——红桃。\n\n这样，对于一张牌的数字模型，使用以下公式进行标记：\n\n牌数字模型大小  =  牌面数字模型大小 * 10 + 牌面花色模型大小\n\n\t// 牌号点数：如3~J~A~2,使用3~15数字\n\tprivate int cardNumber;\n\t\t\n\t// 牌色：如4红桃, 3方片, 2梅花, 1黑桃\n\tprivate int cardColor;\n\t\t\n\t// 牌全称：例34是红桃3,152是梅花2,113是方片J\n\tprivate String cardName;\n\t\t\n\t// 牌描述：例红桃3,梅花2\n\tprivate String cardDesc;\n\n\n\n#### 1.3 总结\n\n经过上边的标记，我们很容易将一张牌的模型进行数字化，例如：\n\n154——黑桃2\n\n151——红桃2\n\n83——梅花8\n\n这样154>151，同样黑桃2大于红桃2\n\n151>83，同样红桃2大于梅花8\n\n\n\n### 2. 构建一副牌\n\n构建一副牌可以从花色、牌面大小、牌的名称、牌的描述四个方面进行构建，其中花色（4——黑桃，3——梅花，2——方片，1——红桃），大小为：使用数字3到15表示真实牌的3到2，牌名称即牌大小和花色组成的数字大小，描述是通用的牌的叫法，比如：154——黑桃2 牌名称为154 描述为 黑桃2\n\n这里需要主要的是：**斗地主中存在王，大小王，共54张牌，而在我们的TienLen游戏中不存在大小王，只有52张牌**\n\n\t/**\n     * 初始化牌\n     * @return\n     */\n    public List<CardInfo> initCard() {\n        List<CardInfo> cardList = new ArrayList<CardInfo>();\n        for (int i = 1; i < 5; i++) {\n            for (int j = 3; j < 16; j++) {\n                CardInfo cardInfo = new CardInfo();\n                cardInfo.setCardNumber(j);\n                cardInfo.setCardColor(i);\n                cardInfo.setCardName(j * 10 + i + \"\");\n                switch (i) {\n                    case 1:\n                        cardInfo.setCardDesc(\"红桃\" + j);\n                        break;\n                    case 2:\n                        cardInfo.setCardDesc(\"方片\" + j);\n                        break;\n                    case 3:\n                        cardInfo.setCardDesc(\"梅花\" + j);\n                        break;\n                    case 4:\n                        cardInfo.setCardDesc(\"黑桃\" + j);\n                        break;\n                }\n                cardList.add(cardInfo);\n            }\n        }\n        return cardList;\n    }\n\n\n\n### 3. 洗牌\n\n洗牌只需要将牌进行打乱即可，这里考虑使用随机数进行交换，模拟洗牌，但是这样的算法存在缺陷，即有可能洗完以后，牌仍然保持原样\n\n\t/**\n     * 洗牌\n     *\n     * @param cardList 初始化号的牌\n     * @return\n     */\n    public List<CardInfo> washCard(List<CardInfo> cardList) {\n        List<CardInfo> randomCardList = cardList;\n        for (int i = 0; i < 100; i++) {\n            Random random = new Random();\n            // 找出52以内的随机数，然后交换位置\n            int a = random.nextInt(52);\n            int b = random.nextInt(52);\n            CardInfo cardInfoTemp = randomCardList.get(a);\n            randomCardList.set(a, randomCardList.get(b));\n            randomCardList.set(b, cardInfoTemp);\n        }\n\n        return randomCardList;\n    }\n \n### 4. 发牌\n\n发牌算法很简单，将已经洗好的52张牌，顺序发给各个玩家。这里我们与斗地主区别在于，我们这里一共有四个玩家，因此需要将牌分为4份：\n\n\t/**\n     * 发牌\n     *\n     * @param cardList 洗好的牌\n     * @return\n     */\n    public List<CardInfo>[] handCard(List<CardInfo> cardList) {\n        List<CardInfo> playerCardList[] = new Vector[4];\n        for (int i = 0; i < 4; i++) {\n            playerCardList[i] = new Vector<CardInfo>();\n        }\n        for (int j = 0; j < 52; j++) {\n            switch (j % 4) {\n                case 0:\n                    playerCardList[0].add(cardList.get(j));\n                    break;\n                case 1:\n                    playerCardList[1].add(cardList.get(j));\n                    break;\n                case 2:\n                    playerCardList[2].add(cardList.get(j));\n                    break;\n                case 3:\n                    playerCardList[3].add(cardList.get(j));\n                    break;\n                default:\n                    break;\n            }\n        }\n        return playerCardList;\n    }\n\n\n### 5. 捋牌\n\n也就是对牌进行排序，从大到小进行排序，这样出来的牌，便于往后进行分类等运算。\n\n\t/**\n     * 排序，按照从大到小的顺序进行排\n     *\n     * @param cardList\n     * @return\n     */\n    public List<CardInfo> sortCard(List<CardInfo> cardList) {\n        Collections.sort(cardList, new Comparator<CardInfo>() {\n            @Override\n            public int compare(CardInfo cardInfo1, CardInfo cardInfo2) {\n                int cardNum1 = Integer.valueOf(cardInfo1.getCardName());\n                int cardNum2 = Integer.valueOf(cardInfo2.getCardName());\n\n                if (cardNum1 > cardNum2) {\n                    return -1;\n                } else if (cardNum1 == cardNum2) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            }\n        });\n        return cardList;\n    }\n\n\n### 6. 出牌\n   出牌时，应该根据规则进行出牌，首先、判断用户所选择的牌是否符合规则，即是否是单牌、对子、三张、链子、炸弹等\n\n#### 6.1 单张牌\n\n获取单张牌的算法很简单，任意一张牌，都可以作为单张牌使用，因此只需要将所有的牌都添加到单张牌的列表中即可。\n\t\n\t /***\n     * 获取单张牌\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get1(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all1List = new ArrayList<>();\n        List<CardInfo> cardList;\n        sortCardAsc(mCardList);\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            cardList = new ArrayList<>();\n            cardList.add(mCardList.get(i));\n            all1List.add(cardList);\n        }\n\n        return all1List;\n    }\n\n#### 6.2 对子\n\n获取对子时，需要注意，因为我们TienLen游戏的规则中，不仅需要比较牌面点数大小，还需要比较花色大小，所以，同样4个2，可能组合成多种对子，且大小不一样，比如黑桃2和梅花2，比如红桃2和方片2\n\n\t /**\n     * 获取对子\n     * 这里对i+1 i+2 i+3分别和第i张牌进行对比，\n     * 举例：比如四个2，可以黑桃2和方片2一对，也可以是梅花2和红桃2一对\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get11(List<CardInfo> mCardList) {\n\t\t// 先对牌进行排序\n        sortCardAsc(mCardList);\n        List<List<CardInfo>> all11CardList = new ArrayList<>();\n        List<CardInfo> cardList;\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 1 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 1).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                all11CardList.add(cardList);\n            }\n            if (i + 2 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 2));\n                all11CardList.add(cardList);\n            }\n            if (i + 3 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 3));\n                all11CardList.add(cardList);\n            }\n        }\n        return all11CardList;\n    }\n\n\n### 6.3 三个\n在斗地主的规则中，好像也是三个也可以一起出，但是需要带一个或者一对，我们TienLen游戏中不需要带，也不能带，可以直接出，比如三个三，三个四，这样的牌，获取的算法和上边对子的获取算法一致\n\n\t /***\n     * 获取三个\n     * 算法个获取对子的算法类似\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get111(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all111List = new ArrayList<>();\n        List<CardInfo> cardList;\n\t\t// 先对牌进行排序\n        sortCardAsc(mCardList);\n\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 2 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                cardList.add(mCardList.get(i + 2));\n                all111List.add(cardList);\n            }\n        }\n        return all111List;\n    }\n\n\n### 6.4 炸弹\n\n炸弹，不论在斗地主中还是我们现在做的TienLen中，都是一样的作用，一样的获取方法，和获取对子，三个的方法一致，这里直接上代码：\n\n\t/***\n     * 获取炸弹\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get1111(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all1111List = new ArrayList<>();\n        List<CardInfo> cardList;\n\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 3 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                cardList.add(mCardList.get(i + 2));\n                cardList.add(mCardList.get(i + 3));\n                all1111List.add(cardList);\n            }\n        }\n        return all1111List;\n    }\n\n\n### 6.5 链子\n\n终于说到了这个牌型——链子，链子在不同的玩法中，可以出不同的长度，在我们的TienLen中最少是三联，这里获取时，先对手牌进行排序，排好序后，进行遍历，找到能和当前牌连接起来的，且牌长度大于3的，均属于链子：\n\n\t/**\n     * 获取链子\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get123(List<CardInfo> mCardList) {\n        // 链子长度必须大于3,即最少出3连\n        if (mCardList.size() < 3) {\n            return null;\n        }\n        // 构建返回数据\n        List<CardInfo> tempCardList = new ArrayList<>();\n        List<List<CardInfo>> all123List = new ArrayList<>();\n\n        // 先去掉2\n        for (int i = 0; i < mCardList.size(); i++) {\n            if (mCardList.get(i).getCardNumber() != 15) {\n                tempCardList.add(mCardList.get(i));\n            }\n        }\n        // 重新进行排序\n        sortCardAsc(tempCardList);\n\n        for (int i = 0; i < tempCardList.size(); i++) {\n            CardInfo tempCardInfo = tempCardList.get(i);\n            List<CardInfo> cardList = new ArrayList<>();\n            cardList.add(tempCardInfo);\n            List<CardInfo> cardListTempAfter = new ArrayList<>();\n            for (int j = i + 1; j < tempCardList.size(); j++) {\n                // 判断当前牌是否个下一个牌能连起来（当前牌是5，当下一个是5+1=6时，即连起来了，当连起来大于3个牌时，即可以认为是一连）\n                if ((tempCardInfo.getCardNumber() + 1) == tempCardList.get(j).getCardNumber()) {\n                    cardListTempAfter.clear();\n                    cardListTempAfter.addAll(cardList);\n                    cardList.add(tempCardList.get(j));\n                    tempCardInfo = tempCardList.get(j);\n                    if (cardList.size() >= 3) {\n                        List<CardInfo> cardListTemp = new ArrayList<>();\n                        cardListTemp.addAll(cardList);\n                        all123List.add(cardList);\n\n                        cardList = new ArrayList<>();\n                        cardList.addAll(cardListTemp);\n                    }\n                } else if (tempCardInfo.getCardNumber() == tempCardList.get(j).getCardNumber()\n                        && tempCardInfo.getCardNumber() != tempCardList.get(i).getCardNumber()) {\n                    List<CardInfo> cardListTemp = new ArrayList<>();\n                    cardListTemp.addAll(cardListTempAfter);\n                    if (cardListTemp.size() > 0\n                            && cardListTemp.get(cardListTemp.size() - 1).getCardNumber() != tempCardList\n                            .get(j).getCardNumber()) {\n                        cardListTempAfter.add(tempCardList.get(j));\n                        if (cardListTempAfter.size() >= 3) {\n                            all123List.add(cardListTempAfter);\n                            cardListTempAfter = new ArrayList<>();\n                            cardListTempAfter.addAll(cardListTemp);\n                        }\n                    }\n                }\n            }\n        }\n        return all123List;\n    }\n\n\n### 6.6 双链\n\n\n双链，也就是经常说的飞机带翅膀，双链的前提是对子，只有存在对子的情况下，才能找出来双链，所以，其算法也是一样，先找到所有的对子，然后去掉2，进行排序，再按照找链子的方法进行找，这样返回的就是双链。\n\n\t /***\n     * 获取飞机\n     *\n     * @param mCardInfoList\n     * @return\n     */\n    public List<List<CardInfo>> get112233(List<CardInfo> mCardInfoList) {\n        int length = mCardInfoList.size();\n        // 双链最少为3连，所以最少六张牌\n        if (length < 6) {\n            return null;\n        }\n        // 保存所有的对子\n        List<CardInfo> tempList = new ArrayList<>();\n        // 保存所有不包含2的对子\n        List<CardInfo> apairTempList = new ArrayList<>();\n        // 防止重复添加\n        List<Integer> integerList = new Vector<>();\n\n        // 返回结果\n        List<List<CardInfo>> all112233List = new ArrayList<>();\n\n        // 存储单个双对链子\n        List<CardInfo> cardList;\n\n        // 先获取所有的对子\n        for (int i = 0; i < length; i++) {\n            if (i + 1 < length\n                    && mCardInfoList.get(i).getCardNumber() == mCardInfoList.get(i + 1)\n                    .getCardNumber()) {\n                tempList.add(mCardInfoList.get(i));\n                tempList.add(mCardInfoList.get(i + 1));\n                i = i + 1;\n            }\n        }\n        // 排序\n        sortCardAsc(tempList);\n\n        // 去除对2和相同的\n        for (int i = 0, tempLength = tempList.size(); i < tempLength; i++) {\n            if (!integerList.contains(Integer.valueOf(tempList.get(i).getCardNumber()))) {\n                apairTempList.add(tempList.get(i));\n                integerList.add(Integer.valueOf(tempList.get(i).getCardNumber()));\n            }\n        }\n\n        // 双对的链子最少三联\n        if (apairTempList.size() < 3) {\n            return null;\n        }\n\n        // 对之前拿到的对子List进行排序，正序\n        sortCardAsc(tempList);\n\n        // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n        List<List<CardInfo>> get123TempList = get123(apairTempList);\n\n        for (int j = 0; j < get123TempList.size(); j++) {\n            List<CardInfo> list123 = get123TempList.get(j);\n            sortCardAsc(list123);\n            for (int k = 0; k < tempList.size(); k++) {\n                if (tempList.get(k).getCardName().equals(list123.get(0).getCardName())) {\n                    cardList = new ArrayList<>();\n                    for (int l = k; l < list123.size() * 2 + k; l++) {\n                        cardList.add(tempList.get(l));\n                    }\n                    all112233List.add(cardList);\n                }\n            }\n        }\n        return all112233List;\n    }\n\n\n\n### 7 出牌\n\n出牌有两种情况，一种是手动选择的，一种是通过提示，自动出牌的。对于手动选择的，需要根据自己当前是否有首先出牌权，进行校验，\n\t\n1. 如果当前是自己的局，也就是说，上轮出牌的过程中，自己最大，这局自己首先出，所以只需要校验自己手动选择的牌是否符合规则。\n2. 如果当前是别人的局，也就是说，自己当前跟着别人的局出牌，只能和别人的类型一致，且大于对方，所以需要校验选择的牌类型是否和别人的一致，再校验是否比别人的大，才能出\n\n对于通过提示出牌的，只适合第二种情况，也就是说，别人出牌，然后自己管，系统会进行提示\n\n\n\n#### 7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\n\n\t /**\n     * 获取出牌类型\n     * \n     * @param outCard\n     * @return\n     */\n    public OutCardType getOutCardType(List<CardInfo> outCard) {\n        if (outCard != null) {\n            int cardLength = outCard.size();\n\n            if (outCard.get(0).getCardNumber() == outCard.get(cardLength - 1).getCardNumber()) {\n                switch (cardLength) {\n                    case 1:\n                        // 单牌\n                        return OutCardType.type1;\n                    case 2:\n                        // 对子\n                        return OutCardType.type11;\n                    case 3:\n                        // 三个\n                        return OutCardType.type111;\n                    case 4:\n                        // 炸弹\n                        return OutCardType.type1111;\n                }\n            }\n\n            // 判断链子，最少三张\n            if (outCard.size() >= 3) {\n                List<CardInfo> tempCardList = new ArrayList<>();\n\n                // 先去掉2\n                for (int i = 0; i < outCard.size(); i++) {\n                    if (outCard.get(i).getCardNumber() != 15) {\n                        tempCardList.add(outCard.get(i));\n                    }\n                }\n                // 重新进行排序\n                sortCardAsc(tempCardList);\n\n                // 判断是否为链子\n                List<List<CardInfo>> get123 = get123(outCard);\n                if (get123 != null && get123.size() > 0) {\n                    for (List<CardInfo> list : get123) {\n                        if (list.size() == outCard.size()) {\n                            return OutCardType.type123;\n                        }\n                    }\n\n                }\n\n                // 双对至少6张\n                if (outCard.size() >= 6) {\n                    int length = outCard.size();\n                    // 保存所有的对子\n                    List<CardInfo> tempList = new ArrayList<>();\n                    // 保存所有不包含2的对子\n                    List<CardInfo> apairTempList = new ArrayList<>();\n                    // 防止重复添加\n                    List<Integer> integerList = new Vector<>();\n\n                    // 先获取所有的对子\n                    for (int i = 0; i < length; i++) {\n                        if (i + 1 < length\n                                && outCard.get(i).getCardNumber() == outCard.get(i + 1)\n                                .getCardNumber()) {\n                            tempList.add(outCard.get(i));\n                            tempList.add(outCard.get(i + 1));\n                            i = i + 1;\n                        }\n                    }\n\n                    // 所有的牌均为对子\n                    if (tempList.size() == outCard.size()) {\n                        // 去除对2\n                        for (int i = 0, tempLength = tempList.size(); i < tempLength; i++) {\n                            if (integerList.indexOf(outCard.get(i).getCardNumber()) < 0\n                                    && tempList.get(i).getCardNumber() != 15) {\n                                apairTempList.add(tempList.get(i));\n                                integerList.add(tempList.get(i).getCardNumber());\n                            }\n                            i = i + 1;\n                        }\n\n                        // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n                        List<List<CardInfo>> get123TempList = get123(apairTempList);\n                        for (int i = 0; i < get123TempList.size(); i++) {\n                            if (get123TempList.get(i).size() == length / 2) {\n                                return OutCardType.type112233;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return OutCardType.type0;\n    }\n只有当选中牌的类型是已知类型，才能第一步判断出是否可以出牌，下一步则需要根据当前是不是自己轮，判断需要不需要压对方的牌\n\n\n#### 7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\n\n\t\n    /**\n     * 当上家出牌后，判断自己是否可以出牌\n     *\n     * @param outCard\n     * @param mAllCard\n     * @param mSelectCard\n     * @return\n     */\n    public boolean whetherCanPlay(List<CardInfo> outCard, List<CardInfo> mAllCard,\n                                  List<CardInfo> mSelectCard) {\n        boolean isCardCanPlay = false;\n\n        // 获取对手牌型\n        OutCardType outCardType = getOutCardType(outCard);\n        OutCardType outCardTypeMy = getOutCardType(mSelectCard);\n        sortCard(outCard);\n        // 先对牌进行排序\n        sortCard(mSelectCard);\n\n        // 首先判断牌的张数是否一样\n        if (outCard.size() == mSelectCard.size() && outCardType == outCardTypeMy) {\n            int outCardName = Integer.valueOf(outCard.get(0).getCardName());\n            int mSelectCardName = Integer.valueOf(mSelectCard.get(0).getCardName());\n\n            // 相同，属于同一级牌之间压\n            switch (outCardType) {\n                case type1:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type11:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type111:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type1111:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type123:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type112233:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                default:\n                    isCardCanPlay = false;\n                    break;\n            }\n        } else {\n            // 当张数不一致时，有两种情况，即炸弹压2和连着的双对压对2\n            if (outCard.size() == 1 && mSelectCard.size() == 4) {\n                // 当别人为单个2且自己的Type为炸弹时\n                if (outCard.get(0).getCardNumber() == 15\n                        && getOutCardType(mSelectCard) == OutCardType.type1111) {\n                    isCardCanPlay = true;\n                }\n            } else {\n                // 别人出牌为一对2，自己应该用33-44-55-66或者55-66-77-88压\n                if (outCard.size() == 2 && mSelectCard.size() >= 8) {\n                    if (outCard.get(0).getCardNumber() == 15\n                            && getOutCardType(mSelectCard) == OutCardType.type112233) {\n                        isCardCanPlay = true;\n                    }\n                } else {\n                    isCardCanPlay = false;\n                }\n            }\n        }\n        return isCardCanPlay;\n    }\n\n\t\n这里边包含了部分规则，比如同样的牌类型，比较大小，同时33445566可以压对二这样的规则\n\n\n\n### 8. 提示\n\n 提示算法比较简单，先获取上家出牌的类型，再获取自己手牌中对应类型的列表，逐个进行比较，直到找到合适的\n\n\n### AI\n\n这里除了上述洗牌、发牌、出牌等算法之外，还有单机模式的AI算法，回头有空了整理下，我再发上来吧。\n\n\n### 总结\n\n在这片文章中，只是写了一个针对斗地主类类游戏的牌的算法，包含了牌模型构建、洗牌、发牌、出牌等算法的实现，虽然游戏规则不同，但是思路大同小异，希望有需要的同学可以参考下。","source":"_posts/20170710TienLen游戏算法——斗地主算法.md","raw":"---\n\ntitle: 斗地主算法\n\ndate: 2017-07-10 18:34:46\n\ntags: [ Android , 斗地主 , 算法]\n\ncategories: Android\n\nkeywords: Android , 斗地主 , 算法\n\ndescription: 斗地主算法\n\ntop_img: http://image.jucaiwy.com/image/20160710/tienlen_width.jpg\n\ncover: http://image.jucaiwy.com/image/20160710/tienlen_small.jpg\n\n---\n\n\n\n\n最近需要做一个类似于斗地主的游戏，由于只是类似斗地主的游戏，因此，规则方面和斗地主存在一些不同，但是在算法上，也是大同小异，现对该游戏算法进行总结：\n\n\n### 1.定义牌对象\n 首先需要对牌对象进行定义，正常斗地主玩法下，一张牌只有一个属性，就是数字大小，而不管花色，而在我们的游戏中，同样数字的牌，不同花色之间还可以比较，因此，我们的牌一共有两个基本属性，分别为花色和大小。\n\n#### 1.1 规则\n\n对于花色，规则定义如下：黑桃>梅花>方片>红桃\n \n对于数字，规则定义如下：2最大，3最小\n\n#### 1.2 建模\n\n我们将牌的牌面实际数字使用数字进行标记，使用数字3到15表示真实牌的3到2，其中11表示J，12表示Q，13表示K，14表示A，15表示2，其余数字分别代表真实牌面数字。\n\n将牌的牌面花色同样使用数字进行标记：根据从大到小，分别标记为：4——黑桃，3——梅花，2——方片，1——红桃。\n\n这样，对于一张牌的数字模型，使用以下公式进行标记：\n\n牌数字模型大小  =  牌面数字模型大小 * 10 + 牌面花色模型大小\n\n\t// 牌号点数：如3~J~A~2,使用3~15数字\n\tprivate int cardNumber;\n\t\t\n\t// 牌色：如4红桃, 3方片, 2梅花, 1黑桃\n\tprivate int cardColor;\n\t\t\n\t// 牌全称：例34是红桃3,152是梅花2,113是方片J\n\tprivate String cardName;\n\t\t\n\t// 牌描述：例红桃3,梅花2\n\tprivate String cardDesc;\n\n\n\n#### 1.3 总结\n\n经过上边的标记，我们很容易将一张牌的模型进行数字化，例如：\n\n154——黑桃2\n\n151——红桃2\n\n83——梅花8\n\n这样154>151，同样黑桃2大于红桃2\n\n151>83，同样红桃2大于梅花8\n\n\n\n### 2. 构建一副牌\n\n构建一副牌可以从花色、牌面大小、牌的名称、牌的描述四个方面进行构建，其中花色（4——黑桃，3——梅花，2——方片，1——红桃），大小为：使用数字3到15表示真实牌的3到2，牌名称即牌大小和花色组成的数字大小，描述是通用的牌的叫法，比如：154——黑桃2 牌名称为154 描述为 黑桃2\n\n这里需要主要的是：**斗地主中存在王，大小王，共54张牌，而在我们的TienLen游戏中不存在大小王，只有52张牌**\n\n\t/**\n     * 初始化牌\n     * @return\n     */\n    public List<CardInfo> initCard() {\n        List<CardInfo> cardList = new ArrayList<CardInfo>();\n        for (int i = 1; i < 5; i++) {\n            for (int j = 3; j < 16; j++) {\n                CardInfo cardInfo = new CardInfo();\n                cardInfo.setCardNumber(j);\n                cardInfo.setCardColor(i);\n                cardInfo.setCardName(j * 10 + i + \"\");\n                switch (i) {\n                    case 1:\n                        cardInfo.setCardDesc(\"红桃\" + j);\n                        break;\n                    case 2:\n                        cardInfo.setCardDesc(\"方片\" + j);\n                        break;\n                    case 3:\n                        cardInfo.setCardDesc(\"梅花\" + j);\n                        break;\n                    case 4:\n                        cardInfo.setCardDesc(\"黑桃\" + j);\n                        break;\n                }\n                cardList.add(cardInfo);\n            }\n        }\n        return cardList;\n    }\n\n\n\n### 3. 洗牌\n\n洗牌只需要将牌进行打乱即可，这里考虑使用随机数进行交换，模拟洗牌，但是这样的算法存在缺陷，即有可能洗完以后，牌仍然保持原样\n\n\t/**\n     * 洗牌\n     *\n     * @param cardList 初始化号的牌\n     * @return\n     */\n    public List<CardInfo> washCard(List<CardInfo> cardList) {\n        List<CardInfo> randomCardList = cardList;\n        for (int i = 0; i < 100; i++) {\n            Random random = new Random();\n            // 找出52以内的随机数，然后交换位置\n            int a = random.nextInt(52);\n            int b = random.nextInt(52);\n            CardInfo cardInfoTemp = randomCardList.get(a);\n            randomCardList.set(a, randomCardList.get(b));\n            randomCardList.set(b, cardInfoTemp);\n        }\n\n        return randomCardList;\n    }\n \n### 4. 发牌\n\n发牌算法很简单，将已经洗好的52张牌，顺序发给各个玩家。这里我们与斗地主区别在于，我们这里一共有四个玩家，因此需要将牌分为4份：\n\n\t/**\n     * 发牌\n     *\n     * @param cardList 洗好的牌\n     * @return\n     */\n    public List<CardInfo>[] handCard(List<CardInfo> cardList) {\n        List<CardInfo> playerCardList[] = new Vector[4];\n        for (int i = 0; i < 4; i++) {\n            playerCardList[i] = new Vector<CardInfo>();\n        }\n        for (int j = 0; j < 52; j++) {\n            switch (j % 4) {\n                case 0:\n                    playerCardList[0].add(cardList.get(j));\n                    break;\n                case 1:\n                    playerCardList[1].add(cardList.get(j));\n                    break;\n                case 2:\n                    playerCardList[2].add(cardList.get(j));\n                    break;\n                case 3:\n                    playerCardList[3].add(cardList.get(j));\n                    break;\n                default:\n                    break;\n            }\n        }\n        return playerCardList;\n    }\n\n\n### 5. 捋牌\n\n也就是对牌进行排序，从大到小进行排序，这样出来的牌，便于往后进行分类等运算。\n\n\t/**\n     * 排序，按照从大到小的顺序进行排\n     *\n     * @param cardList\n     * @return\n     */\n    public List<CardInfo> sortCard(List<CardInfo> cardList) {\n        Collections.sort(cardList, new Comparator<CardInfo>() {\n            @Override\n            public int compare(CardInfo cardInfo1, CardInfo cardInfo2) {\n                int cardNum1 = Integer.valueOf(cardInfo1.getCardName());\n                int cardNum2 = Integer.valueOf(cardInfo2.getCardName());\n\n                if (cardNum1 > cardNum2) {\n                    return -1;\n                } else if (cardNum1 == cardNum2) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            }\n        });\n        return cardList;\n    }\n\n\n### 6. 出牌\n   出牌时，应该根据规则进行出牌，首先、判断用户所选择的牌是否符合规则，即是否是单牌、对子、三张、链子、炸弹等\n\n#### 6.1 单张牌\n\n获取单张牌的算法很简单，任意一张牌，都可以作为单张牌使用，因此只需要将所有的牌都添加到单张牌的列表中即可。\n\t\n\t /***\n     * 获取单张牌\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get1(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all1List = new ArrayList<>();\n        List<CardInfo> cardList;\n        sortCardAsc(mCardList);\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            cardList = new ArrayList<>();\n            cardList.add(mCardList.get(i));\n            all1List.add(cardList);\n        }\n\n        return all1List;\n    }\n\n#### 6.2 对子\n\n获取对子时，需要注意，因为我们TienLen游戏的规则中，不仅需要比较牌面点数大小，还需要比较花色大小，所以，同样4个2，可能组合成多种对子，且大小不一样，比如黑桃2和梅花2，比如红桃2和方片2\n\n\t /**\n     * 获取对子\n     * 这里对i+1 i+2 i+3分别和第i张牌进行对比，\n     * 举例：比如四个2，可以黑桃2和方片2一对，也可以是梅花2和红桃2一对\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get11(List<CardInfo> mCardList) {\n\t\t// 先对牌进行排序\n        sortCardAsc(mCardList);\n        List<List<CardInfo>> all11CardList = new ArrayList<>();\n        List<CardInfo> cardList;\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 1 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 1).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                all11CardList.add(cardList);\n            }\n            if (i + 2 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 2));\n                all11CardList.add(cardList);\n            }\n            if (i + 3 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 3));\n                all11CardList.add(cardList);\n            }\n        }\n        return all11CardList;\n    }\n\n\n### 6.3 三个\n在斗地主的规则中，好像也是三个也可以一起出，但是需要带一个或者一对，我们TienLen游戏中不需要带，也不能带，可以直接出，比如三个三，三个四，这样的牌，获取的算法和上边对子的获取算法一致\n\n\t /***\n     * 获取三个\n     * 算法个获取对子的算法类似\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get111(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all111List = new ArrayList<>();\n        List<CardInfo> cardList;\n\t\t// 先对牌进行排序\n        sortCardAsc(mCardList);\n\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 2 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                cardList.add(mCardList.get(i + 2));\n                all111List.add(cardList);\n            }\n        }\n        return all111List;\n    }\n\n\n### 6.4 炸弹\n\n炸弹，不论在斗地主中还是我们现在做的TienLen中，都是一样的作用，一样的获取方法，和获取对子，三个的方法一致，这里直接上代码：\n\n\t/***\n     * 获取炸弹\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get1111(List<CardInfo> mCardList) {\n        List<List<CardInfo>> all1111List = new ArrayList<>();\n        List<CardInfo> cardList;\n\n        for (int i = 0, length = mCardList.size(); i < length; i++) {\n            if (i + 3 < length\n                    && mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) {\n                cardList = new ArrayList<>();\n                cardList.add(mCardList.get(i));\n                cardList.add(mCardList.get(i + 1));\n                cardList.add(mCardList.get(i + 2));\n                cardList.add(mCardList.get(i + 3));\n                all1111List.add(cardList);\n            }\n        }\n        return all1111List;\n    }\n\n\n### 6.5 链子\n\n终于说到了这个牌型——链子，链子在不同的玩法中，可以出不同的长度，在我们的TienLen中最少是三联，这里获取时，先对手牌进行排序，排好序后，进行遍历，找到能和当前牌连接起来的，且牌长度大于3的，均属于链子：\n\n\t/**\n     * 获取链子\n     *\n     * @param mCardList\n     * @return\n     */\n    public List<List<CardInfo>> get123(List<CardInfo> mCardList) {\n        // 链子长度必须大于3,即最少出3连\n        if (mCardList.size() < 3) {\n            return null;\n        }\n        // 构建返回数据\n        List<CardInfo> tempCardList = new ArrayList<>();\n        List<List<CardInfo>> all123List = new ArrayList<>();\n\n        // 先去掉2\n        for (int i = 0; i < mCardList.size(); i++) {\n            if (mCardList.get(i).getCardNumber() != 15) {\n                tempCardList.add(mCardList.get(i));\n            }\n        }\n        // 重新进行排序\n        sortCardAsc(tempCardList);\n\n        for (int i = 0; i < tempCardList.size(); i++) {\n            CardInfo tempCardInfo = tempCardList.get(i);\n            List<CardInfo> cardList = new ArrayList<>();\n            cardList.add(tempCardInfo);\n            List<CardInfo> cardListTempAfter = new ArrayList<>();\n            for (int j = i + 1; j < tempCardList.size(); j++) {\n                // 判断当前牌是否个下一个牌能连起来（当前牌是5，当下一个是5+1=6时，即连起来了，当连起来大于3个牌时，即可以认为是一连）\n                if ((tempCardInfo.getCardNumber() + 1) == tempCardList.get(j).getCardNumber()) {\n                    cardListTempAfter.clear();\n                    cardListTempAfter.addAll(cardList);\n                    cardList.add(tempCardList.get(j));\n                    tempCardInfo = tempCardList.get(j);\n                    if (cardList.size() >= 3) {\n                        List<CardInfo> cardListTemp = new ArrayList<>();\n                        cardListTemp.addAll(cardList);\n                        all123List.add(cardList);\n\n                        cardList = new ArrayList<>();\n                        cardList.addAll(cardListTemp);\n                    }\n                } else if (tempCardInfo.getCardNumber() == tempCardList.get(j).getCardNumber()\n                        && tempCardInfo.getCardNumber() != tempCardList.get(i).getCardNumber()) {\n                    List<CardInfo> cardListTemp = new ArrayList<>();\n                    cardListTemp.addAll(cardListTempAfter);\n                    if (cardListTemp.size() > 0\n                            && cardListTemp.get(cardListTemp.size() - 1).getCardNumber() != tempCardList\n                            .get(j).getCardNumber()) {\n                        cardListTempAfter.add(tempCardList.get(j));\n                        if (cardListTempAfter.size() >= 3) {\n                            all123List.add(cardListTempAfter);\n                            cardListTempAfter = new ArrayList<>();\n                            cardListTempAfter.addAll(cardListTemp);\n                        }\n                    }\n                }\n            }\n        }\n        return all123List;\n    }\n\n\n### 6.6 双链\n\n\n双链，也就是经常说的飞机带翅膀，双链的前提是对子，只有存在对子的情况下，才能找出来双链，所以，其算法也是一样，先找到所有的对子，然后去掉2，进行排序，再按照找链子的方法进行找，这样返回的就是双链。\n\n\t /***\n     * 获取飞机\n     *\n     * @param mCardInfoList\n     * @return\n     */\n    public List<List<CardInfo>> get112233(List<CardInfo> mCardInfoList) {\n        int length = mCardInfoList.size();\n        // 双链最少为3连，所以最少六张牌\n        if (length < 6) {\n            return null;\n        }\n        // 保存所有的对子\n        List<CardInfo> tempList = new ArrayList<>();\n        // 保存所有不包含2的对子\n        List<CardInfo> apairTempList = new ArrayList<>();\n        // 防止重复添加\n        List<Integer> integerList = new Vector<>();\n\n        // 返回结果\n        List<List<CardInfo>> all112233List = new ArrayList<>();\n\n        // 存储单个双对链子\n        List<CardInfo> cardList;\n\n        // 先获取所有的对子\n        for (int i = 0; i < length; i++) {\n            if (i + 1 < length\n                    && mCardInfoList.get(i).getCardNumber() == mCardInfoList.get(i + 1)\n                    .getCardNumber()) {\n                tempList.add(mCardInfoList.get(i));\n                tempList.add(mCardInfoList.get(i + 1));\n                i = i + 1;\n            }\n        }\n        // 排序\n        sortCardAsc(tempList);\n\n        // 去除对2和相同的\n        for (int i = 0, tempLength = tempList.size(); i < tempLength; i++) {\n            if (!integerList.contains(Integer.valueOf(tempList.get(i).getCardNumber()))) {\n                apairTempList.add(tempList.get(i));\n                integerList.add(Integer.valueOf(tempList.get(i).getCardNumber()));\n            }\n        }\n\n        // 双对的链子最少三联\n        if (apairTempList.size() < 3) {\n            return null;\n        }\n\n        // 对之前拿到的对子List进行排序，正序\n        sortCardAsc(tempList);\n\n        // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n        List<List<CardInfo>> get123TempList = get123(apairTempList);\n\n        for (int j = 0; j < get123TempList.size(); j++) {\n            List<CardInfo> list123 = get123TempList.get(j);\n            sortCardAsc(list123);\n            for (int k = 0; k < tempList.size(); k++) {\n                if (tempList.get(k).getCardName().equals(list123.get(0).getCardName())) {\n                    cardList = new ArrayList<>();\n                    for (int l = k; l < list123.size() * 2 + k; l++) {\n                        cardList.add(tempList.get(l));\n                    }\n                    all112233List.add(cardList);\n                }\n            }\n        }\n        return all112233List;\n    }\n\n\n\n### 7 出牌\n\n出牌有两种情况，一种是手动选择的，一种是通过提示，自动出牌的。对于手动选择的，需要根据自己当前是否有首先出牌权，进行校验，\n\t\n1. 如果当前是自己的局，也就是说，上轮出牌的过程中，自己最大，这局自己首先出，所以只需要校验自己手动选择的牌是否符合规则。\n2. 如果当前是别人的局，也就是说，自己当前跟着别人的局出牌，只能和别人的类型一致，且大于对方，所以需要校验选择的牌类型是否和别人的一致，再校验是否比别人的大，才能出\n\n对于通过提示出牌的，只适合第二种情况，也就是说，别人出牌，然后自己管，系统会进行提示\n\n\n\n#### 7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\n\n\t /**\n     * 获取出牌类型\n     * \n     * @param outCard\n     * @return\n     */\n    public OutCardType getOutCardType(List<CardInfo> outCard) {\n        if (outCard != null) {\n            int cardLength = outCard.size();\n\n            if (outCard.get(0).getCardNumber() == outCard.get(cardLength - 1).getCardNumber()) {\n                switch (cardLength) {\n                    case 1:\n                        // 单牌\n                        return OutCardType.type1;\n                    case 2:\n                        // 对子\n                        return OutCardType.type11;\n                    case 3:\n                        // 三个\n                        return OutCardType.type111;\n                    case 4:\n                        // 炸弹\n                        return OutCardType.type1111;\n                }\n            }\n\n            // 判断链子，最少三张\n            if (outCard.size() >= 3) {\n                List<CardInfo> tempCardList = new ArrayList<>();\n\n                // 先去掉2\n                for (int i = 0; i < outCard.size(); i++) {\n                    if (outCard.get(i).getCardNumber() != 15) {\n                        tempCardList.add(outCard.get(i));\n                    }\n                }\n                // 重新进行排序\n                sortCardAsc(tempCardList);\n\n                // 判断是否为链子\n                List<List<CardInfo>> get123 = get123(outCard);\n                if (get123 != null && get123.size() > 0) {\n                    for (List<CardInfo> list : get123) {\n                        if (list.size() == outCard.size()) {\n                            return OutCardType.type123;\n                        }\n                    }\n\n                }\n\n                // 双对至少6张\n                if (outCard.size() >= 6) {\n                    int length = outCard.size();\n                    // 保存所有的对子\n                    List<CardInfo> tempList = new ArrayList<>();\n                    // 保存所有不包含2的对子\n                    List<CardInfo> apairTempList = new ArrayList<>();\n                    // 防止重复添加\n                    List<Integer> integerList = new Vector<>();\n\n                    // 先获取所有的对子\n                    for (int i = 0; i < length; i++) {\n                        if (i + 1 < length\n                                && outCard.get(i).getCardNumber() == outCard.get(i + 1)\n                                .getCardNumber()) {\n                            tempList.add(outCard.get(i));\n                            tempList.add(outCard.get(i + 1));\n                            i = i + 1;\n                        }\n                    }\n\n                    // 所有的牌均为对子\n                    if (tempList.size() == outCard.size()) {\n                        // 去除对2\n                        for (int i = 0, tempLength = tempList.size(); i < tempLength; i++) {\n                            if (integerList.indexOf(outCard.get(i).getCardNumber()) < 0\n                                    && tempList.get(i).getCardNumber() != 15) {\n                                apairTempList.add(tempList.get(i));\n                                integerList.add(tempList.get(i).getCardNumber());\n                            }\n                            i = i + 1;\n                        }\n\n                        // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n                        List<List<CardInfo>> get123TempList = get123(apairTempList);\n                        for (int i = 0; i < get123TempList.size(); i++) {\n                            if (get123TempList.get(i).size() == length / 2) {\n                                return OutCardType.type112233;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return OutCardType.type0;\n    }\n只有当选中牌的类型是已知类型，才能第一步判断出是否可以出牌，下一步则需要根据当前是不是自己轮，判断需要不需要压对方的牌\n\n\n#### 7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\n\n\t\n    /**\n     * 当上家出牌后，判断自己是否可以出牌\n     *\n     * @param outCard\n     * @param mAllCard\n     * @param mSelectCard\n     * @return\n     */\n    public boolean whetherCanPlay(List<CardInfo> outCard, List<CardInfo> mAllCard,\n                                  List<CardInfo> mSelectCard) {\n        boolean isCardCanPlay = false;\n\n        // 获取对手牌型\n        OutCardType outCardType = getOutCardType(outCard);\n        OutCardType outCardTypeMy = getOutCardType(mSelectCard);\n        sortCard(outCard);\n        // 先对牌进行排序\n        sortCard(mSelectCard);\n\n        // 首先判断牌的张数是否一样\n        if (outCard.size() == mSelectCard.size() && outCardType == outCardTypeMy) {\n            int outCardName = Integer.valueOf(outCard.get(0).getCardName());\n            int mSelectCardName = Integer.valueOf(mSelectCard.get(0).getCardName());\n\n            // 相同，属于同一级牌之间压\n            switch (outCardType) {\n                case type1:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type11:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type111:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type1111:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type123:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                case type112233:\n                    if (mSelectCardName > outCardName) {\n                        isCardCanPlay = true;\n                    }\n                    break;\n                default:\n                    isCardCanPlay = false;\n                    break;\n            }\n        } else {\n            // 当张数不一致时，有两种情况，即炸弹压2和连着的双对压对2\n            if (outCard.size() == 1 && mSelectCard.size() == 4) {\n                // 当别人为单个2且自己的Type为炸弹时\n                if (outCard.get(0).getCardNumber() == 15\n                        && getOutCardType(mSelectCard) == OutCardType.type1111) {\n                    isCardCanPlay = true;\n                }\n            } else {\n                // 别人出牌为一对2，自己应该用33-44-55-66或者55-66-77-88压\n                if (outCard.size() == 2 && mSelectCard.size() >= 8) {\n                    if (outCard.get(0).getCardNumber() == 15\n                            && getOutCardType(mSelectCard) == OutCardType.type112233) {\n                        isCardCanPlay = true;\n                    }\n                } else {\n                    isCardCanPlay = false;\n                }\n            }\n        }\n        return isCardCanPlay;\n    }\n\n\t\n这里边包含了部分规则，比如同样的牌类型，比较大小，同时33445566可以压对二这样的规则\n\n\n\n### 8. 提示\n\n 提示算法比较简单，先获取上家出牌的类型，再获取自己手牌中对应类型的列表，逐个进行比较，直到找到合适的\n\n\n### AI\n\n这里除了上述洗牌、发牌、出牌等算法之外，还有单机模式的AI算法，回头有空了整理下，我再发上来吧。\n\n\n### 总结\n\n在这片文章中，只是写了一个针对斗地主类类游戏的牌的算法，包含了牌模型构建、洗牌、发牌、出牌等算法的实现，虽然游戏规则不同，但是思路大同小异，希望有需要的同学可以参考下。","slug":"20170710TienLen游戏算法——斗地主算法","published":1,"updated":"2020-12-09T06:34:56.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278juru001hb3t1644q7z4k","content":"<p>最近需要做一个类似于斗地主的游戏，由于只是类似斗地主的游戏，因此，规则方面和斗地主存在一些不同，但是在算法上，也是大同小异，现对该游戏算法进行总结：</p>\n<h3 id=\"1-定义牌对象\"><a href=\"#1-定义牌对象\" class=\"headerlink\" title=\"1.定义牌对象\"></a>1.定义牌对象</h3><p> 首先需要对牌对象进行定义，正常斗地主玩法下，一张牌只有一个属性，就是数字大小，而不管花色，而在我们的游戏中，同样数字的牌，不同花色之间还可以比较，因此，我们的牌一共有两个基本属性，分别为花色和大小。</p>\n<h4 id=\"1-1-规则\"><a href=\"#1-1-规则\" class=\"headerlink\" title=\"1.1 规则\"></a>1.1 规则</h4><p>对于花色，规则定义如下：黑桃&gt;梅花&gt;方片&gt;红桃</p>\n<p>对于数字，规则定义如下：2最大，3最小</p>\n<h4 id=\"1-2-建模\"><a href=\"#1-2-建模\" class=\"headerlink\" title=\"1.2 建模\"></a>1.2 建模</h4><p>我们将牌的牌面实际数字使用数字进行标记，使用数字3到15表示真实牌的3到2，其中11表示J，12表示Q，13表示K，14表示A，15表示2，其余数字分别代表真实牌面数字。</p>\n<p>将牌的牌面花色同样使用数字进行标记：根据从大到小，分别标记为：4——黑桃，3——梅花，2——方片，1——红桃。</p>\n<p>这样，对于一张牌的数字模型，使用以下公式进行标记：</p>\n<p>牌数字模型大小  &#x3D;  牌面数字模型大小 * 10 + 牌面花色模型大小</p>\n<pre><code>// 牌号点数：如3~J~A~2,使用3~15数字\nprivate int cardNumber;\n    \n// 牌色：如4红桃, 3方片, 2梅花, 1黑桃\nprivate int cardColor;\n    \n// 牌全称：例34是红桃3,152是梅花2,113是方片J\nprivate String cardName;\n    \n// 牌描述：例红桃3,梅花2\nprivate String cardDesc;\n</code></pre>\n<h4 id=\"1-3-总结\"><a href=\"#1-3-总结\" class=\"headerlink\" title=\"1.3 总结\"></a>1.3 总结</h4><p>经过上边的标记，我们很容易将一张牌的模型进行数字化，例如：</p>\n<p>154——黑桃2</p>\n<p>151——红桃2</p>\n<p>83——梅花8</p>\n<p>这样154&gt;151，同样黑桃2大于红桃2</p>\n<p>151&gt;83，同样红桃2大于梅花8</p>\n<h3 id=\"2-构建一副牌\"><a href=\"#2-构建一副牌\" class=\"headerlink\" title=\"2. 构建一副牌\"></a>2. 构建一副牌</h3><p>构建一副牌可以从花色、牌面大小、牌的名称、牌的描述四个方面进行构建，其中花色（4——黑桃，3——梅花，2——方片，1——红桃），大小为：使用数字3到15表示真实牌的3到2，牌名称即牌大小和花色组成的数字大小，描述是通用的牌的叫法，比如：154——黑桃2 牌名称为154 描述为 黑桃2</p>\n<p>这里需要主要的是：<strong>斗地主中存在王，大小王，共54张牌，而在我们的TienLen游戏中不存在大小王，只有52张牌</strong></p>\n<pre><code>/**\n * 初始化牌\n * @return\n */\npublic List&lt;CardInfo&gt; initCard() &#123;\n    List&lt;CardInfo&gt; cardList = new ArrayList&lt;CardInfo&gt;();\n    for (int i = 1; i &lt; 5; i++) &#123;\n        for (int j = 3; j &lt; 16; j++) &#123;\n            CardInfo cardInfo = new CardInfo();\n            cardInfo.setCardNumber(j);\n            cardInfo.setCardColor(i);\n            cardInfo.setCardName(j * 10 + i + &quot;&quot;);\n            switch (i) &#123;\n                case 1:\n                    cardInfo.setCardDesc(&quot;红桃&quot; + j);\n                    break;\n                case 2:\n                    cardInfo.setCardDesc(&quot;方片&quot; + j);\n                    break;\n                case 3:\n                    cardInfo.setCardDesc(&quot;梅花&quot; + j);\n                    break;\n                case 4:\n                    cardInfo.setCardDesc(&quot;黑桃&quot; + j);\n                    break;\n            &#125;\n            cardList.add(cardInfo);\n        &#125;\n    &#125;\n    return cardList;\n&#125;\n</code></pre>\n<h3 id=\"3-洗牌\"><a href=\"#3-洗牌\" class=\"headerlink\" title=\"3. 洗牌\"></a>3. 洗牌</h3><p>洗牌只需要将牌进行打乱即可，这里考虑使用随机数进行交换，模拟洗牌，但是这样的算法存在缺陷，即有可能洗完以后，牌仍然保持原样</p>\n<pre><code>/**\n * 洗牌\n *\n * @param cardList 初始化号的牌\n * @return\n */\npublic List&lt;CardInfo&gt; washCard(List&lt;CardInfo&gt; cardList) &#123;\n    List&lt;CardInfo&gt; randomCardList = cardList;\n    for (int i = 0; i &lt; 100; i++) &#123;\n        Random random = new Random();\n        // 找出52以内的随机数，然后交换位置\n        int a = random.nextInt(52);\n        int b = random.nextInt(52);\n        CardInfo cardInfoTemp = randomCardList.get(a);\n        randomCardList.set(a, randomCardList.get(b));\n        randomCardList.set(b, cardInfoTemp);\n    &#125;\n\n    return randomCardList;\n&#125;\n</code></pre>\n<h3 id=\"4-发牌\"><a href=\"#4-发牌\" class=\"headerlink\" title=\"4. 发牌\"></a>4. 发牌</h3><p>发牌算法很简单，将已经洗好的52张牌，顺序发给各个玩家。这里我们与斗地主区别在于，我们这里一共有四个玩家，因此需要将牌分为4份：</p>\n<pre><code>/**\n * 发牌\n *\n * @param cardList 洗好的牌\n * @return\n */\npublic List&lt;CardInfo&gt;[] handCard(List&lt;CardInfo&gt; cardList) &#123;\n    List&lt;CardInfo&gt; playerCardList[] = new Vector[4];\n    for (int i = 0; i &lt; 4; i++) &#123;\n        playerCardList[i] = new Vector&lt;CardInfo&gt;();\n    &#125;\n    for (int j = 0; j &lt; 52; j++) &#123;\n        switch (j % 4) &#123;\n            case 0:\n                playerCardList[0].add(cardList.get(j));\n                break;\n            case 1:\n                playerCardList[1].add(cardList.get(j));\n                break;\n            case 2:\n                playerCardList[2].add(cardList.get(j));\n                break;\n            case 3:\n                playerCardList[3].add(cardList.get(j));\n                break;\n            default:\n                break;\n        &#125;\n    &#125;\n    return playerCardList;\n&#125;\n</code></pre>\n<h3 id=\"5-捋牌\"><a href=\"#5-捋牌\" class=\"headerlink\" title=\"5. 捋牌\"></a>5. 捋牌</h3><p>也就是对牌进行排序，从大到小进行排序，这样出来的牌，便于往后进行分类等运算。</p>\n<pre><code>/**\n * 排序，按照从大到小的顺序进行排\n *\n * @param cardList\n * @return\n */\npublic List&lt;CardInfo&gt; sortCard(List&lt;CardInfo&gt; cardList) &#123;\n    Collections.sort(cardList, new Comparator&lt;CardInfo&gt;() &#123;\n        @Override\n        public int compare(CardInfo cardInfo1, CardInfo cardInfo2) &#123;\n            int cardNum1 = Integer.valueOf(cardInfo1.getCardName());\n            int cardNum2 = Integer.valueOf(cardInfo2.getCardName());\n\n            if (cardNum1 &gt; cardNum2) &#123;\n                return -1;\n            &#125; else if (cardNum1 == cardNum2) &#123;\n                return 0;\n            &#125; else &#123;\n                return 1;\n            &#125;\n        &#125;\n    &#125;);\n    return cardList;\n&#125;\n</code></pre>\n<h3 id=\"6-出牌\"><a href=\"#6-出牌\" class=\"headerlink\" title=\"6. 出牌\"></a>6. 出牌</h3><p>   出牌时，应该根据规则进行出牌，首先、判断用户所选择的牌是否符合规则，即是否是单牌、对子、三张、链子、炸弹等</p>\n<h4 id=\"6-1-单张牌\"><a href=\"#6-1-单张牌\" class=\"headerlink\" title=\"6.1 单张牌\"></a>6.1 单张牌</h4><p>获取单张牌的算法很简单，任意一张牌，都可以作为单张牌使用，因此只需要将所有的牌都添加到单张牌的列表中即可。</p>\n<pre><code> /***\n * 获取单张牌\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get1(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all1List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    sortCardAsc(mCardList);\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        cardList = new ArrayList&lt;&gt;();\n        cardList.add(mCardList.get(i));\n        all1List.add(cardList);\n    &#125;\n\n    return all1List;\n&#125;\n</code></pre>\n<h4 id=\"6-2-对子\"><a href=\"#6-2-对子\" class=\"headerlink\" title=\"6.2 对子\"></a>6.2 对子</h4><p>获取对子时，需要注意，因为我们TienLen游戏的规则中，不仅需要比较牌面点数大小，还需要比较花色大小，所以，同样4个2，可能组合成多种对子，且大小不一样，比如黑桃2和梅花2，比如红桃2和方片2</p>\n<pre><code> /**\n * 获取对子\n * 这里对i+1 i+2 i+3分别和第i张牌进行对比，\n * 举例：比如四个2，可以黑桃2和方片2一对，也可以是梅花2和红桃2一对\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get11(List&lt;CardInfo&gt; mCardList) &#123;\n    // 先对牌进行排序\n    sortCardAsc(mCardList);\n    List&lt;List&lt;CardInfo&gt;&gt; all11CardList = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 1 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 1).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            all11CardList.add(cardList);\n        &#125;\n        if (i + 2 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 2));\n            all11CardList.add(cardList);\n        &#125;\n        if (i + 3 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 3));\n            all11CardList.add(cardList);\n        &#125;\n    &#125;\n    return all11CardList;\n&#125;\n</code></pre>\n<h3 id=\"6-3-三个\"><a href=\"#6-3-三个\" class=\"headerlink\" title=\"6.3 三个\"></a>6.3 三个</h3><p>在斗地主的规则中，好像也是三个也可以一起出，但是需要带一个或者一对，我们TienLen游戏中不需要带，也不能带，可以直接出，比如三个三，三个四，这样的牌，获取的算法和上边对子的获取算法一致</p>\n<pre><code> /***\n * 获取三个\n * 算法个获取对子的算法类似\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get111(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all111List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    // 先对牌进行排序\n    sortCardAsc(mCardList);\n\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 2 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            cardList.add(mCardList.get(i + 2));\n            all111List.add(cardList);\n        &#125;\n    &#125;\n    return all111List;\n&#125;\n</code></pre>\n<h3 id=\"6-4-炸弹\"><a href=\"#6-4-炸弹\" class=\"headerlink\" title=\"6.4 炸弹\"></a>6.4 炸弹</h3><p>炸弹，不论在斗地主中还是我们现在做的TienLen中，都是一样的作用，一样的获取方法，和获取对子，三个的方法一致，这里直接上代码：</p>\n<pre><code>/***\n * 获取炸弹\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get1111(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all1111List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 3 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            cardList.add(mCardList.get(i + 2));\n            cardList.add(mCardList.get(i + 3));\n            all1111List.add(cardList);\n        &#125;\n    &#125;\n    return all1111List;\n&#125;\n</code></pre>\n<h3 id=\"6-5-链子\"><a href=\"#6-5-链子\" class=\"headerlink\" title=\"6.5 链子\"></a>6.5 链子</h3><p>终于说到了这个牌型——链子，链子在不同的玩法中，可以出不同的长度，在我们的TienLen中最少是三联，这里获取时，先对手牌进行排序，排好序后，进行遍历，找到能和当前牌连接起来的，且牌长度大于3的，均属于链子：</p>\n<pre><code>/**\n * 获取链子\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get123(List&lt;CardInfo&gt; mCardList) &#123;\n    // 链子长度必须大于3,即最少出3连\n    if (mCardList.size() &lt; 3) &#123;\n        return null;\n    &#125;\n    // 构建返回数据\n    List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();\n    List&lt;List&lt;CardInfo&gt;&gt; all123List = new ArrayList&lt;&gt;();\n\n    // 先去掉2\n    for (int i = 0; i &lt; mCardList.size(); i++) &#123;\n        if (mCardList.get(i).getCardNumber() != 15) &#123;\n            tempCardList.add(mCardList.get(i));\n        &#125;\n    &#125;\n    // 重新进行排序\n    sortCardAsc(tempCardList);\n\n    for (int i = 0; i &lt; tempCardList.size(); i++) &#123;\n        CardInfo tempCardInfo = tempCardList.get(i);\n        List&lt;CardInfo&gt; cardList = new ArrayList&lt;&gt;();\n        cardList.add(tempCardInfo);\n        List&lt;CardInfo&gt; cardListTempAfter = new ArrayList&lt;&gt;();\n        for (int j = i + 1; j &lt; tempCardList.size(); j++) &#123;\n            // 判断当前牌是否个下一个牌能连起来（当前牌是5，当下一个是5+1=6时，即连起来了，当连起来大于3个牌时，即可以认为是一连）\n            if ((tempCardInfo.getCardNumber() + 1) == tempCardList.get(j).getCardNumber()) &#123;\n                cardListTempAfter.clear();\n                cardListTempAfter.addAll(cardList);\n                cardList.add(tempCardList.get(j));\n                tempCardInfo = tempCardList.get(j);\n                if (cardList.size() &gt;= 3) &#123;\n                    List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();\n                    cardListTemp.addAll(cardList);\n                    all123List.add(cardList);\n\n                    cardList = new ArrayList&lt;&gt;();\n                    cardList.addAll(cardListTemp);\n                &#125;\n            &#125; else if (tempCardInfo.getCardNumber() == tempCardList.get(j).getCardNumber()\n                    &amp;&amp; tempCardInfo.getCardNumber() != tempCardList.get(i).getCardNumber()) &#123;\n                List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();\n                cardListTemp.addAll(cardListTempAfter);\n                if (cardListTemp.size() &gt; 0\n                        &amp;&amp; cardListTemp.get(cardListTemp.size() - 1).getCardNumber() != tempCardList\n                        .get(j).getCardNumber()) &#123;\n                    cardListTempAfter.add(tempCardList.get(j));\n                    if (cardListTempAfter.size() &gt;= 3) &#123;\n                        all123List.add(cardListTempAfter);\n                        cardListTempAfter = new ArrayList&lt;&gt;();\n                        cardListTempAfter.addAll(cardListTemp);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return all123List;\n&#125;\n</code></pre>\n<h3 id=\"6-6-双链\"><a href=\"#6-6-双链\" class=\"headerlink\" title=\"6.6 双链\"></a>6.6 双链</h3><p>双链，也就是经常说的飞机带翅膀，双链的前提是对子，只有存在对子的情况下，才能找出来双链，所以，其算法也是一样，先找到所有的对子，然后去掉2，进行排序，再按照找链子的方法进行找，这样返回的就是双链。</p>\n<pre><code> /***\n * 获取飞机\n *\n * @param mCardInfoList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get112233(List&lt;CardInfo&gt; mCardInfoList) &#123;\n    int length = mCardInfoList.size();\n    // 双链最少为3连，所以最少六张牌\n    if (length &lt; 6) &#123;\n        return null;\n    &#125;\n    // 保存所有的对子\n    List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();\n    // 保存所有不包含2的对子\n    List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();\n    // 防止重复添加\n    List&lt;Integer&gt; integerList = new Vector&lt;&gt;();\n\n    // 返回结果\n    List&lt;List&lt;CardInfo&gt;&gt; all112233List = new ArrayList&lt;&gt;();\n\n    // 存储单个双对链子\n    List&lt;CardInfo&gt; cardList;\n\n    // 先获取所有的对子\n    for (int i = 0; i &lt; length; i++) &#123;\n        if (i + 1 &lt; length\n                &amp;&amp; mCardInfoList.get(i).getCardNumber() == mCardInfoList.get(i + 1)\n                .getCardNumber()) &#123;\n            tempList.add(mCardInfoList.get(i));\n            tempList.add(mCardInfoList.get(i + 1));\n            i = i + 1;\n        &#125;\n    &#125;\n    // 排序\n    sortCardAsc(tempList);\n\n    // 去除对2和相同的\n    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;\n        if (!integerList.contains(Integer.valueOf(tempList.get(i).getCardNumber()))) &#123;\n            apairTempList.add(tempList.get(i));\n            integerList.add(Integer.valueOf(tempList.get(i).getCardNumber()));\n        &#125;\n    &#125;\n\n    // 双对的链子最少三联\n    if (apairTempList.size() &lt; 3) &#123;\n        return null;\n    &#125;\n\n    // 对之前拿到的对子List进行排序，正序\n    sortCardAsc(tempList);\n\n    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);\n\n    for (int j = 0; j &lt; get123TempList.size(); j++) &#123;\n        List&lt;CardInfo&gt; list123 = get123TempList.get(j);\n        sortCardAsc(list123);\n        for (int k = 0; k &lt; tempList.size(); k++) &#123;\n            if (tempList.get(k).getCardName().equals(list123.get(0).getCardName())) &#123;\n                cardList = new ArrayList&lt;&gt;();\n                for (int l = k; l &lt; list123.size() * 2 + k; l++) &#123;\n                    cardList.add(tempList.get(l));\n                &#125;\n                all112233List.add(cardList);\n            &#125;\n        &#125;\n    &#125;\n    return all112233List;\n&#125;\n</code></pre>\n<h3 id=\"7-出牌\"><a href=\"#7-出牌\" class=\"headerlink\" title=\"7 出牌\"></a>7 出牌</h3><p>出牌有两种情况，一种是手动选择的，一种是通过提示，自动出牌的。对于手动选择的，需要根据自己当前是否有首先出牌权，进行校验，</p>\n<ol>\n<li>如果当前是自己的局，也就是说，上轮出牌的过程中，自己最大，这局自己首先出，所以只需要校验自己手动选择的牌是否符合规则。</li>\n<li>如果当前是别人的局，也就是说，自己当前跟着别人的局出牌，只能和别人的类型一致，且大于对方，所以需要校验选择的牌类型是否和别人的一致，再校验是否比别人的大，才能出</li>\n</ol>\n<p>对于通过提示出牌的，只适合第二种情况，也就是说，别人出牌，然后自己管，系统会进行提示</p>\n<h4 id=\"7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\"><a href=\"#7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\" class=\"headerlink\" title=\"7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\"></a>7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出</h4><pre><code> /**\n * 获取出牌类型\n * \n * @param outCard\n * @return\n */\npublic OutCardType getOutCardType(List&lt;CardInfo&gt; outCard) &#123;\n    if (outCard != null) &#123;\n        int cardLength = outCard.size();\n\n        if (outCard.get(0).getCardNumber() == outCard.get(cardLength - 1).getCardNumber()) &#123;\n            switch (cardLength) &#123;\n                case 1:\n                    // 单牌\n                    return OutCardType.type1;\n                case 2:\n                    // 对子\n                    return OutCardType.type11;\n                case 3:\n                    // 三个\n                    return OutCardType.type111;\n                case 4:\n                    // 炸弹\n                    return OutCardType.type1111;\n            &#125;\n        &#125;\n\n        // 判断链子，最少三张\n        if (outCard.size() &gt;= 3) &#123;\n            List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();\n\n            // 先去掉2\n            for (int i = 0; i &lt; outCard.size(); i++) &#123;\n                if (outCard.get(i).getCardNumber() != 15) &#123;\n                    tempCardList.add(outCard.get(i));\n                &#125;\n            &#125;\n            // 重新进行排序\n            sortCardAsc(tempCardList);\n\n            // 判断是否为链子\n            List&lt;List&lt;CardInfo&gt;&gt; get123 = get123(outCard);\n            if (get123 != null &amp;&amp; get123.size() &gt; 0) &#123;\n                for (List&lt;CardInfo&gt; list : get123) &#123;\n                    if (list.size() == outCard.size()) &#123;\n                        return OutCardType.type123;\n                    &#125;\n                &#125;\n\n            &#125;\n\n            // 双对至少6张\n            if (outCard.size() &gt;= 6) &#123;\n                int length = outCard.size();\n                // 保存所有的对子\n                List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();\n                // 保存所有不包含2的对子\n                List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();\n                // 防止重复添加\n                List&lt;Integer&gt; integerList = new Vector&lt;&gt;();\n\n                // 先获取所有的对子\n                for (int i = 0; i &lt; length; i++) &#123;\n                    if (i + 1 &lt; length\n                            &amp;&amp; outCard.get(i).getCardNumber() == outCard.get(i + 1)\n                            .getCardNumber()) &#123;\n                        tempList.add(outCard.get(i));\n                        tempList.add(outCard.get(i + 1));\n                        i = i + 1;\n                    &#125;\n                &#125;\n\n                // 所有的牌均为对子\n                if (tempList.size() == outCard.size()) &#123;\n                    // 去除对2\n                    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;\n                        if (integerList.indexOf(outCard.get(i).getCardNumber()) &lt; 0\n                                &amp;&amp; tempList.get(i).getCardNumber() != 15) &#123;\n                            apairTempList.add(tempList.get(i));\n                            integerList.add(tempList.get(i).getCardNumber());\n                        &#125;\n                        i = i + 1;\n                    &#125;\n\n                    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n                    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);\n                    for (int i = 0; i &lt; get123TempList.size(); i++) &#123;\n                        if (get123TempList.get(i).size() == length / 2) &#123;\n                            return OutCardType.type112233;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return OutCardType.type0;\n&#125;\n</code></pre>\n<p>只有当选中牌的类型是已知类型，才能第一步判断出是否可以出牌，下一步则需要根据当前是不是自己轮，判断需要不需要压对方的牌</p>\n<h4 id=\"7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\"><a href=\"#7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\" class=\"headerlink\" title=\"7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\"></a>7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大</h4><pre><code>/**\n * 当上家出牌后，判断自己是否可以出牌\n *\n * @param outCard\n * @param mAllCard\n * @param mSelectCard\n * @return\n */\npublic boolean whetherCanPlay(List&lt;CardInfo&gt; outCard, List&lt;CardInfo&gt; mAllCard,\n                              List&lt;CardInfo&gt; mSelectCard) &#123;\n    boolean isCardCanPlay = false;\n\n    // 获取对手牌型\n    OutCardType outCardType = getOutCardType(outCard);\n    OutCardType outCardTypeMy = getOutCardType(mSelectCard);\n    sortCard(outCard);\n    // 先对牌进行排序\n    sortCard(mSelectCard);\n\n    // 首先判断牌的张数是否一样\n    if (outCard.size() == mSelectCard.size() &amp;&amp; outCardType == outCardTypeMy) &#123;\n        int outCardName = Integer.valueOf(outCard.get(0).getCardName());\n        int mSelectCardName = Integer.valueOf(mSelectCard.get(0).getCardName());\n\n        // 相同，属于同一级牌之间压\n        switch (outCardType) &#123;\n            case type1:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type11:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type111:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type1111:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type123:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type112233:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            default:\n                isCardCanPlay = false;\n                break;\n        &#125;\n    &#125; else &#123;\n        // 当张数不一致时，有两种情况，即炸弹压2和连着的双对压对2\n        if (outCard.size() == 1 &amp;&amp; mSelectCard.size() == 4) &#123;\n            // 当别人为单个2且自己的Type为炸弹时\n            if (outCard.get(0).getCardNumber() == 15\n                    &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type1111) &#123;\n                isCardCanPlay = true;\n            &#125;\n        &#125; else &#123;\n            // 别人出牌为一对2，自己应该用33-44-55-66或者55-66-77-88压\n            if (outCard.size() == 2 &amp;&amp; mSelectCard.size() &gt;= 8) &#123;\n                if (outCard.get(0).getCardNumber() == 15\n                        &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type112233) &#123;\n                    isCardCanPlay = true;\n                &#125;\n            &#125; else &#123;\n                isCardCanPlay = false;\n            &#125;\n        &#125;\n    &#125;\n    return isCardCanPlay;\n&#125;\n</code></pre>\n<p>这里边包含了部分规则，比如同样的牌类型，比较大小，同时33445566可以压对二这样的规则</p>\n<h3 id=\"8-提示\"><a href=\"#8-提示\" class=\"headerlink\" title=\"8. 提示\"></a>8. 提示</h3><p> 提示算法比较简单，先获取上家出牌的类型，再获取自己手牌中对应类型的列表，逐个进行比较，直到找到合适的</p>\n<h3 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h3><p>这里除了上述洗牌、发牌、出牌等算法之外，还有单机模式的AI算法，回头有空了整理下，我再发上来吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这片文章中，只是写了一个针对斗地主类类游戏的牌的算法，包含了牌模型构建、洗牌、发牌、出牌等算法的实现，虽然游戏规则不同，但是思路大同小异，希望有需要的同学可以参考下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近需要做一个类似于斗地主的游戏，由于只是类似斗地主的游戏，因此，规则方面和斗地主存在一些不同，但是在算法上，也是大同小异，现对该游戏算法进行总结：</p>\n<h3 id=\"1-定义牌对象\"><a href=\"#1-定义牌对象\" class=\"headerlink\" title=\"1.定义牌对象\"></a>1.定义牌对象</h3><p> 首先需要对牌对象进行定义，正常斗地主玩法下，一张牌只有一个属性，就是数字大小，而不管花色，而在我们的游戏中，同样数字的牌，不同花色之间还可以比较，因此，我们的牌一共有两个基本属性，分别为花色和大小。</p>\n<h4 id=\"1-1-规则\"><a href=\"#1-1-规则\" class=\"headerlink\" title=\"1.1 规则\"></a>1.1 规则</h4><p>对于花色，规则定义如下：黑桃&gt;梅花&gt;方片&gt;红桃</p>\n<p>对于数字，规则定义如下：2最大，3最小</p>\n<h4 id=\"1-2-建模\"><a href=\"#1-2-建模\" class=\"headerlink\" title=\"1.2 建模\"></a>1.2 建模</h4><p>我们将牌的牌面实际数字使用数字进行标记，使用数字3到15表示真实牌的3到2，其中11表示J，12表示Q，13表示K，14表示A，15表示2，其余数字分别代表真实牌面数字。</p>\n<p>将牌的牌面花色同样使用数字进行标记：根据从大到小，分别标记为：4——黑桃，3——梅花，2——方片，1——红桃。</p>\n<p>这样，对于一张牌的数字模型，使用以下公式进行标记：</p>\n<p>牌数字模型大小  &#x3D;  牌面数字模型大小 * 10 + 牌面花色模型大小</p>\n<pre><code>// 牌号点数：如3~J~A~2,使用3~15数字\nprivate int cardNumber;\n    \n// 牌色：如4红桃, 3方片, 2梅花, 1黑桃\nprivate int cardColor;\n    \n// 牌全称：例34是红桃3,152是梅花2,113是方片J\nprivate String cardName;\n    \n// 牌描述：例红桃3,梅花2\nprivate String cardDesc;\n</code></pre>\n<h4 id=\"1-3-总结\"><a href=\"#1-3-总结\" class=\"headerlink\" title=\"1.3 总结\"></a>1.3 总结</h4><p>经过上边的标记，我们很容易将一张牌的模型进行数字化，例如：</p>\n<p>154——黑桃2</p>\n<p>151——红桃2</p>\n<p>83——梅花8</p>\n<p>这样154&gt;151，同样黑桃2大于红桃2</p>\n<p>151&gt;83，同样红桃2大于梅花8</p>\n<h3 id=\"2-构建一副牌\"><a href=\"#2-构建一副牌\" class=\"headerlink\" title=\"2. 构建一副牌\"></a>2. 构建一副牌</h3><p>构建一副牌可以从花色、牌面大小、牌的名称、牌的描述四个方面进行构建，其中花色（4——黑桃，3——梅花，2——方片，1——红桃），大小为：使用数字3到15表示真实牌的3到2，牌名称即牌大小和花色组成的数字大小，描述是通用的牌的叫法，比如：154——黑桃2 牌名称为154 描述为 黑桃2</p>\n<p>这里需要主要的是：<strong>斗地主中存在王，大小王，共54张牌，而在我们的TienLen游戏中不存在大小王，只有52张牌</strong></p>\n<pre><code>/**\n * 初始化牌\n * @return\n */\npublic List&lt;CardInfo&gt; initCard() &#123;\n    List&lt;CardInfo&gt; cardList = new ArrayList&lt;CardInfo&gt;();\n    for (int i = 1; i &lt; 5; i++) &#123;\n        for (int j = 3; j &lt; 16; j++) &#123;\n            CardInfo cardInfo = new CardInfo();\n            cardInfo.setCardNumber(j);\n            cardInfo.setCardColor(i);\n            cardInfo.setCardName(j * 10 + i + &quot;&quot;);\n            switch (i) &#123;\n                case 1:\n                    cardInfo.setCardDesc(&quot;红桃&quot; + j);\n                    break;\n                case 2:\n                    cardInfo.setCardDesc(&quot;方片&quot; + j);\n                    break;\n                case 3:\n                    cardInfo.setCardDesc(&quot;梅花&quot; + j);\n                    break;\n                case 4:\n                    cardInfo.setCardDesc(&quot;黑桃&quot; + j);\n                    break;\n            &#125;\n            cardList.add(cardInfo);\n        &#125;\n    &#125;\n    return cardList;\n&#125;\n</code></pre>\n<h3 id=\"3-洗牌\"><a href=\"#3-洗牌\" class=\"headerlink\" title=\"3. 洗牌\"></a>3. 洗牌</h3><p>洗牌只需要将牌进行打乱即可，这里考虑使用随机数进行交换，模拟洗牌，但是这样的算法存在缺陷，即有可能洗完以后，牌仍然保持原样</p>\n<pre><code>/**\n * 洗牌\n *\n * @param cardList 初始化号的牌\n * @return\n */\npublic List&lt;CardInfo&gt; washCard(List&lt;CardInfo&gt; cardList) &#123;\n    List&lt;CardInfo&gt; randomCardList = cardList;\n    for (int i = 0; i &lt; 100; i++) &#123;\n        Random random = new Random();\n        // 找出52以内的随机数，然后交换位置\n        int a = random.nextInt(52);\n        int b = random.nextInt(52);\n        CardInfo cardInfoTemp = randomCardList.get(a);\n        randomCardList.set(a, randomCardList.get(b));\n        randomCardList.set(b, cardInfoTemp);\n    &#125;\n\n    return randomCardList;\n&#125;\n</code></pre>\n<h3 id=\"4-发牌\"><a href=\"#4-发牌\" class=\"headerlink\" title=\"4. 发牌\"></a>4. 发牌</h3><p>发牌算法很简单，将已经洗好的52张牌，顺序发给各个玩家。这里我们与斗地主区别在于，我们这里一共有四个玩家，因此需要将牌分为4份：</p>\n<pre><code>/**\n * 发牌\n *\n * @param cardList 洗好的牌\n * @return\n */\npublic List&lt;CardInfo&gt;[] handCard(List&lt;CardInfo&gt; cardList) &#123;\n    List&lt;CardInfo&gt; playerCardList[] = new Vector[4];\n    for (int i = 0; i &lt; 4; i++) &#123;\n        playerCardList[i] = new Vector&lt;CardInfo&gt;();\n    &#125;\n    for (int j = 0; j &lt; 52; j++) &#123;\n        switch (j % 4) &#123;\n            case 0:\n                playerCardList[0].add(cardList.get(j));\n                break;\n            case 1:\n                playerCardList[1].add(cardList.get(j));\n                break;\n            case 2:\n                playerCardList[2].add(cardList.get(j));\n                break;\n            case 3:\n                playerCardList[3].add(cardList.get(j));\n                break;\n            default:\n                break;\n        &#125;\n    &#125;\n    return playerCardList;\n&#125;\n</code></pre>\n<h3 id=\"5-捋牌\"><a href=\"#5-捋牌\" class=\"headerlink\" title=\"5. 捋牌\"></a>5. 捋牌</h3><p>也就是对牌进行排序，从大到小进行排序，这样出来的牌，便于往后进行分类等运算。</p>\n<pre><code>/**\n * 排序，按照从大到小的顺序进行排\n *\n * @param cardList\n * @return\n */\npublic List&lt;CardInfo&gt; sortCard(List&lt;CardInfo&gt; cardList) &#123;\n    Collections.sort(cardList, new Comparator&lt;CardInfo&gt;() &#123;\n        @Override\n        public int compare(CardInfo cardInfo1, CardInfo cardInfo2) &#123;\n            int cardNum1 = Integer.valueOf(cardInfo1.getCardName());\n            int cardNum2 = Integer.valueOf(cardInfo2.getCardName());\n\n            if (cardNum1 &gt; cardNum2) &#123;\n                return -1;\n            &#125; else if (cardNum1 == cardNum2) &#123;\n                return 0;\n            &#125; else &#123;\n                return 1;\n            &#125;\n        &#125;\n    &#125;);\n    return cardList;\n&#125;\n</code></pre>\n<h3 id=\"6-出牌\"><a href=\"#6-出牌\" class=\"headerlink\" title=\"6. 出牌\"></a>6. 出牌</h3><p>   出牌时，应该根据规则进行出牌，首先、判断用户所选择的牌是否符合规则，即是否是单牌、对子、三张、链子、炸弹等</p>\n<h4 id=\"6-1-单张牌\"><a href=\"#6-1-单张牌\" class=\"headerlink\" title=\"6.1 单张牌\"></a>6.1 单张牌</h4><p>获取单张牌的算法很简单，任意一张牌，都可以作为单张牌使用，因此只需要将所有的牌都添加到单张牌的列表中即可。</p>\n<pre><code> /***\n * 获取单张牌\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get1(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all1List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    sortCardAsc(mCardList);\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        cardList = new ArrayList&lt;&gt;();\n        cardList.add(mCardList.get(i));\n        all1List.add(cardList);\n    &#125;\n\n    return all1List;\n&#125;\n</code></pre>\n<h4 id=\"6-2-对子\"><a href=\"#6-2-对子\" class=\"headerlink\" title=\"6.2 对子\"></a>6.2 对子</h4><p>获取对子时，需要注意，因为我们TienLen游戏的规则中，不仅需要比较牌面点数大小，还需要比较花色大小，所以，同样4个2，可能组合成多种对子，且大小不一样，比如黑桃2和梅花2，比如红桃2和方片2</p>\n<pre><code> /**\n * 获取对子\n * 这里对i+1 i+2 i+3分别和第i张牌进行对比，\n * 举例：比如四个2，可以黑桃2和方片2一对，也可以是梅花2和红桃2一对\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get11(List&lt;CardInfo&gt; mCardList) &#123;\n    // 先对牌进行排序\n    sortCardAsc(mCardList);\n    List&lt;List&lt;CardInfo&gt;&gt; all11CardList = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 1 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 1).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            all11CardList.add(cardList);\n        &#125;\n        if (i + 2 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 2));\n            all11CardList.add(cardList);\n        &#125;\n        if (i + 3 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 3));\n            all11CardList.add(cardList);\n        &#125;\n    &#125;\n    return all11CardList;\n&#125;\n</code></pre>\n<h3 id=\"6-3-三个\"><a href=\"#6-3-三个\" class=\"headerlink\" title=\"6.3 三个\"></a>6.3 三个</h3><p>在斗地主的规则中，好像也是三个也可以一起出，但是需要带一个或者一对，我们TienLen游戏中不需要带，也不能带，可以直接出，比如三个三，三个四，这样的牌，获取的算法和上边对子的获取算法一致</p>\n<pre><code> /***\n * 获取三个\n * 算法个获取对子的算法类似\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get111(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all111List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n    // 先对牌进行排序\n    sortCardAsc(mCardList);\n\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 2 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            cardList.add(mCardList.get(i + 2));\n            all111List.add(cardList);\n        &#125;\n    &#125;\n    return all111List;\n&#125;\n</code></pre>\n<h3 id=\"6-4-炸弹\"><a href=\"#6-4-炸弹\" class=\"headerlink\" title=\"6.4 炸弹\"></a>6.4 炸弹</h3><p>炸弹，不论在斗地主中还是我们现在做的TienLen中，都是一样的作用，一样的获取方法，和获取对子，三个的方法一致，这里直接上代码：</p>\n<pre><code>/***\n * 获取炸弹\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get1111(List&lt;CardInfo&gt; mCardList) &#123;\n    List&lt;List&lt;CardInfo&gt;&gt; all1111List = new ArrayList&lt;&gt;();\n    List&lt;CardInfo&gt; cardList;\n\n    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;\n        if (i + 3 &lt; length\n                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;\n            cardList = new ArrayList&lt;&gt;();\n            cardList.add(mCardList.get(i));\n            cardList.add(mCardList.get(i + 1));\n            cardList.add(mCardList.get(i + 2));\n            cardList.add(mCardList.get(i + 3));\n            all1111List.add(cardList);\n        &#125;\n    &#125;\n    return all1111List;\n&#125;\n</code></pre>\n<h3 id=\"6-5-链子\"><a href=\"#6-5-链子\" class=\"headerlink\" title=\"6.5 链子\"></a>6.5 链子</h3><p>终于说到了这个牌型——链子，链子在不同的玩法中，可以出不同的长度，在我们的TienLen中最少是三联，这里获取时，先对手牌进行排序，排好序后，进行遍历，找到能和当前牌连接起来的，且牌长度大于3的，均属于链子：</p>\n<pre><code>/**\n * 获取链子\n *\n * @param mCardList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get123(List&lt;CardInfo&gt; mCardList) &#123;\n    // 链子长度必须大于3,即最少出3连\n    if (mCardList.size() &lt; 3) &#123;\n        return null;\n    &#125;\n    // 构建返回数据\n    List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();\n    List&lt;List&lt;CardInfo&gt;&gt; all123List = new ArrayList&lt;&gt;();\n\n    // 先去掉2\n    for (int i = 0; i &lt; mCardList.size(); i++) &#123;\n        if (mCardList.get(i).getCardNumber() != 15) &#123;\n            tempCardList.add(mCardList.get(i));\n        &#125;\n    &#125;\n    // 重新进行排序\n    sortCardAsc(tempCardList);\n\n    for (int i = 0; i &lt; tempCardList.size(); i++) &#123;\n        CardInfo tempCardInfo = tempCardList.get(i);\n        List&lt;CardInfo&gt; cardList = new ArrayList&lt;&gt;();\n        cardList.add(tempCardInfo);\n        List&lt;CardInfo&gt; cardListTempAfter = new ArrayList&lt;&gt;();\n        for (int j = i + 1; j &lt; tempCardList.size(); j++) &#123;\n            // 判断当前牌是否个下一个牌能连起来（当前牌是5，当下一个是5+1=6时，即连起来了，当连起来大于3个牌时，即可以认为是一连）\n            if ((tempCardInfo.getCardNumber() + 1) == tempCardList.get(j).getCardNumber()) &#123;\n                cardListTempAfter.clear();\n                cardListTempAfter.addAll(cardList);\n                cardList.add(tempCardList.get(j));\n                tempCardInfo = tempCardList.get(j);\n                if (cardList.size() &gt;= 3) &#123;\n                    List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();\n                    cardListTemp.addAll(cardList);\n                    all123List.add(cardList);\n\n                    cardList = new ArrayList&lt;&gt;();\n                    cardList.addAll(cardListTemp);\n                &#125;\n            &#125; else if (tempCardInfo.getCardNumber() == tempCardList.get(j).getCardNumber()\n                    &amp;&amp; tempCardInfo.getCardNumber() != tempCardList.get(i).getCardNumber()) &#123;\n                List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();\n                cardListTemp.addAll(cardListTempAfter);\n                if (cardListTemp.size() &gt; 0\n                        &amp;&amp; cardListTemp.get(cardListTemp.size() - 1).getCardNumber() != tempCardList\n                        .get(j).getCardNumber()) &#123;\n                    cardListTempAfter.add(tempCardList.get(j));\n                    if (cardListTempAfter.size() &gt;= 3) &#123;\n                        all123List.add(cardListTempAfter);\n                        cardListTempAfter = new ArrayList&lt;&gt;();\n                        cardListTempAfter.addAll(cardListTemp);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return all123List;\n&#125;\n</code></pre>\n<h3 id=\"6-6-双链\"><a href=\"#6-6-双链\" class=\"headerlink\" title=\"6.6 双链\"></a>6.6 双链</h3><p>双链，也就是经常说的飞机带翅膀，双链的前提是对子，只有存在对子的情况下，才能找出来双链，所以，其算法也是一样，先找到所有的对子，然后去掉2，进行排序，再按照找链子的方法进行找，这样返回的就是双链。</p>\n<pre><code> /***\n * 获取飞机\n *\n * @param mCardInfoList\n * @return\n */\npublic List&lt;List&lt;CardInfo&gt;&gt; get112233(List&lt;CardInfo&gt; mCardInfoList) &#123;\n    int length = mCardInfoList.size();\n    // 双链最少为3连，所以最少六张牌\n    if (length &lt; 6) &#123;\n        return null;\n    &#125;\n    // 保存所有的对子\n    List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();\n    // 保存所有不包含2的对子\n    List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();\n    // 防止重复添加\n    List&lt;Integer&gt; integerList = new Vector&lt;&gt;();\n\n    // 返回结果\n    List&lt;List&lt;CardInfo&gt;&gt; all112233List = new ArrayList&lt;&gt;();\n\n    // 存储单个双对链子\n    List&lt;CardInfo&gt; cardList;\n\n    // 先获取所有的对子\n    for (int i = 0; i &lt; length; i++) &#123;\n        if (i + 1 &lt; length\n                &amp;&amp; mCardInfoList.get(i).getCardNumber() == mCardInfoList.get(i + 1)\n                .getCardNumber()) &#123;\n            tempList.add(mCardInfoList.get(i));\n            tempList.add(mCardInfoList.get(i + 1));\n            i = i + 1;\n        &#125;\n    &#125;\n    // 排序\n    sortCardAsc(tempList);\n\n    // 去除对2和相同的\n    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;\n        if (!integerList.contains(Integer.valueOf(tempList.get(i).getCardNumber()))) &#123;\n            apairTempList.add(tempList.get(i));\n            integerList.add(Integer.valueOf(tempList.get(i).getCardNumber()));\n        &#125;\n    &#125;\n\n    // 双对的链子最少三联\n    if (apairTempList.size() &lt; 3) &#123;\n        return null;\n    &#125;\n\n    // 对之前拿到的对子List进行排序，正序\n    sortCardAsc(tempList);\n\n    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);\n\n    for (int j = 0; j &lt; get123TempList.size(); j++) &#123;\n        List&lt;CardInfo&gt; list123 = get123TempList.get(j);\n        sortCardAsc(list123);\n        for (int k = 0; k &lt; tempList.size(); k++) &#123;\n            if (tempList.get(k).getCardName().equals(list123.get(0).getCardName())) &#123;\n                cardList = new ArrayList&lt;&gt;();\n                for (int l = k; l &lt; list123.size() * 2 + k; l++) &#123;\n                    cardList.add(tempList.get(l));\n                &#125;\n                all112233List.add(cardList);\n            &#125;\n        &#125;\n    &#125;\n    return all112233List;\n&#125;\n</code></pre>\n<h3 id=\"7-出牌\"><a href=\"#7-出牌\" class=\"headerlink\" title=\"7 出牌\"></a>7 出牌</h3><p>出牌有两种情况，一种是手动选择的，一种是通过提示，自动出牌的。对于手动选择的，需要根据自己当前是否有首先出牌权，进行校验，</p>\n<ol>\n<li>如果当前是自己的局，也就是说，上轮出牌的过程中，自己最大，这局自己首先出，所以只需要校验自己手动选择的牌是否符合规则。</li>\n<li>如果当前是别人的局，也就是说，自己当前跟着别人的局出牌，只能和别人的类型一致，且大于对方，所以需要校验选择的牌类型是否和别人的一致，再校验是否比别人的大，才能出</li>\n</ol>\n<p>对于通过提示出牌的，只适合第二种情况，也就是说，别人出牌，然后自己管，系统会进行提示</p>\n<h4 id=\"7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\"><a href=\"#7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\" class=\"headerlink\" title=\"7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出\"></a>7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出</h4><pre><code> /**\n * 获取出牌类型\n * \n * @param outCard\n * @return\n */\npublic OutCardType getOutCardType(List&lt;CardInfo&gt; outCard) &#123;\n    if (outCard != null) &#123;\n        int cardLength = outCard.size();\n\n        if (outCard.get(0).getCardNumber() == outCard.get(cardLength - 1).getCardNumber()) &#123;\n            switch (cardLength) &#123;\n                case 1:\n                    // 单牌\n                    return OutCardType.type1;\n                case 2:\n                    // 对子\n                    return OutCardType.type11;\n                case 3:\n                    // 三个\n                    return OutCardType.type111;\n                case 4:\n                    // 炸弹\n                    return OutCardType.type1111;\n            &#125;\n        &#125;\n\n        // 判断链子，最少三张\n        if (outCard.size() &gt;= 3) &#123;\n            List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();\n\n            // 先去掉2\n            for (int i = 0; i &lt; outCard.size(); i++) &#123;\n                if (outCard.get(i).getCardNumber() != 15) &#123;\n                    tempCardList.add(outCard.get(i));\n                &#125;\n            &#125;\n            // 重新进行排序\n            sortCardAsc(tempCardList);\n\n            // 判断是否为链子\n            List&lt;List&lt;CardInfo&gt;&gt; get123 = get123(outCard);\n            if (get123 != null &amp;&amp; get123.size() &gt; 0) &#123;\n                for (List&lt;CardInfo&gt; list : get123) &#123;\n                    if (list.size() == outCard.size()) &#123;\n                        return OutCardType.type123;\n                    &#125;\n                &#125;\n\n            &#125;\n\n            // 双对至少6张\n            if (outCard.size() &gt;= 6) &#123;\n                int length = outCard.size();\n                // 保存所有的对子\n                List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();\n                // 保存所有不包含2的对子\n                List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();\n                // 防止重复添加\n                List&lt;Integer&gt; integerList = new Vector&lt;&gt;();\n\n                // 先获取所有的对子\n                for (int i = 0; i &lt; length; i++) &#123;\n                    if (i + 1 &lt; length\n                            &amp;&amp; outCard.get(i).getCardNumber() == outCard.get(i + 1)\n                            .getCardNumber()) &#123;\n                        tempList.add(outCard.get(i));\n                        tempList.add(outCard.get(i + 1));\n                        i = i + 1;\n                    &#125;\n                &#125;\n\n                // 所有的牌均为对子\n                if (tempList.size() == outCard.size()) &#123;\n                    // 去除对2\n                    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;\n                        if (integerList.indexOf(outCard.get(i).getCardNumber()) &lt; 0\n                                &amp;&amp; tempList.get(i).getCardNumber() != 15) &#123;\n                            apairTempList.add(tempList.get(i));\n                            integerList.add(tempList.get(i).getCardNumber());\n                        &#125;\n                        i = i + 1;\n                    &#125;\n\n                    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子\n                    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);\n                    for (int i = 0; i &lt; get123TempList.size(); i++) &#123;\n                        if (get123TempList.get(i).size() == length / 2) &#123;\n                            return OutCardType.type112233;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return OutCardType.type0;\n&#125;\n</code></pre>\n<p>只有当选中牌的类型是已知类型，才能第一步判断出是否可以出牌，下一步则需要根据当前是不是自己轮，判断需要不需要压对方的牌</p>\n<h4 id=\"7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\"><a href=\"#7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\" class=\"headerlink\" title=\"7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大\"></a>7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大</h4><pre><code>/**\n * 当上家出牌后，判断自己是否可以出牌\n *\n * @param outCard\n * @param mAllCard\n * @param mSelectCard\n * @return\n */\npublic boolean whetherCanPlay(List&lt;CardInfo&gt; outCard, List&lt;CardInfo&gt; mAllCard,\n                              List&lt;CardInfo&gt; mSelectCard) &#123;\n    boolean isCardCanPlay = false;\n\n    // 获取对手牌型\n    OutCardType outCardType = getOutCardType(outCard);\n    OutCardType outCardTypeMy = getOutCardType(mSelectCard);\n    sortCard(outCard);\n    // 先对牌进行排序\n    sortCard(mSelectCard);\n\n    // 首先判断牌的张数是否一样\n    if (outCard.size() == mSelectCard.size() &amp;&amp; outCardType == outCardTypeMy) &#123;\n        int outCardName = Integer.valueOf(outCard.get(0).getCardName());\n        int mSelectCardName = Integer.valueOf(mSelectCard.get(0).getCardName());\n\n        // 相同，属于同一级牌之间压\n        switch (outCardType) &#123;\n            case type1:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type11:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type111:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type1111:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type123:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            case type112233:\n                if (mSelectCardName &gt; outCardName) &#123;\n                    isCardCanPlay = true;\n                &#125;\n                break;\n            default:\n                isCardCanPlay = false;\n                break;\n        &#125;\n    &#125; else &#123;\n        // 当张数不一致时，有两种情况，即炸弹压2和连着的双对压对2\n        if (outCard.size() == 1 &amp;&amp; mSelectCard.size() == 4) &#123;\n            // 当别人为单个2且自己的Type为炸弹时\n            if (outCard.get(0).getCardNumber() == 15\n                    &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type1111) &#123;\n                isCardCanPlay = true;\n            &#125;\n        &#125; else &#123;\n            // 别人出牌为一对2，自己应该用33-44-55-66或者55-66-77-88压\n            if (outCard.size() == 2 &amp;&amp; mSelectCard.size() &gt;= 8) &#123;\n                if (outCard.get(0).getCardNumber() == 15\n                        &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type112233) &#123;\n                    isCardCanPlay = true;\n                &#125;\n            &#125; else &#123;\n                isCardCanPlay = false;\n            &#125;\n        &#125;\n    &#125;\n    return isCardCanPlay;\n&#125;\n</code></pre>\n<p>这里边包含了部分规则，比如同样的牌类型，比较大小，同时33445566可以压对二这样的规则</p>\n<h3 id=\"8-提示\"><a href=\"#8-提示\" class=\"headerlink\" title=\"8. 提示\"></a>8. 提示</h3><p> 提示算法比较简单，先获取上家出牌的类型，再获取自己手牌中对应类型的列表，逐个进行比较，直到找到合适的</p>\n<h3 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h3><p>这里除了上述洗牌、发牌、出牌等算法之外，还有单机模式的AI算法，回头有空了整理下，我再发上来吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这片文章中，只是写了一个针对斗地主类类游戏的牌的算法，包含了牌模型构建、洗牌、发牌、出牌等算法的实现，虽然游戏规则不同，但是思路大同小异，希望有需要的同学可以参考下。</p>\n"},{"title":"HEIF图片存储格式探秘","date":"2017-12-11T10:30:43.000Z","keywords":"HEIF , IOS11图片格式 , 图片存储","description":"HEIF图片存储格式探秘","top_img":"http://image.jucaiwy.com/image/20161211/heif_image.jpg","cover":"http://image.jucaiwy.com/image/20161211/heif_image.jpg","_content":"\n\n\nHEIF，High Efficiency Image File Format，即高效率图档格式，是由动态图像专家组（MPEG--Moving Picture Experts Group ）在2013年推出的存储图片和图片序列的新格式，用于HEVC关键帧的处理上，因此它同样可以用更少的容量来存储画质更好的照片，在连拍、动图和色彩变化不大的照片上效果尤其明显。\n\n官网：[http://nokiatech.github.io/heif/](http://nokiatech.github.io/heif/)\n\n比较：[http://nokiatech.github.io/heif/comparison.html](http://nokiatech.github.io/heif/comparison.html)\n\n\nGitHub地址：[https://github.com/nokiatech/heif](https://github.com/nokiatech/heif)\n\n\n在git的wiki上有说明如何进行编译，需要再linux中进行编译，今天安装了linux系统，然后，准备编译一下。\n\n\n### 1. 编译构建\n\n从GitHub上下载了Nokia的代码，语言不通，几乎看不懂，但是，从wiki上看到了如何进行编译和构建，于是决定试试。\n\n\n在Linux环境下，打开命令行模式，输入命令进行下载：\n\n![](http://image.jucaiwy.com/image/20161211/I9eaox5.png)\n\n下载完成后，可以看到目录结构如下：\n\n![](http://image.jucaiwy.com/image/20161211/HH0eXqI.png)\n\n然后，进入heif目录，新建文件夹，命名为build，然后进入build，执行cmake .. \n\n![](http://image.jucaiwy.com/image/20161211/IpuSeOp.png)\n\n然后执行make：\n\n![](http://image.jucaiwy.com/image/20161211/4R9eq3Y.png)\n\n生成了可执行的writerapp的执行文件，但是现在还不知道怎么执行。\n\n### 2. 转换工具：\n\n[HEIF Utility](https://liuziangexit.com/HEIF-Utility/)\n\n这个转换工具，今天测试了以下，不是很好用。\n\n### 3. Android项目Demo\n\n[https://github.com/yohhoy/heifreader](https://github.com/yohhoy/heifreader)\n\n这个项目使用了 [sannies/mp4parser ](https://github.com/sannies/mp4parser)这个库解析HEIF结构。目前为止存在bug，没有解决，可能是因为当前技术不完善吧\n\n\n### 4. 各种不支持\n\nWindows不支持，PhotoShopCC不支持，低版本的iPhone、Mac均不支持该格式，微信，微博等均不支持（测试了Android版本的）\n\n### 5. 在线的HEIF图片地址：\n\n这里找到了一些在线的图片地址，heic格式的，是诺基亚官方提供的，以后研究的时候可以使用\n\n在线地址：[https://github.com/nokiatech/heif/tree/gh-pages/content/images](https://github.com/nokiatech/heif/tree/gh-pages/content/images)\n\n\n### 6. 没有快速推广的原因：\n\n1. 专利费，齁贵，各大厂硬件厂商用不起\n2. 格式暂时未通用，各大软件服务商，暂时没有支持，表现在Windows也无法产生这种文档的图示，而且Photoshop也不支持该格式的图片编辑，目前仅苹果支持。\n\n\n\n","source":"_posts/20171211HEIF图片存储格式探秘.markdown","raw":"---\n\ntitle: HEIF图片存储格式探秘\n\ndate: 2017-12-11 18:30:43\n\ntags: [ Android , IJKPlayer , IOS11图片格式 , 图片存储]\n\ncategories: [Android , HEIF ]\n\nkeywords: HEIF , IOS11图片格式 , 图片存储\n\ndescription: HEIF图片存储格式探秘\n\ntop_img: http://image.jucaiwy.com/image/20161211/heif_image.jpg\n\ncover: http://image.jucaiwy.com/image/20161211/heif_image.jpg\n\n---\n\n\n\nHEIF，High Efficiency Image File Format，即高效率图档格式，是由动态图像专家组（MPEG--Moving Picture Experts Group ）在2013年推出的存储图片和图片序列的新格式，用于HEVC关键帧的处理上，因此它同样可以用更少的容量来存储画质更好的照片，在连拍、动图和色彩变化不大的照片上效果尤其明显。\n\n官网：[http://nokiatech.github.io/heif/](http://nokiatech.github.io/heif/)\n\n比较：[http://nokiatech.github.io/heif/comparison.html](http://nokiatech.github.io/heif/comparison.html)\n\n\nGitHub地址：[https://github.com/nokiatech/heif](https://github.com/nokiatech/heif)\n\n\n在git的wiki上有说明如何进行编译，需要再linux中进行编译，今天安装了linux系统，然后，准备编译一下。\n\n\n### 1. 编译构建\n\n从GitHub上下载了Nokia的代码，语言不通，几乎看不懂，但是，从wiki上看到了如何进行编译和构建，于是决定试试。\n\n\n在Linux环境下，打开命令行模式，输入命令进行下载：\n\n![](http://image.jucaiwy.com/image/20161211/I9eaox5.png)\n\n下载完成后，可以看到目录结构如下：\n\n![](http://image.jucaiwy.com/image/20161211/HH0eXqI.png)\n\n然后，进入heif目录，新建文件夹，命名为build，然后进入build，执行cmake .. \n\n![](http://image.jucaiwy.com/image/20161211/IpuSeOp.png)\n\n然后执行make：\n\n![](http://image.jucaiwy.com/image/20161211/4R9eq3Y.png)\n\n生成了可执行的writerapp的执行文件，但是现在还不知道怎么执行。\n\n### 2. 转换工具：\n\n[HEIF Utility](https://liuziangexit.com/HEIF-Utility/)\n\n这个转换工具，今天测试了以下，不是很好用。\n\n### 3. Android项目Demo\n\n[https://github.com/yohhoy/heifreader](https://github.com/yohhoy/heifreader)\n\n这个项目使用了 [sannies/mp4parser ](https://github.com/sannies/mp4parser)这个库解析HEIF结构。目前为止存在bug，没有解决，可能是因为当前技术不完善吧\n\n\n### 4. 各种不支持\n\nWindows不支持，PhotoShopCC不支持，低版本的iPhone、Mac均不支持该格式，微信，微博等均不支持（测试了Android版本的）\n\n### 5. 在线的HEIF图片地址：\n\n这里找到了一些在线的图片地址，heic格式的，是诺基亚官方提供的，以后研究的时候可以使用\n\n在线地址：[https://github.com/nokiatech/heif/tree/gh-pages/content/images](https://github.com/nokiatech/heif/tree/gh-pages/content/images)\n\n\n### 6. 没有快速推广的原因：\n\n1. 专利费，齁贵，各大厂硬件厂商用不起\n2. 格式暂时未通用，各大软件服务商，暂时没有支持，表现在Windows也无法产生这种文档的图示，而且Photoshop也不支持该格式的图片编辑，目前仅苹果支持。\n\n\n\n","slug":"20171211HEIF图片存储格式探秘","published":1,"updated":"2022-04-19T07:08:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurv001kb3t1212t7t7h","content":"<p>HEIF，High Efficiency Image File Format，即高效率图档格式，是由动态图像专家组（MPEG–Moving Picture Experts Group ）在2013年推出的存储图片和图片序列的新格式，用于HEVC关键帧的处理上，因此它同样可以用更少的容量来存储画质更好的照片，在连拍、动图和色彩变化不大的照片上效果尤其明显。</p>\n<p>官网：<a href=\"http://nokiatech.github.io/heif/\">http://nokiatech.github.io/heif/</a></p>\n<p>比较：<a href=\"http://nokiatech.github.io/heif/comparison.html\">http://nokiatech.github.io/heif/comparison.html</a></p>\n<p>GitHub地址：<a href=\"https://github.com/nokiatech/heif\">https://github.com/nokiatech/heif</a></p>\n<p>在git的wiki上有说明如何进行编译，需要再linux中进行编译，今天安装了linux系统，然后，准备编译一下。</p>\n<h3 id=\"1-编译构建\"><a href=\"#1-编译构建\" class=\"headerlink\" title=\"1. 编译构建\"></a>1. 编译构建</h3><p>从GitHub上下载了Nokia的代码，语言不通，几乎看不懂，但是，从wiki上看到了如何进行编译和构建，于是决定试试。</p>\n<p>在Linux环境下，打开命令行模式，输入命令进行下载：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/I9eaox5.png\"></p>\n<p>下载完成后，可以看到目录结构如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/HH0eXqI.png\"></p>\n<p>然后，进入heif目录，新建文件夹，命名为build，然后进入build，执行cmake .. </p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/IpuSeOp.png\"></p>\n<p>然后执行make：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/4R9eq3Y.png\"></p>\n<p>生成了可执行的writerapp的执行文件，但是现在还不知道怎么执行。</p>\n<h3 id=\"2-转换工具：\"><a href=\"#2-转换工具：\" class=\"headerlink\" title=\"2. 转换工具：\"></a>2. 转换工具：</h3><p><a href=\"https://liuziangexit.com/HEIF-Utility/\">HEIF Utility</a></p>\n<p>这个转换工具，今天测试了以下，不是很好用。</p>\n<h3 id=\"3-Android项目Demo\"><a href=\"#3-Android项目Demo\" class=\"headerlink\" title=\"3. Android项目Demo\"></a>3. Android项目Demo</h3><p><a href=\"https://github.com/yohhoy/heifreader\">https://github.com/yohhoy/heifreader</a></p>\n<p>这个项目使用了 <a href=\"https://github.com/sannies/mp4parser\">sannies&#x2F;mp4parser </a>这个库解析HEIF结构。目前为止存在bug，没有解决，可能是因为当前技术不完善吧</p>\n<h3 id=\"4-各种不支持\"><a href=\"#4-各种不支持\" class=\"headerlink\" title=\"4. 各种不支持\"></a>4. 各种不支持</h3><p>Windows不支持，PhotoShopCC不支持，低版本的iPhone、Mac均不支持该格式，微信，微博等均不支持（测试了Android版本的）</p>\n<h3 id=\"5-在线的HEIF图片地址：\"><a href=\"#5-在线的HEIF图片地址：\" class=\"headerlink\" title=\"5. 在线的HEIF图片地址：\"></a>5. 在线的HEIF图片地址：</h3><p>这里找到了一些在线的图片地址，heic格式的，是诺基亚官方提供的，以后研究的时候可以使用</p>\n<p>在线地址：<a href=\"https://github.com/nokiatech/heif/tree/gh-pages/content/images\">https://github.com/nokiatech/heif/tree/gh-pages/content/images</a></p>\n<h3 id=\"6-没有快速推广的原因：\"><a href=\"#6-没有快速推广的原因：\" class=\"headerlink\" title=\"6. 没有快速推广的原因：\"></a>6. 没有快速推广的原因：</h3><ol>\n<li>专利费，齁贵，各大厂硬件厂商用不起</li>\n<li>格式暂时未通用，各大软件服务商，暂时没有支持，表现在Windows也无法产生这种文档的图示，而且Photoshop也不支持该格式的图片编辑，目前仅苹果支持。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>HEIF，High Efficiency Image File Format，即高效率图档格式，是由动态图像专家组（MPEG–Moving Picture Experts Group ）在2013年推出的存储图片和图片序列的新格式，用于HEVC关键帧的处理上，因此它同样可以用更少的容量来存储画质更好的照片，在连拍、动图和色彩变化不大的照片上效果尤其明显。</p>\n<p>官网：<a href=\"http://nokiatech.github.io/heif/\">http://nokiatech.github.io/heif/</a></p>\n<p>比较：<a href=\"http://nokiatech.github.io/heif/comparison.html\">http://nokiatech.github.io/heif/comparison.html</a></p>\n<p>GitHub地址：<a href=\"https://github.com/nokiatech/heif\">https://github.com/nokiatech/heif</a></p>\n<p>在git的wiki上有说明如何进行编译，需要再linux中进行编译，今天安装了linux系统，然后，准备编译一下。</p>\n<h3 id=\"1-编译构建\"><a href=\"#1-编译构建\" class=\"headerlink\" title=\"1. 编译构建\"></a>1. 编译构建</h3><p>从GitHub上下载了Nokia的代码，语言不通，几乎看不懂，但是，从wiki上看到了如何进行编译和构建，于是决定试试。</p>\n<p>在Linux环境下，打开命令行模式，输入命令进行下载：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/I9eaox5.png\"></p>\n<p>下载完成后，可以看到目录结构如下：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/HH0eXqI.png\"></p>\n<p>然后，进入heif目录，新建文件夹，命名为build，然后进入build，执行cmake .. </p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/IpuSeOp.png\"></p>\n<p>然后执行make：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20161211/4R9eq3Y.png\"></p>\n<p>生成了可执行的writerapp的执行文件，但是现在还不知道怎么执行。</p>\n<h3 id=\"2-转换工具：\"><a href=\"#2-转换工具：\" class=\"headerlink\" title=\"2. 转换工具：\"></a>2. 转换工具：</h3><p><a href=\"https://liuziangexit.com/HEIF-Utility/\">HEIF Utility</a></p>\n<p>这个转换工具，今天测试了以下，不是很好用。</p>\n<h3 id=\"3-Android项目Demo\"><a href=\"#3-Android项目Demo\" class=\"headerlink\" title=\"3. Android项目Demo\"></a>3. Android项目Demo</h3><p><a href=\"https://github.com/yohhoy/heifreader\">https://github.com/yohhoy/heifreader</a></p>\n<p>这个项目使用了 <a href=\"https://github.com/sannies/mp4parser\">sannies&#x2F;mp4parser </a>这个库解析HEIF结构。目前为止存在bug，没有解决，可能是因为当前技术不完善吧</p>\n<h3 id=\"4-各种不支持\"><a href=\"#4-各种不支持\" class=\"headerlink\" title=\"4. 各种不支持\"></a>4. 各种不支持</h3><p>Windows不支持，PhotoShopCC不支持，低版本的iPhone、Mac均不支持该格式，微信，微博等均不支持（测试了Android版本的）</p>\n<h3 id=\"5-在线的HEIF图片地址：\"><a href=\"#5-在线的HEIF图片地址：\" class=\"headerlink\" title=\"5. 在线的HEIF图片地址：\"></a>5. 在线的HEIF图片地址：</h3><p>这里找到了一些在线的图片地址，heic格式的，是诺基亚官方提供的，以后研究的时候可以使用</p>\n<p>在线地址：<a href=\"https://github.com/nokiatech/heif/tree/gh-pages/content/images\">https://github.com/nokiatech/heif/tree/gh-pages/content/images</a></p>\n<h3 id=\"6-没有快速推广的原因：\"><a href=\"#6-没有快速推广的原因：\" class=\"headerlink\" title=\"6. 没有快速推广的原因：\"></a>6. 没有快速推广的原因：</h3><ol>\n<li>专利费，齁贵，各大厂硬件厂商用不起</li>\n<li>格式暂时未通用，各大软件服务商，暂时没有支持，表现在Windows也无法产生这种文档的图示，而且Photoshop也不支持该格式的图片编辑，目前仅苹果支持。</li>\n</ol>\n"},{"title":"IJKPlayer使用SeekTo跳转关键帧不正确","date":"2017-12-21T09:56:53.000Z","keywords":"Android , IJKPlayer , 跳转关键帧","description":"IJKPlayer使用SeekTo跳转关键帧不正确","top_img":"http://image.jucaiwy.com/image/20161221/ijk_player.jpeg","cover":"http://image.jucaiwy.com/image/20161221/ijk_player.jpeg","_content":"\n今天在做一个视频播放的功能，播放内核使用的IJKPlayer，在拖动进度条进行跳转的时候，发现跳转位置总是不准确，尤其在10秒以内的视频播放中进行拖动，跳转的更不准确，经常调至开头或者结尾。\n\n分析其原因，发现进度条SeekBar定位是没有问题的，但是使用IjkMediaPlayer.seekTo(int position)方法时，总是不能准确定位。分析是IjkMediaPlayer内部问题，可能因为视频时间较短，压缩率较高等原因，导致关键帧确实，进度条定点位置内没有找到关键帧，所以，定位不准确。\n\n\n### 解决方法\n在初始化视频播放器的时候，添加seekTo支持\n\n```java\n((IjkMediaPlayer)mMediaPlayer).setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"enable-accurate-seek\", 1);\n```\n\n至于这个配置具体还有别的什么，我再找找。\n","source":"_posts/20171221IJKPlayer使用SeekTo跳转关键帧不正确.markdown","raw":"---\n\ntitle: IJKPlayer使用SeekTo跳转关键帧不正确\n\ndate: 2017-12-21 17:56:53\n\ntags: [ Android , IJKPlayer , ]\n\ncategories: [Android , 问题记录 ]\n\nkeywords: Android , IJKPlayer , 跳转关键帧\n\ndescription: IJKPlayer使用SeekTo跳转关键帧不正确\n\ntop_img: http://image.jucaiwy.com/image/20161221/ijk_player.jpeg\n\ncover: http://image.jucaiwy.com/image/20161221/ijk_player.jpeg\n\n---\n\n今天在做一个视频播放的功能，播放内核使用的IJKPlayer，在拖动进度条进行跳转的时候，发现跳转位置总是不准确，尤其在10秒以内的视频播放中进行拖动，跳转的更不准确，经常调至开头或者结尾。\n\n分析其原因，发现进度条SeekBar定位是没有问题的，但是使用IjkMediaPlayer.seekTo(int position)方法时，总是不能准确定位。分析是IjkMediaPlayer内部问题，可能因为视频时间较短，压缩率较高等原因，导致关键帧确实，进度条定点位置内没有找到关键帧，所以，定位不准确。\n\n\n### 解决方法\n在初始化视频播放器的时候，添加seekTo支持\n\n```java\n((IjkMediaPlayer)mMediaPlayer).setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"enable-accurate-seek\", 1);\n```\n\n至于这个配置具体还有别的什么，我再找找。\n","slug":"20171221IJKPlayer使用SeekTo跳转关键帧不正确","published":1,"updated":"2020-12-09T06:35:50.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurw001nb3t1a8te5k7v","content":"<p>今天在做一个视频播放的功能，播放内核使用的IJKPlayer，在拖动进度条进行跳转的时候，发现跳转位置总是不准确，尤其在10秒以内的视频播放中进行拖动，跳转的更不准确，经常调至开头或者结尾。</p>\n<p>分析其原因，发现进度条SeekBar定位是没有问题的，但是使用IjkMediaPlayer.seekTo(int position)方法时，总是不能准确定位。分析是IjkMediaPlayer内部问题，可能因为视频时间较短，压缩率较高等原因，导致关键帧确实，进度条定点位置内没有找到关键帧，所以，定位不准确。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>在初始化视频播放器的时候，添加seekTo支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((IjkMediaPlayer)mMediaPlayer).setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class=\"string\">&quot;enable-accurate-seek&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>至于这个配置具体还有别的什么，我再找找。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在做一个视频播放的功能，播放内核使用的IJKPlayer，在拖动进度条进行跳转的时候，发现跳转位置总是不准确，尤其在10秒以内的视频播放中进行拖动，跳转的更不准确，经常调至开头或者结尾。</p>\n<p>分析其原因，发现进度条SeekBar定位是没有问题的，但是使用IjkMediaPlayer.seekTo(int position)方法时，总是不能准确定位。分析是IjkMediaPlayer内部问题，可能因为视频时间较短，压缩率较高等原因，导致关键帧确实，进度条定点位置内没有找到关键帧，所以，定位不准确。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>在初始化视频播放器的时候，添加seekTo支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((IjkMediaPlayer)mMediaPlayer).setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class=\"string\">&quot;enable-accurate-seek&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>至于这个配置具体还有别的什么，我再找找。</p>\n"},{"title":"AndroidStudio集成ReactNative到已有工程","date":"2018-01-04T11:34:46.000Z","keywords":"ReactNative , 集成RN","description":"AndroidStudio集成ReactNative到已有工程","top_img":"http://image.jucaiwy.com/image/20180104/react_native.jpg","cover":"http://image.jucaiwy.com/image/20180104/react_native.jpg","_content":"\n最近在看ReactNative的教程，书本上都是直接npm init出来的一个个工程，我突发奇想，觉得直接继承到现有的app里边比较方便开发，说干就干，在网上查了不少资料，也跳了不少坑，现在把我搭建环境的步骤记录下来，方便以后查看\n\n\n### 1. 新建AndroidStudio工程\n\n首先需要新建AndroidStudio工程，注意使用\n\n```\ncompileSdkVersion 23\nminSdkVersion 16\ntargetSdkVersion 23\n```\n\n以及依赖：\n\n```\nimplementation 'com.android.support:appcompat-v7:23.0.1'\n```\n\n### 2. 初始化\n\n打开AndroidStudio底部的Terminal，然后再命令行模式下，输入：\n\n```bash\nnpm init\n```\n\n如图所示：\n\n![](http://image.jucaiwy.com/image/20180104/EXnbv92.png)\n\n然后，一路回车，会生成 package.json文件\n\n![](http://image.jucaiwy.com/image/20180104/q0oJTnh.png)\n\n### 3. 安装node-module\n\n继续在AndroidStudio底部的Terminal中，输入以下命令：\n```bash\nnpm install --save react react-native\n```\n\n然后，回车，大一一分多钟以后，会在工程目录中看到 node_modules 这个包，表示安装成功\n\n安装中：\n\n![](http://image.jucaiwy.com/image/20180104/3B4dP8p.png)\n\n安装成功：\n\n![](http://image.jucaiwy.com/image/20180104/QGitFFv.png)\n\n### 4. 下载.flowconfig\n\n可以使用命令下载这个文件：\n\n```bash\ncurl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig\n```\n\t\n或者直接在根目录中新建文档：.flowconfig,然后复制以下文本，在这个文件中进行保存\n\n[https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig](https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig)\n\n\n### 5. 添加index.android.js\n\n这里我们使用index.android.js为ReactNative的界面入口，也是展示HelloWord的js界面，我们可以直接在工程根目录下创建index.android.js文件，代码：\n```\n\timport React from 'react';\n\timport {\n\t    AppRegistry,\n\t    StyleSheet,\n\t    Text,\n\t    View\n\t} from 'react-native';\n\t\n\tclass HelloWorldApp extends React.Component {\n\t    render() {\n\t        return (\n\t            <View style={styles.container}>\n\t                <Text style={styles.hello}>Hello world! I am from ReactNattive!!</Text>\n\t            </View>\n\t        )\n\t    }\n\t}\n\t\n\tvar styles = StyleSheet.create({\n\t    container: {\n\t        flex: 1,\n\t        justifyContent: 'center',\n\t    },\n\t    hello: {\n\t        fontSize: 20,\n\t        textAlign: 'center',\n\t        margin: 10,\n\t    },\n\t});\n\t\n\tAppRegistry.registerComponent('ReactNative', () => HelloWorldApp);\n```\n\n这里需要注意最后一行代码，registerComponent，这里的第一个参数，必须和自己新建的Android项目名称一样，我们的项目名称是ReactNative，所以第一个参数应该是ReactNative，第二个参数和index.android.js中定义的方法名一样。\n\n所有的文件添加完成后，整个包是这样的：\n\n![](http://image.jucaiwy.com/image/20180104/7zODqQG.png)\n\n\n\n### 6. App添加依赖\n\n首先需要再ReactNative项目app模块的build.gradle目录中添加react-native依赖\n```\n\tcompile \"com.facebook.react:react-native:+\"\n```\n\n添加完成后，完整的代码如下：\n\n``` \napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 23\n    defaultConfig {\n        applicationId \"jd.com.react\"\n        minSdkVersion 16\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        // 开始修改java.lang.UnsatisfiedLinkError: dlopen failed: \"/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so\" is 32-bit instead of 64-bit\n        ndk {\n            abiFilters \"armeabi-v7a\", \"x86\"\n        }\n\n        packagingOptions {\n            exclude \"lib/arm64-v8a/librealm-jni.so\"\n        }\n        // 结束修改java.lang.UnsatisfiedLinkError: dlopen failed: \"/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so\" is 32-bit instead of 64-bit\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation 'com.android.support:appcompat-v7:23.0.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n    testImplementation 'junit:junit:4.12'\n\n    compile \"com.facebook.react:react-native:+\"\n}\n\t\n```\n\n\n这里可以看到，我们工程的编译版本已经修改为23，引用的\n\n```\ncom.android.support:appcompat-v7:23.0.1\n```\n\n\n### 7. 修改maven为本地路径\n\n在工程根目录下，找到build.gradle文件，添加maven路径为本地生成的node-modules\n\n```\nmaven {\n    // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm\n    url \"$rootDir/../node_modules/react-native/android\"\n}\n```\n\n修改完成后，完整的文件为：\n\n![](http://image.jucaiwy.com/image/20180104/RGxteet.png)\n\n\n### 8. 添加Application\n\n为当前工程指定Application，新建一个Application，继承自ReactApplication，这里需要注意的是，如果当前编译版本不是23，那么在新建这个类的时候，将会提示**找不到ReactApplication**\n\n```java\n\tpublic class MyApplication extends Application implements ReactApplication {\n    \tprivate final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {\n\t        @Override\n\t        public boolean getUseDeveloperSupport() {\n\t            return BuildConfig.DEBUG;\n\t        }\n\t\n\t        @Override\n\t        protected List<ReactPackage> getPackages() {\n\t            return Arrays.<ReactPackage>asList(\n\t                    new MainReactPackage()\n\t            );\n\t        }\n\t    };\n\n\t    @Override\n\t    public ReactNativeHost getReactNativeHost() {\n\t        return mReactNativeHost;\n\t    }\n\t\n\t    @Override\n\t    public void onCreate() {\n\t        super.onCreate();\n\t    }\n\t}\n```\n\n新建完成后：\n\n1. 需要再AndroidManifest.xml中为当前项目添加这个application的注册\n2. 需要添加网络权限，因为需要从服务端刷新js界面\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n3. 需要添加调试界面DevSettingsActivity \n```\n<activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" />\n```\n\n\n### 9. 修改MainActivity\n\n首先在MainActivity的布局文件中添加ReactRootView，我这里直接删除了之前新建工程默认出现的TextView，替换为\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\">\n\n\t <com.facebook.react.ReactRootView\n\t     android:id=\"@+id/react_root_view_id\"\n\t     android:layout_width=\"300dp\"\n\t     android:layout_height=\"300dp\" />\n</LinearLayout>\n```\n\n然后修改MainActivity：\n\n```java\npublic class MainActivity extends Activity {\n\t    ReactRootView reactRootView;\n\t    ReactInstanceManager reactInstanceManager;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.react_root_view);\n\t        reactRootView = (ReactRootView) findViewById(R.id.react_root_view_id);\n\t\n\t        // 这里需要注意，官方文档setJSMainModuleName在0.51.0版本中找不到，替换为setJSMainModulePath\n\t        reactInstanceManager = ReactInstanceManager.builder()\n\t                .setApplication(getApplication())\n\t                .setBundleAssetName(\"index.android.bundle\")\n\t                .setJSMainModulePath(\"index.android\")\n\t                .addPackage(new MainReactPackage())\n\t                .setUseDeveloperSupport(BuildConfig.DEBUG)\n\t                .setInitialLifecycleState(LifecycleState.RESUMED)\n\t                .build();\n\t\n\t        //ReactNative 是项目名，需要和index.adnroid.js中的保持一致\n\t        reactRootView.startReactApplication(reactInstanceManager, \"ReactNative\", null);\n\t    }\n\t}\n```\n至此，已经完成了配置，我们可以运行当前应用到真机上，然后启动npm进行测试了\n\n### 10. 测试\n\n\t1. 启动npm，在Terminal窗口中，输入 npm start即可启动\n\t2. 运行当前App到手机上\n\t3. 手机必须和电脑在同意网段，可以使用电脑开个热点，手机连接\n\t4. 手机进入应用后，摇一摇，会出现debug的dialog，可以配置IP和端口\n\n\n### 11. 后记：\n这个文章是我一遍搭建，一边整理的，参考了[http://blog.csdn.net/github_33304260/article/details/76571961](http://blog.csdn.net/github_33304260/article/details/76571961) 可能存在配置问题，有缘人看到了，可以试试，有啥问题，随时留言或者和我联系，我再进行更新文档\n","source":"_posts/20180104集成ReactNative到已有工程.markdown","raw":"---\n\ntitle: AndroidStudio集成ReactNative到已有工程\n\ndate: 2018-01-04 19:34:46\n\ntags: [ ReactNative , 集成RN ]\n\ncategories: ReactNative\n\nkeywords: ReactNative , 集成RN \n\ndescription: AndroidStudio集成ReactNative到已有工程\n\ntop_img: http://image.jucaiwy.com/image/20180104/react_native.jpg\n\ncover: http://image.jucaiwy.com/image/20180104/react_native.jpg\n\n---\n\n最近在看ReactNative的教程，书本上都是直接npm init出来的一个个工程，我突发奇想，觉得直接继承到现有的app里边比较方便开发，说干就干，在网上查了不少资料，也跳了不少坑，现在把我搭建环境的步骤记录下来，方便以后查看\n\n\n### 1. 新建AndroidStudio工程\n\n首先需要新建AndroidStudio工程，注意使用\n\n```\ncompileSdkVersion 23\nminSdkVersion 16\ntargetSdkVersion 23\n```\n\n以及依赖：\n\n```\nimplementation 'com.android.support:appcompat-v7:23.0.1'\n```\n\n### 2. 初始化\n\n打开AndroidStudio底部的Terminal，然后再命令行模式下，输入：\n\n```bash\nnpm init\n```\n\n如图所示：\n\n![](http://image.jucaiwy.com/image/20180104/EXnbv92.png)\n\n然后，一路回车，会生成 package.json文件\n\n![](http://image.jucaiwy.com/image/20180104/q0oJTnh.png)\n\n### 3. 安装node-module\n\n继续在AndroidStudio底部的Terminal中，输入以下命令：\n```bash\nnpm install --save react react-native\n```\n\n然后，回车，大一一分多钟以后，会在工程目录中看到 node_modules 这个包，表示安装成功\n\n安装中：\n\n![](http://image.jucaiwy.com/image/20180104/3B4dP8p.png)\n\n安装成功：\n\n![](http://image.jucaiwy.com/image/20180104/QGitFFv.png)\n\n### 4. 下载.flowconfig\n\n可以使用命令下载这个文件：\n\n```bash\ncurl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig\n```\n\t\n或者直接在根目录中新建文档：.flowconfig,然后复制以下文本，在这个文件中进行保存\n\n[https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig](https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig)\n\n\n### 5. 添加index.android.js\n\n这里我们使用index.android.js为ReactNative的界面入口，也是展示HelloWord的js界面，我们可以直接在工程根目录下创建index.android.js文件，代码：\n```\n\timport React from 'react';\n\timport {\n\t    AppRegistry,\n\t    StyleSheet,\n\t    Text,\n\t    View\n\t} from 'react-native';\n\t\n\tclass HelloWorldApp extends React.Component {\n\t    render() {\n\t        return (\n\t            <View style={styles.container}>\n\t                <Text style={styles.hello}>Hello world! I am from ReactNattive!!</Text>\n\t            </View>\n\t        )\n\t    }\n\t}\n\t\n\tvar styles = StyleSheet.create({\n\t    container: {\n\t        flex: 1,\n\t        justifyContent: 'center',\n\t    },\n\t    hello: {\n\t        fontSize: 20,\n\t        textAlign: 'center',\n\t        margin: 10,\n\t    },\n\t});\n\t\n\tAppRegistry.registerComponent('ReactNative', () => HelloWorldApp);\n```\n\n这里需要注意最后一行代码，registerComponent，这里的第一个参数，必须和自己新建的Android项目名称一样，我们的项目名称是ReactNative，所以第一个参数应该是ReactNative，第二个参数和index.android.js中定义的方法名一样。\n\n所有的文件添加完成后，整个包是这样的：\n\n![](http://image.jucaiwy.com/image/20180104/7zODqQG.png)\n\n\n\n### 6. App添加依赖\n\n首先需要再ReactNative项目app模块的build.gradle目录中添加react-native依赖\n```\n\tcompile \"com.facebook.react:react-native:+\"\n```\n\n添加完成后，完整的代码如下：\n\n``` \napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 23\n    defaultConfig {\n        applicationId \"jd.com.react\"\n        minSdkVersion 16\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        // 开始修改java.lang.UnsatisfiedLinkError: dlopen failed: \"/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so\" is 32-bit instead of 64-bit\n        ndk {\n            abiFilters \"armeabi-v7a\", \"x86\"\n        }\n\n        packagingOptions {\n            exclude \"lib/arm64-v8a/librealm-jni.so\"\n        }\n        // 结束修改java.lang.UnsatisfiedLinkError: dlopen failed: \"/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so\" is 32-bit instead of 64-bit\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation 'com.android.support:appcompat-v7:23.0.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n    testImplementation 'junit:junit:4.12'\n\n    compile \"com.facebook.react:react-native:+\"\n}\n\t\n```\n\n\n这里可以看到，我们工程的编译版本已经修改为23，引用的\n\n```\ncom.android.support:appcompat-v7:23.0.1\n```\n\n\n### 7. 修改maven为本地路径\n\n在工程根目录下，找到build.gradle文件，添加maven路径为本地生成的node-modules\n\n```\nmaven {\n    // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm\n    url \"$rootDir/../node_modules/react-native/android\"\n}\n```\n\n修改完成后，完整的文件为：\n\n![](http://image.jucaiwy.com/image/20180104/RGxteet.png)\n\n\n### 8. 添加Application\n\n为当前工程指定Application，新建一个Application，继承自ReactApplication，这里需要注意的是，如果当前编译版本不是23，那么在新建这个类的时候，将会提示**找不到ReactApplication**\n\n```java\n\tpublic class MyApplication extends Application implements ReactApplication {\n    \tprivate final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {\n\t        @Override\n\t        public boolean getUseDeveloperSupport() {\n\t            return BuildConfig.DEBUG;\n\t        }\n\t\n\t        @Override\n\t        protected List<ReactPackage> getPackages() {\n\t            return Arrays.<ReactPackage>asList(\n\t                    new MainReactPackage()\n\t            );\n\t        }\n\t    };\n\n\t    @Override\n\t    public ReactNativeHost getReactNativeHost() {\n\t        return mReactNativeHost;\n\t    }\n\t\n\t    @Override\n\t    public void onCreate() {\n\t        super.onCreate();\n\t    }\n\t}\n```\n\n新建完成后：\n\n1. 需要再AndroidManifest.xml中为当前项目添加这个application的注册\n2. 需要添加网络权限，因为需要从服务端刷新js界面\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n3. 需要添加调试界面DevSettingsActivity \n```\n<activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" />\n```\n\n\n### 9. 修改MainActivity\n\n首先在MainActivity的布局文件中添加ReactRootView，我这里直接删除了之前新建工程默认出现的TextView，替换为\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\">\n\n\t <com.facebook.react.ReactRootView\n\t     android:id=\"@+id/react_root_view_id\"\n\t     android:layout_width=\"300dp\"\n\t     android:layout_height=\"300dp\" />\n</LinearLayout>\n```\n\n然后修改MainActivity：\n\n```java\npublic class MainActivity extends Activity {\n\t    ReactRootView reactRootView;\n\t    ReactInstanceManager reactInstanceManager;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.react_root_view);\n\t        reactRootView = (ReactRootView) findViewById(R.id.react_root_view_id);\n\t\n\t        // 这里需要注意，官方文档setJSMainModuleName在0.51.0版本中找不到，替换为setJSMainModulePath\n\t        reactInstanceManager = ReactInstanceManager.builder()\n\t                .setApplication(getApplication())\n\t                .setBundleAssetName(\"index.android.bundle\")\n\t                .setJSMainModulePath(\"index.android\")\n\t                .addPackage(new MainReactPackage())\n\t                .setUseDeveloperSupport(BuildConfig.DEBUG)\n\t                .setInitialLifecycleState(LifecycleState.RESUMED)\n\t                .build();\n\t\n\t        //ReactNative 是项目名，需要和index.adnroid.js中的保持一致\n\t        reactRootView.startReactApplication(reactInstanceManager, \"ReactNative\", null);\n\t    }\n\t}\n```\n至此，已经完成了配置，我们可以运行当前应用到真机上，然后启动npm进行测试了\n\n### 10. 测试\n\n\t1. 启动npm，在Terminal窗口中，输入 npm start即可启动\n\t2. 运行当前App到手机上\n\t3. 手机必须和电脑在同意网段，可以使用电脑开个热点，手机连接\n\t4. 手机进入应用后，摇一摇，会出现debug的dialog，可以配置IP和端口\n\n\n### 11. 后记：\n这个文章是我一遍搭建，一边整理的，参考了[http://blog.csdn.net/github_33304260/article/details/76571961](http://blog.csdn.net/github_33304260/article/details/76571961) 可能存在配置问题，有缘人看到了，可以试试，有啥问题，随时留言或者和我联系，我再进行更新文档\n","slug":"20180104集成ReactNative到已有工程","published":1,"updated":"2020-12-09T06:36:49.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurx001rb3t11agz5uev","content":"<p>最近在看ReactNative的教程，书本上都是直接npm init出来的一个个工程，我突发奇想，觉得直接继承到现有的app里边比较方便开发，说干就干，在网上查了不少资料，也跳了不少坑，现在把我搭建环境的步骤记录下来，方便以后查看</p>\n<h3 id=\"1-新建AndroidStudio工程\"><a href=\"#1-新建AndroidStudio工程\" class=\"headerlink\" title=\"1. 新建AndroidStudio工程\"></a>1. 新建AndroidStudio工程</h3><p>首先需要新建AndroidStudio工程，注意使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileSdkVersion 23</span><br><span class=\"line\">minSdkVersion 16</span><br><span class=\"line\">targetSdkVersion 23</span><br></pre></td></tr></table></figure>\n\n<p>以及依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2. 初始化\"></a>2. 初始化</h3><p>打开AndroidStudio底部的Terminal，然后再命令行模式下，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/EXnbv92.png\"></p>\n<p>然后，一路回车，会生成 package.json文件</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/q0oJTnh.png\"></p>\n<h3 id=\"3-安装node-module\"><a href=\"#3-安装node-module\" class=\"headerlink\" title=\"3. 安装node-module\"></a>3. 安装node-module</h3><p>继续在AndroidStudio底部的Terminal中，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react react-native</span><br></pre></td></tr></table></figure>\n\n<p>然后，回车，大一一分多钟以后，会在工程目录中看到 node_modules 这个包，表示安装成功</p>\n<p>安装中：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/3B4dP8p.png\"></p>\n<p>安装成功：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/QGitFFv.png\"></p>\n<h3 id=\"4-下载-flowconfig\"><a href=\"#4-下载-flowconfig\" class=\"headerlink\" title=\"4. 下载.flowconfig\"></a>4. 下载.flowconfig</h3><p>可以使用命令下载这个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</span><br></pre></td></tr></table></figure>\n<p>或者直接在根目录中新建文档：.flowconfig,然后复制以下文本，在这个文件中进行保存</p>\n<p><a href=\"https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig\">https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</a></p>\n<h3 id=\"5-添加index-android-js\"><a href=\"#5-添加index-android-js\" class=\"headerlink\" title=\"5. 添加index.android.js\"></a>5. 添加index.android.js</h3><p>这里我们使用index.android.js为ReactNative的界面入口，也是展示HelloWord的js界面，我们可以直接在工程根目录下创建index.android.js文件，代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">    AppRegistry,</span><br><span class=\"line\">    StyleSheet,</span><br><span class=\"line\">    Text,</span><br><span class=\"line\">    View</span><br><span class=\"line\">&#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class HelloWorldApp extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">                &lt;Text style=&#123;styles.hello&#125;&gt;Hello world! I am from ReactNattive!!&lt;/Text&gt;</span><br><span class=\"line\">            &lt;/View&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">    container: &#123;</span><br><span class=\"line\">        flex: 1,</span><br><span class=\"line\">        justifyContent: &#x27;center&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    hello: &#123;</span><br><span class=\"line\">        fontSize: 20,</span><br><span class=\"line\">        textAlign: &#x27;center&#x27;,</span><br><span class=\"line\">        margin: 10,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">AppRegistry.registerComponent(&#x27;ReactNative&#x27;, () =&gt; HelloWorldApp);</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意最后一行代码，registerComponent，这里的第一个参数，必须和自己新建的Android项目名称一样，我们的项目名称是ReactNative，所以第一个参数应该是ReactNative，第二个参数和index.android.js中定义的方法名一样。</p>\n<p>所有的文件添加完成后，整个包是这样的：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/7zODqQG.png\"></p>\n<h3 id=\"6-App添加依赖\"><a href=\"#6-App添加依赖\" class=\"headerlink\" title=\"6. App添加依赖\"></a>6. App添加依赖</h3><p>首先需要再ReactNative项目app模块的build.gradle目录中添加react-native依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &quot;com.facebook.react:react-native:+&quot;</span><br></pre></td></tr></table></figure>\n\n<p>添加完成后，完整的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;com.android.application&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion 23</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId &quot;jd.com.react&quot;</span><br><span class=\"line\">        minSdkVersion 16</span><br><span class=\"line\">        targetSdkVersion 23</span><br><span class=\"line\">        versionCode 1</span><br><span class=\"line\">        versionName &quot;1.0&quot;</span><br><span class=\"line\">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class=\"line\">        // 开始修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        packagingOptions &#123;</span><br><span class=\"line\">            exclude &quot;lib/arm64-v8a/librealm-jni.so&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 结束修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(include: [&#x27;*.jar&#x27;], dir: &#x27;libs&#x27;)</span><br><span class=\"line\">    implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br><span class=\"line\">    implementation &#x27;com.android.support.constraint:constraint-layout:1.0.2&#x27;</span><br><span class=\"line\">    testImplementation &#x27;junit:junit:4.12&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    compile &quot;com.facebook.react:react-native:+&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n<p>这里可以看到，我们工程的编译版本已经修改为23，引用的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.android.support:appcompat-v7:23.0.1</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-修改maven为本地路径\"><a href=\"#7-修改maven为本地路径\" class=\"headerlink\" title=\"7. 修改maven为本地路径\"></a>7. 修改maven为本地路径</h3><p>在工程根目录下，找到build.gradle文件，添加maven路径为本地生成的node-modules</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maven &#123;</span><br><span class=\"line\">    // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</span><br><span class=\"line\">    url &quot;$rootDir/../node_modules/react-native/android&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改完成后，完整的文件为：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/RGxteet.png\"></p>\n<h3 id=\"8-添加Application\"><a href=\"#8-添加Application\" class=\"headerlink\" title=\"8. 添加Application\"></a>8. 添加Application</h3><p>为当前工程指定Application，新建一个Application，继承自ReactApplication，这里需要注意的是，如果当前编译版本不是23，那么在新建这个类的时候，将会提示<strong>找不到ReactApplication</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Application</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ReactApplication</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReactNativeHost</span> <span class=\"variable\">mReactNativeHost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReactNativeHost</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">getUseDeveloperSupport</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> BuildConfig.DEBUG;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> List&lt;ReactPackage&gt; <span class=\"title function_\">getPackages</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">MainReactPackage</span>()</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReactNativeHost <span class=\"title function_\">getReactNativeHost</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReactNativeHost;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后：</p>\n<ol>\n<li>需要再AndroidManifest.xml中为当前项目添加这个application的注册</li>\n<li>需要添加网络权限，因为需要从服务端刷新js界面<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure></li>\n<li>需要添加调试界面DevSettingsActivity <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"9-修改MainActivity\"><a href=\"#9-修改MainActivity\" class=\"headerlink\" title=\"9. 修改MainActivity\"></a>9. 修改MainActivity</h3><p>首先在MainActivity的布局文件中添加ReactRootView，我这里直接删除了之前新建工程默认出现的TextView，替换为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:gravity</span>=<span class=\"string\">&quot;center&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">&quot;vertical&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">com.facebook.react.ReactRootView</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/react_root_view_id&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;300dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;300dp&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后修改MainActivity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;</span><br><span class=\"line\">\t    ReactRootView reactRootView;</span><br><span class=\"line\">\t    ReactInstanceManager reactInstanceManager;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">\t        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">\t        setContentView(R.layout.react_root_view);</span><br><span class=\"line\">\t        reactRootView = (ReactRootView) findViewById(R.id.react_root_view_id);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        <span class=\"comment\">// 这里需要注意，官方文档setJSMainModuleName在0.51.0版本中找不到，替换为setJSMainModulePath</span></span><br><span class=\"line\">\t        reactInstanceManager = ReactInstanceManager.builder()</span><br><span class=\"line\">\t                .setApplication(getApplication())</span><br><span class=\"line\">\t                .setBundleAssetName(<span class=\"string\">&quot;index.android.bundle&quot;</span>)</span><br><span class=\"line\">\t                .setJSMainModulePath(<span class=\"string\">&quot;index.android&quot;</span>)</span><br><span class=\"line\">\t                .addPackage(<span class=\"keyword\">new</span> <span class=\"title class_\">MainReactPackage</span>())</span><br><span class=\"line\">\t                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class=\"line\">\t                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class=\"line\">\t                .build();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        <span class=\"comment\">//ReactNative 是项目名，需要和index.adnroid.js中的保持一致</span></span><br><span class=\"line\">\t        reactRootView.startReactApplication(reactInstanceManager, <span class=\"string\">&quot;ReactNative&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，已经完成了配置，我们可以运行当前应用到真机上，然后启动npm进行测试了</p>\n<h3 id=\"10-测试\"><a href=\"#10-测试\" class=\"headerlink\" title=\"10. 测试\"></a>10. 测试</h3><pre><code>1. 启动npm，在Terminal窗口中，输入 npm start即可启动\n2. 运行当前App到手机上\n3. 手机必须和电脑在同意网段，可以使用电脑开个热点，手机连接\n4. 手机进入应用后，摇一摇，会出现debug的dialog，可以配置IP和端口\n</code></pre>\n<h3 id=\"11-后记：\"><a href=\"#11-后记：\" class=\"headerlink\" title=\"11. 后记：\"></a>11. 后记：</h3><p>这个文章是我一遍搭建，一边整理的，参考了<a href=\"http://blog.csdn.net/github_33304260/article/details/76571961\">http://blog.csdn.net/github_33304260&#x2F;article&#x2F;details&#x2F;76571961</a> 可能存在配置问题，有缘人看到了，可以试试，有啥问题，随时留言或者和我联系，我再进行更新文档</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在看ReactNative的教程，书本上都是直接npm init出来的一个个工程，我突发奇想，觉得直接继承到现有的app里边比较方便开发，说干就干，在网上查了不少资料，也跳了不少坑，现在把我搭建环境的步骤记录下来，方便以后查看</p>\n<h3 id=\"1-新建AndroidStudio工程\"><a href=\"#1-新建AndroidStudio工程\" class=\"headerlink\" title=\"1. 新建AndroidStudio工程\"></a>1. 新建AndroidStudio工程</h3><p>首先需要新建AndroidStudio工程，注意使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileSdkVersion 23</span><br><span class=\"line\">minSdkVersion 16</span><br><span class=\"line\">targetSdkVersion 23</span><br></pre></td></tr></table></figure>\n\n<p>以及依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2. 初始化\"></a>2. 初始化</h3><p>打开AndroidStudio底部的Terminal，然后再命令行模式下，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/EXnbv92.png\"></p>\n<p>然后，一路回车，会生成 package.json文件</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/q0oJTnh.png\"></p>\n<h3 id=\"3-安装node-module\"><a href=\"#3-安装node-module\" class=\"headerlink\" title=\"3. 安装node-module\"></a>3. 安装node-module</h3><p>继续在AndroidStudio底部的Terminal中，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react react-native</span><br></pre></td></tr></table></figure>\n\n<p>然后，回车，大一一分多钟以后，会在工程目录中看到 node_modules 这个包，表示安装成功</p>\n<p>安装中：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/3B4dP8p.png\"></p>\n<p>安装成功：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/QGitFFv.png\"></p>\n<h3 id=\"4-下载-flowconfig\"><a href=\"#4-下载-flowconfig\" class=\"headerlink\" title=\"4. 下载.flowconfig\"></a>4. 下载.flowconfig</h3><p>可以使用命令下载这个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</span><br></pre></td></tr></table></figure>\n<p>或者直接在根目录中新建文档：.flowconfig,然后复制以下文本，在这个文件中进行保存</p>\n<p><a href=\"https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig\">https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</a></p>\n<h3 id=\"5-添加index-android-js\"><a href=\"#5-添加index-android-js\" class=\"headerlink\" title=\"5. 添加index.android.js\"></a>5. 添加index.android.js</h3><p>这里我们使用index.android.js为ReactNative的界面入口，也是展示HelloWord的js界面，我们可以直接在工程根目录下创建index.android.js文件，代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">    AppRegistry,</span><br><span class=\"line\">    StyleSheet,</span><br><span class=\"line\">    Text,</span><br><span class=\"line\">    View</span><br><span class=\"line\">&#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class HelloWorldApp extends React.Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class=\"line\">                &lt;Text style=&#123;styles.hello&#125;&gt;Hello world! I am from ReactNattive!!&lt;/Text&gt;</span><br><span class=\"line\">            &lt;/View&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var styles = StyleSheet.create(&#123;</span><br><span class=\"line\">    container: &#123;</span><br><span class=\"line\">        flex: 1,</span><br><span class=\"line\">        justifyContent: &#x27;center&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    hello: &#123;</span><br><span class=\"line\">        fontSize: 20,</span><br><span class=\"line\">        textAlign: &#x27;center&#x27;,</span><br><span class=\"line\">        margin: 10,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">AppRegistry.registerComponent(&#x27;ReactNative&#x27;, () =&gt; HelloWorldApp);</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意最后一行代码，registerComponent，这里的第一个参数，必须和自己新建的Android项目名称一样，我们的项目名称是ReactNative，所以第一个参数应该是ReactNative，第二个参数和index.android.js中定义的方法名一样。</p>\n<p>所有的文件添加完成后，整个包是这样的：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/7zODqQG.png\"></p>\n<h3 id=\"6-App添加依赖\"><a href=\"#6-App添加依赖\" class=\"headerlink\" title=\"6. App添加依赖\"></a>6. App添加依赖</h3><p>首先需要再ReactNative项目app模块的build.gradle目录中添加react-native依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &quot;com.facebook.react:react-native:+&quot;</span><br></pre></td></tr></table></figure>\n\n<p>添加完成后，完整的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;com.android.application&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion 23</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId &quot;jd.com.react&quot;</span><br><span class=\"line\">        minSdkVersion 16</span><br><span class=\"line\">        targetSdkVersion 23</span><br><span class=\"line\">        versionCode 1</span><br><span class=\"line\">        versionName &quot;1.0&quot;</span><br><span class=\"line\">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class=\"line\">        // 开始修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        packagingOptions &#123;</span><br><span class=\"line\">            exclude &quot;lib/arm64-v8a/librealm-jni.so&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 结束修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(include: [&#x27;*.jar&#x27;], dir: &#x27;libs&#x27;)</span><br><span class=\"line\">    implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br><span class=\"line\">    implementation &#x27;com.android.support.constraint:constraint-layout:1.0.2&#x27;</span><br><span class=\"line\">    testImplementation &#x27;junit:junit:4.12&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    compile &quot;com.facebook.react:react-native:+&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n<p>这里可以看到，我们工程的编译版本已经修改为23，引用的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.android.support:appcompat-v7:23.0.1</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-修改maven为本地路径\"><a href=\"#7-修改maven为本地路径\" class=\"headerlink\" title=\"7. 修改maven为本地路径\"></a>7. 修改maven为本地路径</h3><p>在工程根目录下，找到build.gradle文件，添加maven路径为本地生成的node-modules</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maven &#123;</span><br><span class=\"line\">    // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</span><br><span class=\"line\">    url &quot;$rootDir/../node_modules/react-native/android&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改完成后，完整的文件为：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20180104/RGxteet.png\"></p>\n<h3 id=\"8-添加Application\"><a href=\"#8-添加Application\" class=\"headerlink\" title=\"8. 添加Application\"></a>8. 添加Application</h3><p>为当前工程指定Application，新建一个Application，继承自ReactApplication，这里需要注意的是，如果当前编译版本不是23，那么在新建这个类的时候，将会提示<strong>找不到ReactApplication</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Application</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ReactApplication</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReactNativeHost</span> <span class=\"variable\">mReactNativeHost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReactNativeHost</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">getUseDeveloperSupport</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> BuildConfig.DEBUG;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> List&lt;ReactPackage&gt; <span class=\"title function_\">getPackages</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">MainReactPackage</span>()</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReactNativeHost <span class=\"title function_\">getReactNativeHost</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReactNativeHost;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后：</p>\n<ol>\n<li>需要再AndroidManifest.xml中为当前项目添加这个application的注册</li>\n<li>需要添加网络权限，因为需要从服务端刷新js界面<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure></li>\n<li>需要添加调试界面DevSettingsActivity <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"9-修改MainActivity\"><a href=\"#9-修改MainActivity\" class=\"headerlink\" title=\"9. 修改MainActivity\"></a>9. 修改MainActivity</h3><p>首先在MainActivity的布局文件中添加ReactRootView，我这里直接删除了之前新建工程默认出现的TextView，替换为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:gravity</span>=<span class=\"string\">&quot;center&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">&quot;vertical&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">com.facebook.react.ReactRootView</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/react_root_view_id&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;300dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t     <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;300dp&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后修改MainActivity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;</span><br><span class=\"line\">\t    ReactRootView reactRootView;</span><br><span class=\"line\">\t    ReactInstanceManager reactInstanceManager;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">\t        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">\t        setContentView(R.layout.react_root_view);</span><br><span class=\"line\">\t        reactRootView = (ReactRootView) findViewById(R.id.react_root_view_id);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        <span class=\"comment\">// 这里需要注意，官方文档setJSMainModuleName在0.51.0版本中找不到，替换为setJSMainModulePath</span></span><br><span class=\"line\">\t        reactInstanceManager = ReactInstanceManager.builder()</span><br><span class=\"line\">\t                .setApplication(getApplication())</span><br><span class=\"line\">\t                .setBundleAssetName(<span class=\"string\">&quot;index.android.bundle&quot;</span>)</span><br><span class=\"line\">\t                .setJSMainModulePath(<span class=\"string\">&quot;index.android&quot;</span>)</span><br><span class=\"line\">\t                .addPackage(<span class=\"keyword\">new</span> <span class=\"title class_\">MainReactPackage</span>())</span><br><span class=\"line\">\t                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class=\"line\">\t                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class=\"line\">\t                .build();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        <span class=\"comment\">//ReactNative 是项目名，需要和index.adnroid.js中的保持一致</span></span><br><span class=\"line\">\t        reactRootView.startReactApplication(reactInstanceManager, <span class=\"string\">&quot;ReactNative&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，已经完成了配置，我们可以运行当前应用到真机上，然后启动npm进行测试了</p>\n<h3 id=\"10-测试\"><a href=\"#10-测试\" class=\"headerlink\" title=\"10. 测试\"></a>10. 测试</h3><pre><code>1. 启动npm，在Terminal窗口中，输入 npm start即可启动\n2. 运行当前App到手机上\n3. 手机必须和电脑在同意网段，可以使用电脑开个热点，手机连接\n4. 手机进入应用后，摇一摇，会出现debug的dialog，可以配置IP和端口\n</code></pre>\n<h3 id=\"11-后记：\"><a href=\"#11-后记：\" class=\"headerlink\" title=\"11. 后记：\"></a>11. 后记：</h3><p>这个文章是我一遍搭建，一边整理的，参考了<a href=\"http://blog.csdn.net/github_33304260/article/details/76571961\">http://blog.csdn.net/github_33304260&#x2F;article&#x2F;details&#x2F;76571961</a> 可能存在配置问题，有缘人看到了，可以试试，有啥问题，随时留言或者和我联系，我再进行更新文档</p>\n"},{"title":"Flutter—Json数据格式化","date":"2019-11-28T06:54:46.000Z","keywords":"Flutter,Json,序列化和反序列化","description":"Flutter—Json数据格式化","top_img":"http://image.jucaiwy.com/image/20191128/flutter_json.jpeg","cover":"http://image.jucaiwy.com/image/20191128/flutter_json.jpeg","_content":"\n因为Flutter中禁止使用运行时反射，因为运行时反射回干扰Dart的**tree shaking**(具体是什么，我也不知道)，所以之前在Java中使用Gson等序列化工具，无法在Flutter中正常使用。同样的道理，Dart中支持的dartson，也是使用了运行时反射，所以也不能在Flutter中使用。\n\n在Flutter中，我们一般使用自动化源码生成器[ json_serializable package ](https://pub.dartlang.org/packages/json_serializable)包，在开发阶段，生成Json序列化和反序列化的模版。具体使用方式如下：\n\n### 1. 在项目中配置json_serializable的依赖\n想将json_serializable引入到我们的项目中，需要完成两个依赖，一个是开发依赖，一个是常规依赖，如下：\n\n```dart\ndependencies:\n  # Your other regular dependencies here\n  json_annotation: ^2.0.0\n\ndev_dependencies:\n  # Your other dev_dependencies here\n  build_runner: ^1.1.3\n  json_serializable: ^2.0.0\n```\n配置完成以后，需要执行** flutter packages get **命令进行相关依赖包的导入。\n\n### 2. 以json_serializable的方式创建Model类\n\n使用json_serializable方式创建Model类，可以按照以下几步进行操作：\n \n#### 2.1 创建Model类文件 test_user.dart\n\n#### 2.2 创建Model类，包含相关字段。\n```dart\n/// 用户信息\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n}\n```\n#### 2.3 给Model类添加json_serializable的注解@JsonSerializable()\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\n/// 用户信息\n@JsonSerializable()\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n}\n```\n#### 2.4 代码引入part，引入fromJson和toJson方法\n这里part好像是需要自己手动写上，还有下边的fromJson和toJson方法也是需要自己进行手动添加，不知道是否有快捷键，没找到，暂且手写吧。\n\n**这里需要注意的是，一定要添加默认构造方法，否则会编译不通过。**\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'test_user.g.dart';\n\n/// 用户信息\n@JsonSerializable()\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n\n  // 默认构造函数\n  UserInfo(this.name, this.userAge, this.isMarried);\n\n  factory UserInfo.fromJson(Map<String, dynamic> json) =>\n      _$UserInfoFromJson(json);\n\n  Map<String, dynamic> toJson() => _$UserInfoToJson(this);\n}\n\n```\n加入这些方法后，发现新加入的part以及fromJson及toJson方法无法找到，这时候我们需要使用**flutter packages**命令进行生成相应的test_user.g.dart类。\n\n这里可以使用单次build命令进行生成：\n\n```bash\nflutter packages pub run build_runner build\n```\n也可以使用watch模式，进行监控生成，在所有的JsonBean对象都生成以后，使用control+c退出命令行模式，会生成相对应的.g.dart文件。\n```bash\nflutter packages pub run build_runner build\n```\n此时，之前新建的**test_user.dart**同级目录下，会生成之前part中输入的**test_user.g.dart**文件，截止目前，Flutter可以使用的Json序列化对象，已经构建完成。\n\n### 3. FlutterJson对象使用方法\n使用时，直接可以使用UserInfo.fromJson，进行json解析，或者是userInfo.toJson，进行json序列化。需要注意以下几点：\n\n    1. Flutter中json将数据格式比较严格，不像Gson中，double的值，也可使用String去解析，必须一一对应。\n\n    2. 需要解析的对象中，如果有定义了一个服务端么有下发的bool值，并赋初始值为false时，经过json解析后，为null。没明白为啥，但是的确是这样子，bool可以为bull\n\n\n![](http://image.jucaiwy.com/image/20191128/flutter_json.jpeg)\n\n\n\n\n","source":"_posts/20191128Flutter—Json数据格式化.md","raw":"---\n\ntitle: Flutter—Json数据格式化\n\ndate: 2019-11-28 14:54:46\n\ntags: [Flutter ,Json ,序列化和反序列化]\n\ncategories: Flutter\n\nkeywords: Flutter,Json,序列化和反序列化\n\ndescription: Flutter—Json数据格式化\n\ntop_img: http://image.jucaiwy.com/image/20191128/flutter_json.jpeg\n\ncover: http://image.jucaiwy.com/image/20191128/flutter_json.jpeg\n\n---\n\n因为Flutter中禁止使用运行时反射，因为运行时反射回干扰Dart的**tree shaking**(具体是什么，我也不知道)，所以之前在Java中使用Gson等序列化工具，无法在Flutter中正常使用。同样的道理，Dart中支持的dartson，也是使用了运行时反射，所以也不能在Flutter中使用。\n\n在Flutter中，我们一般使用自动化源码生成器[ json_serializable package ](https://pub.dartlang.org/packages/json_serializable)包，在开发阶段，生成Json序列化和反序列化的模版。具体使用方式如下：\n\n### 1. 在项目中配置json_serializable的依赖\n想将json_serializable引入到我们的项目中，需要完成两个依赖，一个是开发依赖，一个是常规依赖，如下：\n\n```dart\ndependencies:\n  # Your other regular dependencies here\n  json_annotation: ^2.0.0\n\ndev_dependencies:\n  # Your other dev_dependencies here\n  build_runner: ^1.1.3\n  json_serializable: ^2.0.0\n```\n配置完成以后，需要执行** flutter packages get **命令进行相关依赖包的导入。\n\n### 2. 以json_serializable的方式创建Model类\n\n使用json_serializable方式创建Model类，可以按照以下几步进行操作：\n \n#### 2.1 创建Model类文件 test_user.dart\n\n#### 2.2 创建Model类，包含相关字段。\n```dart\n/// 用户信息\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n}\n```\n#### 2.3 给Model类添加json_serializable的注解@JsonSerializable()\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\n/// 用户信息\n@JsonSerializable()\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n}\n```\n#### 2.4 代码引入part，引入fromJson和toJson方法\n这里part好像是需要自己手动写上，还有下边的fromJson和toJson方法也是需要自己进行手动添加，不知道是否有快捷键，没找到，暂且手写吧。\n\n**这里需要注意的是，一定要添加默认构造方法，否则会编译不通过。**\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'test_user.g.dart';\n\n/// 用户信息\n@JsonSerializable()\nclass UserInfo {\n  // 名字\n  String name;\n\n  // 年龄\n  int userAge;\n\n  // 是否结婚\n  bool isMarried;\n\n  // 默认构造函数\n  UserInfo(this.name, this.userAge, this.isMarried);\n\n  factory UserInfo.fromJson(Map<String, dynamic> json) =>\n      _$UserInfoFromJson(json);\n\n  Map<String, dynamic> toJson() => _$UserInfoToJson(this);\n}\n\n```\n加入这些方法后，发现新加入的part以及fromJson及toJson方法无法找到，这时候我们需要使用**flutter packages**命令进行生成相应的test_user.g.dart类。\n\n这里可以使用单次build命令进行生成：\n\n```bash\nflutter packages pub run build_runner build\n```\n也可以使用watch模式，进行监控生成，在所有的JsonBean对象都生成以后，使用control+c退出命令行模式，会生成相对应的.g.dart文件。\n```bash\nflutter packages pub run build_runner build\n```\n此时，之前新建的**test_user.dart**同级目录下，会生成之前part中输入的**test_user.g.dart**文件，截止目前，Flutter可以使用的Json序列化对象，已经构建完成。\n\n### 3. FlutterJson对象使用方法\n使用时，直接可以使用UserInfo.fromJson，进行json解析，或者是userInfo.toJson，进行json序列化。需要注意以下几点：\n\n    1. Flutter中json将数据格式比较严格，不像Gson中，double的值，也可使用String去解析，必须一一对应。\n\n    2. 需要解析的对象中，如果有定义了一个服务端么有下发的bool值，并赋初始值为false时，经过json解析后，为null。没明白为啥，但是的确是这样子，bool可以为bull\n\n\n![](http://image.jucaiwy.com/image/20191128/flutter_json.jpeg)\n\n\n\n\n","slug":"20191128Flutter—Json数据格式化","published":1,"updated":"2022-04-19T07:13:28.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl278jurx001vb3t1ebxm6sqc","content":"<p>因为Flutter中禁止使用运行时反射，因为运行时反射回干扰Dart的<strong>tree shaking</strong>(具体是什么，我也不知道)，所以之前在Java中使用Gson等序列化工具，无法在Flutter中正常使用。同样的道理，Dart中支持的dartson，也是使用了运行时反射，所以也不能在Flutter中使用。</p>\n<p>在Flutter中，我们一般使用自动化源码生成器<a href=\"https://pub.dartlang.org/packages/json_serializable\"> json_serializable package </a>包，在开发阶段，生成Json序列化和反序列化的模版。具体使用方式如下：</p>\n<h3 id=\"1-在项目中配置json-serializable的依赖\"><a href=\"#1-在项目中配置json-serializable的依赖\" class=\"headerlink\" title=\"1. 在项目中配置json_serializable的依赖\"></a>1. 在项目中配置json_serializable的依赖</h3><p>想将json_serializable引入到我们的项目中，需要完成两个依赖，一个是开发依赖，一个是常规依赖，如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  # Your other regular dependencies here</span><br><span class=\"line\">  json_annotation: ^<span class=\"number\">2.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">dev_dependencies:</span><br><span class=\"line\">  # Your other dev_dependencies here</span><br><span class=\"line\">  build_runner: ^<span class=\"number\">1.1</span><span class=\"number\">.3</span></span><br><span class=\"line\">  json_serializable: ^<span class=\"number\">2.0</span><span class=\"number\">.0</span></span><br></pre></td></tr></table></figure>\n<p>配置完成以后，需要执行** flutter packages get **命令进行相关依赖包的导入。</p>\n<h3 id=\"2-以json-serializable的方式创建Model类\"><a href=\"#2-以json-serializable的方式创建Model类\" class=\"headerlink\" title=\"2. 以json_serializable的方式创建Model类\"></a>2. 以json_serializable的方式创建Model类</h3><p>使用json_serializable方式创建Model类，可以按照以下几步进行操作：</p>\n<h4 id=\"2-1-创建Model类文件-test-user-dart\"><a href=\"#2-1-创建Model类文件-test-user-dart\" class=\"headerlink\" title=\"2.1 创建Model类文件 test_user.dart\"></a>2.1 创建Model类文件 test_user.dart</h4><h4 id=\"2-2-创建Model类，包含相关字段。\"><a href=\"#2-2-创建Model类，包含相关字段。\" class=\"headerlink\" title=\"2.2 创建Model类，包含相关字段。\"></a>2.2 创建Model类，包含相关字段。</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-给Model类添加json-serializable的注解-JsonSerializable\"><a href=\"#2-3-给Model类添加json-serializable的注解-JsonSerializable\" class=\"headerlink\" title=\"2.3 给Model类添加json_serializable的注解@JsonSerializable()\"></a>2.3 给Model类添加json_serializable的注解@JsonSerializable()</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"meta\">@JsonSerializable</span>()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-代码引入part，引入fromJson和toJson方法\"><a href=\"#2-4-代码引入part，引入fromJson和toJson方法\" class=\"headerlink\" title=\"2.4 代码引入part，引入fromJson和toJson方法\"></a>2.4 代码引入part，引入fromJson和toJson方法</h4><p>这里part好像是需要自己手动写上，还有下边的fromJson和toJson方法也是需要自己进行手动添加，不知道是否有快捷键，没找到，暂且手写吧。</p>\n<p><strong>这里需要注意的是，一定要添加默认构造方法，否则会编译不通过。</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">part</span> <span class=\"string\">&#x27;test_user.g.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"meta\">@JsonSerializable</span>()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">  UserInfo(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.userAge, <span class=\"keyword\">this</span>.isMarried);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> UserInfo.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">dynamic</span>&gt; json) =&gt;</span><br><span class=\"line\">      _$UserInfoFromJson(json);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">dynamic</span>&gt; toJson() =&gt; _$UserInfoToJson(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>加入这些方法后，发现新加入的part以及fromJson及toJson方法无法找到，这时候我们需要使用<strong>flutter packages</strong>命令进行生成相应的test_user.g.dart类。</p>\n<p>这里可以使用单次build命令进行生成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>\n<p>也可以使用watch模式，进行监控生成，在所有的JsonBean对象都生成以后，使用control+c退出命令行模式，会生成相对应的.g.dart文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>\n<p>此时，之前新建的<strong>test_user.dart</strong>同级目录下，会生成之前part中输入的<strong>test_user.g.dart</strong>文件，截止目前，Flutter可以使用的Json序列化对象，已经构建完成。</p>\n<h3 id=\"3-FlutterJson对象使用方法\"><a href=\"#3-FlutterJson对象使用方法\" class=\"headerlink\" title=\"3. FlutterJson对象使用方法\"></a>3. FlutterJson对象使用方法</h3><p>使用时，直接可以使用UserInfo.fromJson，进行json解析，或者是userInfo.toJson，进行json序列化。需要注意以下几点：</p>\n<pre><code>1. Flutter中json将数据格式比较严格，不像Gson中，double的值，也可使用String去解析，必须一一对应。\n\n2. 需要解析的对象中，如果有定义了一个服务端么有下发的bool值，并赋初始值为false时，经过json解析后，为null。没明白为啥，但是的确是这样子，bool可以为bull\n</code></pre>\n<p><img src=\"http://image.jucaiwy.com/image/20191128/flutter_json.jpeg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为Flutter中禁止使用运行时反射，因为运行时反射回干扰Dart的<strong>tree shaking</strong>(具体是什么，我也不知道)，所以之前在Java中使用Gson等序列化工具，无法在Flutter中正常使用。同样的道理，Dart中支持的dartson，也是使用了运行时反射，所以也不能在Flutter中使用。</p>\n<p>在Flutter中，我们一般使用自动化源码生成器<a href=\"https://pub.dartlang.org/packages/json_serializable\"> json_serializable package </a>包，在开发阶段，生成Json序列化和反序列化的模版。具体使用方式如下：</p>\n<h3 id=\"1-在项目中配置json-serializable的依赖\"><a href=\"#1-在项目中配置json-serializable的依赖\" class=\"headerlink\" title=\"1. 在项目中配置json_serializable的依赖\"></a>1. 在项目中配置json_serializable的依赖</h3><p>想将json_serializable引入到我们的项目中，需要完成两个依赖，一个是开发依赖，一个是常规依赖，如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  # Your other regular dependencies here</span><br><span class=\"line\">  json_annotation: ^<span class=\"number\">2.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">dev_dependencies:</span><br><span class=\"line\">  # Your other dev_dependencies here</span><br><span class=\"line\">  build_runner: ^<span class=\"number\">1.1</span><span class=\"number\">.3</span></span><br><span class=\"line\">  json_serializable: ^<span class=\"number\">2.0</span><span class=\"number\">.0</span></span><br></pre></td></tr></table></figure>\n<p>配置完成以后，需要执行** flutter packages get **命令进行相关依赖包的导入。</p>\n<h3 id=\"2-以json-serializable的方式创建Model类\"><a href=\"#2-以json-serializable的方式创建Model类\" class=\"headerlink\" title=\"2. 以json_serializable的方式创建Model类\"></a>2. 以json_serializable的方式创建Model类</h3><p>使用json_serializable方式创建Model类，可以按照以下几步进行操作：</p>\n<h4 id=\"2-1-创建Model类文件-test-user-dart\"><a href=\"#2-1-创建Model类文件-test-user-dart\" class=\"headerlink\" title=\"2.1 创建Model类文件 test_user.dart\"></a>2.1 创建Model类文件 test_user.dart</h4><h4 id=\"2-2-创建Model类，包含相关字段。\"><a href=\"#2-2-创建Model类，包含相关字段。\" class=\"headerlink\" title=\"2.2 创建Model类，包含相关字段。\"></a>2.2 创建Model类，包含相关字段。</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-给Model类添加json-serializable的注解-JsonSerializable\"><a href=\"#2-3-给Model类添加json-serializable的注解-JsonSerializable\" class=\"headerlink\" title=\"2.3 给Model类添加json_serializable的注解@JsonSerializable()\"></a>2.3 给Model类添加json_serializable的注解@JsonSerializable()</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"meta\">@JsonSerializable</span>()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-代码引入part，引入fromJson和toJson方法\"><a href=\"#2-4-代码引入part，引入fromJson和toJson方法\" class=\"headerlink\" title=\"2.4 代码引入part，引入fromJson和toJson方法\"></a>2.4 代码引入part，引入fromJson和toJson方法</h4><p>这里part好像是需要自己手动写上，还有下边的fromJson和toJson方法也是需要自己进行手动添加，不知道是否有快捷键，没找到，暂且手写吧。</p>\n<p><strong>这里需要注意的是，一定要添加默认构造方法，否则会编译不通过。</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">part</span> <span class=\"string\">&#x27;test_user.g.dart&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">用户信息</span></span></span><br><span class=\"line\"><span class=\"meta\">@JsonSerializable</span>()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 名字</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 年龄</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否结婚</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isMarried;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">  UserInfo(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.userAge, <span class=\"keyword\">this</span>.isMarried);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> UserInfo.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">dynamic</span>&gt; json) =&gt;</span><br><span class=\"line\">      _$UserInfoFromJson(json);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">dynamic</span>&gt; toJson() =&gt; _$UserInfoToJson(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>加入这些方法后，发现新加入的part以及fromJson及toJson方法无法找到，这时候我们需要使用<strong>flutter packages</strong>命令进行生成相应的test_user.g.dart类。</p>\n<p>这里可以使用单次build命令进行生成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>\n<p>也可以使用watch模式，进行监控生成，在所有的JsonBean对象都生成以后，使用control+c退出命令行模式，会生成相对应的.g.dart文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>\n<p>此时，之前新建的<strong>test_user.dart</strong>同级目录下，会生成之前part中输入的<strong>test_user.g.dart</strong>文件，截止目前，Flutter可以使用的Json序列化对象，已经构建完成。</p>\n<h3 id=\"3-FlutterJson对象使用方法\"><a href=\"#3-FlutterJson对象使用方法\" class=\"headerlink\" title=\"3. FlutterJson对象使用方法\"></a>3. FlutterJson对象使用方法</h3><p>使用时，直接可以使用UserInfo.fromJson，进行json解析，或者是userInfo.toJson，进行json序列化。需要注意以下几点：</p>\n<pre><code>1. Flutter中json将数据格式比较严格，不像Gson中，double的值，也可使用String去解析，必须一一对应。\n\n2. 需要解析的对象中，如果有定义了一个服务端么有下发的bool值，并赋初始值为false时，经过json解析后，为null。没明白为啥，但是的确是这样子，bool可以为bull\n</code></pre>\n<p><img src=\"http://image.jucaiwy.com/image/20191128/flutter_json.jpeg\"></p>\n"},{"title":"HarmonyOS开发—基础—环境搭建","date":"2023-12-22T06:54:46.000Z","keywords":"HarmonyOS , HarmonyOS开发 , HarmonyOS入门 , HarmonyOS环境搭建","description":"HarmonyOS开发","top_img":"http://image.jucaiwy.com/image/20240710/harmonyOS_logo.png","cover":"http://image.jucaiwy.com/image/20240710/harmonyOS_logo.png","_content":"\n## HarmonyOS开发—基础—环境搭建\n\n\n### 一、DevEco Studio下载\n\nDevEco Studio是基于IntelliJ IDEA Community开源版本打造，是华为提供的面向全场景多设备，提供一站式的分布式应用开发平台。支持分布式多端开发、分布式多端调测、多端模拟仿真以及全方位的质量与安全保障。我们可以在华为官网上下载自己所需要的开发工具，一般情况下，开发工具版本和HarmonyOS版本一一对应。\n\n\n\n这里最新的是DevEco Studio 3.1。配套支持HarmonyOS 3.1版本及以上的应用及服务开发，提供了代码智能编辑、低代码开发、双向预览等功能，以及轻量构建工具DevEco Hvigor 、本地模拟器，持续提升应用及服务开发效率。下载链接：https://developer.huawei.com/consumer/cn/deveco-studio/\n\n\n\n需要注意的是：DevEco Studio的编译构建依赖JDK，DevEco Studio预置了OpenJDK，版本为1.8，安装过程中会自动安装JDK。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudio%E7%AE%80%E4%BB%8B.png)\n\n下载完成以后，双击安装。\n\n### 二、DevEco Studio配置\n\nDevEcoStudio安装完成后，首次进入需要安装Node.js和ohpm。\n\n**Node.js：**一个运行在Chrome V8引擎的JavaScript运行环境。现在被广泛的运用于Web前端工程化构建中。由于鸿蒙的Ark UI框架是基于Node.js进行开发的，所以像绝大多数Web前端开发框架一样，首先要在当前操作系统中安装Node.js框架。新版本的DevEco Studio已经集成了node.js的安装，无需前置安装。\n\n**ohpm：**openharmony package manager，鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理，同样在新版本的DevEco Studio中集成了安装包。\n\n这里只需要在首页单击Agree进入配置，配置node.js和ohpm的安装源，即可。推荐选择从华为镜像直接下载安装，选择本地安装路径。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioBasic.png)\n\nNode.js和ohpm选择好以后，点击下一步，进入SDK Setup页面，选择和修改SDK安装位置：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioSDK.png)\n\n这里需要点击Next以后，需要阅读和勾选License协议，再次点击下一步进入预览页面，确认各项下载路径无误以后，点击Next开始进行下载安装。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioSummary.png)\n\n### 三、DevEco Studio主题\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioTheme.png)\n\n### 四、DevEco Studio HelloWord\n\n安装和配置完成以后，就可以开始我们的第一个项目啦，当然必须是HelloWorld。通过Create Project 创建一个Empty Ability。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioCreate.png)\n\n项目名称叫做HelloWorld，同步通过以后，可以进入HelloWorld工程中，默认是Project模式，定位到我们的Index.ets文件上。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioProject.png)\n\n这里我们也可以通过右上角目录视图切换，切换至Ohos视图：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioIndex.png)\n\n这里分别对这三个目录进行介绍：\n\nAppScope：主要用于存放整个应用公共的信息与资源\n\nentry：是默认的初始模块，其中ets中存放编写的代码文件，ets中page目录，则用来存放我们的页面文件，例如初始的index.ets就存放在ets->pages目录下；configuration中存放相应模块的配置文件；resources中存放资源文件\n\nconfiguration：工程、应用级别的配置文件\n\n**预览：**右侧Previewer点击后，可以实时预览我们编写的页面在手机上的样式：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioPreView.png)\n\n创建模拟器：通过菜单栏中Tools---DeviceManager打开这个页面，也可以通过右上角Device区域的Device Manager打开模拟器管理页面。选择好模拟器创建位置后，选择+号，可以新建本地模拟器。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioDevice.png)\n\n第一次安装系统后，会提示下载安装模拟器，根据提示下载安装即可，然后就可以选择创建。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioHardWare.png)\n\n安装完成后，可以一键运行：至此，Hello World工程，成功运行起来：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioHello.png)   \n","source":"_posts/20231221-HarmonyOS开发—基础—环境搭建.md","raw":"---\n\ntitle: HarmonyOS开发—基础—环境搭建\n\ndate: 2023-12-22 14:54:46\n\ntags: [HarmonyOS开发 , 环境搭建]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS , HarmonyOS开发 , HarmonyOS入门 , HarmonyOS环境搭建\n\ndescription: HarmonyOS开发\n\ntop_img: http://image.jucaiwy.com/image/20240710/harmonyOS_logo.png\n\ncover: http://image.jucaiwy.com/image/20240710/harmonyOS_logo.png\n\n---\n\n## HarmonyOS开发—基础—环境搭建\n\n\n### 一、DevEco Studio下载\n\nDevEco Studio是基于IntelliJ IDEA Community开源版本打造，是华为提供的面向全场景多设备，提供一站式的分布式应用开发平台。支持分布式多端开发、分布式多端调测、多端模拟仿真以及全方位的质量与安全保障。我们可以在华为官网上下载自己所需要的开发工具，一般情况下，开发工具版本和HarmonyOS版本一一对应。\n\n\n\n这里最新的是DevEco Studio 3.1。配套支持HarmonyOS 3.1版本及以上的应用及服务开发，提供了代码智能编辑、低代码开发、双向预览等功能，以及轻量构建工具DevEco Hvigor 、本地模拟器，持续提升应用及服务开发效率。下载链接：https://developer.huawei.com/consumer/cn/deveco-studio/\n\n\n\n需要注意的是：DevEco Studio的编译构建依赖JDK，DevEco Studio预置了OpenJDK，版本为1.8，安装过程中会自动安装JDK。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudio%E7%AE%80%E4%BB%8B.png)\n\n下载完成以后，双击安装。\n\n### 二、DevEco Studio配置\n\nDevEcoStudio安装完成后，首次进入需要安装Node.js和ohpm。\n\n**Node.js：**一个运行在Chrome V8引擎的JavaScript运行环境。现在被广泛的运用于Web前端工程化构建中。由于鸿蒙的Ark UI框架是基于Node.js进行开发的，所以像绝大多数Web前端开发框架一样，首先要在当前操作系统中安装Node.js框架。新版本的DevEco Studio已经集成了node.js的安装，无需前置安装。\n\n**ohpm：**openharmony package manager，鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理，同样在新版本的DevEco Studio中集成了安装包。\n\n这里只需要在首页单击Agree进入配置，配置node.js和ohpm的安装源，即可。推荐选择从华为镜像直接下载安装，选择本地安装路径。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioBasic.png)\n\nNode.js和ohpm选择好以后，点击下一步，进入SDK Setup页面，选择和修改SDK安装位置：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioSDK.png)\n\n这里需要点击Next以后，需要阅读和勾选License协议，再次点击下一步进入预览页面，确认各项下载路径无误以后，点击Next开始进行下载安装。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioSummary.png)\n\n### 三、DevEco Studio主题\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioTheme.png)\n\n### 四、DevEco Studio HelloWord\n\n安装和配置完成以后，就可以开始我们的第一个项目啦，当然必须是HelloWorld。通过Create Project 创建一个Empty Ability。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioCreate.png)\n\n项目名称叫做HelloWorld，同步通过以后，可以进入HelloWorld工程中，默认是Project模式，定位到我们的Index.ets文件上。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioProject.png)\n\n这里我们也可以通过右上角目录视图切换，切换至Ohos视图：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioIndex.png)\n\n这里分别对这三个目录进行介绍：\n\nAppScope：主要用于存放整个应用公共的信息与资源\n\nentry：是默认的初始模块，其中ets中存放编写的代码文件，ets中page目录，则用来存放我们的页面文件，例如初始的index.ets就存放在ets->pages目录下；configuration中存放相应模块的配置文件；resources中存放资源文件\n\nconfiguration：工程、应用级别的配置文件\n\n**预览：**右侧Previewer点击后，可以实时预览我们编写的页面在手机上的样式：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioPreView.png)\n\n创建模拟器：通过菜单栏中Tools---DeviceManager打开这个页面，也可以通过右上角Device区域的Device Manager打开模拟器管理页面。选择好模拟器创建位置后，选择+号，可以新建本地模拟器。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioDevice.png)\n\n第一次安装系统后，会提示下载安装模拟器，根据提示下载安装即可，然后就可以选择创建。\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioHardWare.png)\n\n安装完成后，可以一键运行：至此，Hello World工程，成功运行起来：\n\n![img](http://image.jucaiwy.com/image/20240710/DevEcoStudioHello.png)   \n","slug":"20231221-HarmonyOS开发—基础—环境搭建","published":1,"updated":"2024-07-10T10:22:22.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01600000nv64iy2f8v5","content":"<h2 id=\"HarmonyOS开发—基础—环境搭建\"><a href=\"#HarmonyOS开发—基础—环境搭建\" class=\"headerlink\" title=\"HarmonyOS开发—基础—环境搭建\"></a>HarmonyOS开发—基础—环境搭建</h2><h3 id=\"一、DevEco-Studio下载\"><a href=\"#一、DevEco-Studio下载\" class=\"headerlink\" title=\"一、DevEco Studio下载\"></a>一、DevEco Studio下载</h3><p>DevEco Studio是基于IntelliJ IDEA Community开源版本打造，是华为提供的面向全场景多设备，提供一站式的分布式应用开发平台。支持分布式多端开发、分布式多端调测、多端模拟仿真以及全方位的质量与安全保障。我们可以在华为官网上下载自己所需要的开发工具，一般情况下，开发工具版本和HarmonyOS版本一一对应。</p>\n<p>这里最新的是DevEco Studio 3.1。配套支持HarmonyOS 3.1版本及以上的应用及服务开发，提供了代码智能编辑、低代码开发、双向预览等功能，以及轻量构建工具DevEco Hvigor 、本地模拟器，持续提升应用及服务开发效率。下载链接：<a href=\"https://developer.huawei.com/consumer/cn/deveco-studio/\">https://developer.huawei.com/consumer/cn/deveco-studio/</a></p>\n<p>需要注意的是：DevEco Studio的编译构建依赖JDK，DevEco Studio预置了OpenJDK，版本为1.8，安装过程中会自动安装JDK。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudio%E7%AE%80%E4%BB%8B.png\" alt=\"img\"></p>\n<p>下载完成以后，双击安装。</p>\n<h3 id=\"二、DevEco-Studio配置\"><a href=\"#二、DevEco-Studio配置\" class=\"headerlink\" title=\"二、DevEco Studio配置\"></a>二、DevEco Studio配置</h3><p>DevEcoStudio安装完成后，首次进入需要安装Node.js和ohpm。</p>\n<p><strong>Node.js：</strong>一个运行在Chrome V8引擎的JavaScript运行环境。现在被广泛的运用于Web前端工程化构建中。由于鸿蒙的Ark UI框架是基于Node.js进行开发的，所以像绝大多数Web前端开发框架一样，首先要在当前操作系统中安装Node.js框架。新版本的DevEco Studio已经集成了node.js的安装，无需前置安装。</p>\n<p><strong>ohpm：</strong>openharmony package manager，鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理，同样在新版本的DevEco Studio中集成了安装包。</p>\n<p>这里只需要在首页单击Agree进入配置，配置node.js和ohpm的安装源，即可。推荐选择从华为镜像直接下载安装，选择本地安装路径。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioBasic.png\" alt=\"img\"></p>\n<p>Node.js和ohpm选择好以后，点击下一步，进入SDK Setup页面，选择和修改SDK安装位置：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioSDK.png\" alt=\"img\"></p>\n<p>这里需要点击Next以后，需要阅读和勾选License协议，再次点击下一步进入预览页面，确认各项下载路径无误以后，点击Next开始进行下载安装。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioSummary.png\" alt=\"img\"></p>\n<h3 id=\"三、DevEco-Studio主题\"><a href=\"#三、DevEco-Studio主题\" class=\"headerlink\" title=\"三、DevEco Studio主题\"></a>三、DevEco Studio主题</h3><p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioTheme.png\" alt=\"img\"></p>\n<h3 id=\"四、DevEco-Studio-HelloWord\"><a href=\"#四、DevEco-Studio-HelloWord\" class=\"headerlink\" title=\"四、DevEco Studio HelloWord\"></a>四、DevEco Studio HelloWord</h3><p>安装和配置完成以后，就可以开始我们的第一个项目啦，当然必须是HelloWorld。通过Create Project 创建一个Empty Ability。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioCreate.png\" alt=\"img\"></p>\n<p>项目名称叫做HelloWorld，同步通过以后，可以进入HelloWorld工程中，默认是Project模式，定位到我们的Index.ets文件上。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioProject.png\" alt=\"img\"></p>\n<p>这里我们也可以通过右上角目录视图切换，切换至Ohos视图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioIndex.png\" alt=\"img\"></p>\n<p>这里分别对这三个目录进行介绍：</p>\n<p>AppScope：主要用于存放整个应用公共的信息与资源</p>\n<p>entry：是默认的初始模块，其中ets中存放编写的代码文件，ets中page目录，则用来存放我们的页面文件，例如初始的index.ets就存放在ets-&gt;pages目录下；configuration中存放相应模块的配置文件；resources中存放资源文件</p>\n<p>configuration：工程、应用级别的配置文件</p>\n<p><strong>预览：</strong>右侧Previewer点击后，可以实时预览我们编写的页面在手机上的样式：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioPreView.png\" alt=\"img\"></p>\n<p>创建模拟器：通过菜单栏中Tools—DeviceManager打开这个页面，也可以通过右上角Device区域的Device Manager打开模拟器管理页面。选择好模拟器创建位置后，选择+号，可以新建本地模拟器。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioDevice.png\" alt=\"img\"></p>\n<p>第一次安装系统后，会提示下载安装模拟器，根据提示下载安装即可，然后就可以选择创建。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioHardWare.png\" alt=\"img\"></p>\n<p>安装完成后，可以一键运行：至此，Hello World工程，成功运行起来：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioHello.png\" alt=\"img\">   </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HarmonyOS开发—基础—环境搭建\"><a href=\"#HarmonyOS开发—基础—环境搭建\" class=\"headerlink\" title=\"HarmonyOS开发—基础—环境搭建\"></a>HarmonyOS开发—基础—环境搭建</h2><h3 id=\"一、DevEco-Studio下载\"><a href=\"#一、DevEco-Studio下载\" class=\"headerlink\" title=\"一、DevEco Studio下载\"></a>一、DevEco Studio下载</h3><p>DevEco Studio是基于IntelliJ IDEA Community开源版本打造，是华为提供的面向全场景多设备，提供一站式的分布式应用开发平台。支持分布式多端开发、分布式多端调测、多端模拟仿真以及全方位的质量与安全保障。我们可以在华为官网上下载自己所需要的开发工具，一般情况下，开发工具版本和HarmonyOS版本一一对应。</p>\n<p>这里最新的是DevEco Studio 3.1。配套支持HarmonyOS 3.1版本及以上的应用及服务开发，提供了代码智能编辑、低代码开发、双向预览等功能，以及轻量构建工具DevEco Hvigor 、本地模拟器，持续提升应用及服务开发效率。下载链接：<a href=\"https://developer.huawei.com/consumer/cn/deveco-studio/\">https://developer.huawei.com/consumer/cn/deveco-studio/</a></p>\n<p>需要注意的是：DevEco Studio的编译构建依赖JDK，DevEco Studio预置了OpenJDK，版本为1.8，安装过程中会自动安装JDK。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudio%E7%AE%80%E4%BB%8B.png\" alt=\"img\"></p>\n<p>下载完成以后，双击安装。</p>\n<h3 id=\"二、DevEco-Studio配置\"><a href=\"#二、DevEco-Studio配置\" class=\"headerlink\" title=\"二、DevEco Studio配置\"></a>二、DevEco Studio配置</h3><p>DevEcoStudio安装完成后，首次进入需要安装Node.js和ohpm。</p>\n<p><strong>Node.js：</strong>一个运行在Chrome V8引擎的JavaScript运行环境。现在被广泛的运用于Web前端工程化构建中。由于鸿蒙的Ark UI框架是基于Node.js进行开发的，所以像绝大多数Web前端开发框架一样，首先要在当前操作系统中安装Node.js框架。新版本的DevEco Studio已经集成了node.js的安装，无需前置安装。</p>\n<p><strong>ohpm：</strong>openharmony package manager，鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理，同样在新版本的DevEco Studio中集成了安装包。</p>\n<p>这里只需要在首页单击Agree进入配置，配置node.js和ohpm的安装源，即可。推荐选择从华为镜像直接下载安装，选择本地安装路径。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioBasic.png\" alt=\"img\"></p>\n<p>Node.js和ohpm选择好以后，点击下一步，进入SDK Setup页面，选择和修改SDK安装位置：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioSDK.png\" alt=\"img\"></p>\n<p>这里需要点击Next以后，需要阅读和勾选License协议，再次点击下一步进入预览页面，确认各项下载路径无误以后，点击Next开始进行下载安装。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioSummary.png\" alt=\"img\"></p>\n<h3 id=\"三、DevEco-Studio主题\"><a href=\"#三、DevEco-Studio主题\" class=\"headerlink\" title=\"三、DevEco Studio主题\"></a>三、DevEco Studio主题</h3><p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioTheme.png\" alt=\"img\"></p>\n<h3 id=\"四、DevEco-Studio-HelloWord\"><a href=\"#四、DevEco-Studio-HelloWord\" class=\"headerlink\" title=\"四、DevEco Studio HelloWord\"></a>四、DevEco Studio HelloWord</h3><p>安装和配置完成以后，就可以开始我们的第一个项目啦，当然必须是HelloWorld。通过Create Project 创建一个Empty Ability。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioCreate.png\" alt=\"img\"></p>\n<p>项目名称叫做HelloWorld，同步通过以后，可以进入HelloWorld工程中，默认是Project模式，定位到我们的Index.ets文件上。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioProject.png\" alt=\"img\"></p>\n<p>这里我们也可以通过右上角目录视图切换，切换至Ohos视图：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioIndex.png\" alt=\"img\"></p>\n<p>这里分别对这三个目录进行介绍：</p>\n<p>AppScope：主要用于存放整个应用公共的信息与资源</p>\n<p>entry：是默认的初始模块，其中ets中存放编写的代码文件，ets中page目录，则用来存放我们的页面文件，例如初始的index.ets就存放在ets-&gt;pages目录下；configuration中存放相应模块的配置文件；resources中存放资源文件</p>\n<p>configuration：工程、应用级别的配置文件</p>\n<p><strong>预览：</strong>右侧Previewer点击后，可以实时预览我们编写的页面在手机上的样式：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioPreView.png\" alt=\"img\"></p>\n<p>创建模拟器：通过菜单栏中Tools—DeviceManager打开这个页面，也可以通过右上角Device区域的Device Manager打开模拟器管理页面。选择好模拟器创建位置后，选择+号，可以新建本地模拟器。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioDevice.png\" alt=\"img\"></p>\n<p>第一次安装系统后，会提示下载安装模拟器，根据提示下载安装即可，然后就可以选择创建。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioHardWare.png\" alt=\"img\"></p>\n<p>安装完成后，可以一键运行：至此，Hello World工程，成功运行起来：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20240710/DevEcoStudioHello.png\" alt=\"img\">   </p>\n"},{"title":"Flutter状态管理","date":"2022-04-19T06:54:46.000Z","keywords":"Flutter,状态管理,Provider","description":"Flutter—状态管理机制","top_img":"http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg","cover":"http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg","_content":"\n## Flutter状态管理\n\n在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。\n\nFlutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。\n\n常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。\n\n### 一、 状态管理分类：\n\n首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：\n\n#### 局部状态：\n\nFlutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。\n\n#### 全局状态：\n\nFlutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理\n\n#### 最简单的状态管理\n\n我们可以使用 State + InheritedWidget实现最简单的状态管理机制。\n\n\n### 二、 状态管理——Stream\n\nStream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 \n\n```dart\n/// 展示文本\nString textString = \"等待接收文本\";\n\n/// 单订阅Stream\nStream<String> stream = new Stream.fromFuture(_doFutureTask());\n\n@override\nvoid initState() {\nStreamSubscription subscription = stream.listen((data) {\n  textString = data;\n  print(\"接收数据成功\");\n}, onDone: () {\n  print(\"流处理完成\");\n}, onError: () {\n  print(\"流处理出现异常\");\n});\n\n/// Subscription_API\nsubscription.cancel();\nsubscription.pause();\nsubscription.resume();\n}\n\n/// 异步任务\nstatic _doFutureTask() {\n\treturn Future.delayed(Duration(seconds: 5), () {\n  \tprint('Hello World');\n\t});\n}\n\n```\n\n这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流\n\n\n#### 单订阅流\n\n单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。\n\n```dart\n// 初始化\nStreamController<String> singleStream = StreamController();\n\n// 消息发送\nsingleStream.add('Hello World');\n\n```\n\n使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.\n其含义就是指：单订阅流不能有多个收听者\n\t\n\n#### 广播流 \n\n广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件\n\n```dart\n// 初始化\nStreamController<int> singleStream = StreamController.broadcast();\n\n// 消息发送\nsingleStream.sink.add(6);\n```\n\nStreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。\n\n#### StreamBuilder如何实现刷新\n\n在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：\n\n```dart\nStreamBuilder<String>(\n        builder: (context, snapshot) {\n          if (snapshot == null || !snapshot.hasData) {\n            return CircularProgressIndicator();\n          } else {\n            if (snapshot.hasError) {\n              return Text(\"发生错误\");\n            } else {\n              return Text(snapshot.data);\n            }\n          }\n        },\n        stream: singleStream.stream,\n      )\n```\n\n那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。\n\t\n```dart\nvoid _subscribe() {\nif (widget.stream != null) {\n  _subscription = widget.stream.listen((T data) {\n    setState(() {\n      _summary = widget.afterData(_summary, data);\n    });\n  }, onError: (Object error) {\n    setState(() {\n      _summary = widget.afterError(_summary, error);\n    });\n  }, onDone: () {\n    setState(() {\n      _summary = widget.afterDone(_summary);\n    });\n  });\n  _summary = widget.afterConnected(_summary);\n}\n```\n  }\n\n\n而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制\n\t\n\t\n#### StreamController整体架构\n\n从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：\n\n![](http://image.jucaiwy.com/image/20220419/stream_pic.png)\n\n\n整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作\n\n#### StreamController同步、异步处理\n\n在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。\n\n```dart\nreturn sync\n    ? new _SyncStreamController<T>(onListen, onPause, onResume, onCancel)\n    : new _AsyncStreamController<T>(onListen, onPause, onResume, onCancel);\n```\n\n这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：\n\n```dart\nvoid _sendData(T data) {\n    if (_isEmpty) return;\n    if (_hasOneListener) {\n\t      _state |= _BroadcastStreamController._STATE_FIRING;\n\t      _BroadcastSubscription<T> subscription = _firstSubscription;\n\t      subscription._add(data);\n\t      _state &= ~_BroadcastStreamController._STATE_FIRING;\n\t      if (_isEmpty) {\n\t        _callOnCancel();\n\t      }\n\t      return;\t\t\n    }\n    _forEachListener((_BufferingStreamSubscription<T> subscription) {\n      \t   subscription._add(data);\n    });\n}\n```\n\n\n​\t\n而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：\n\n```dart\nabstract class _AsyncStreamControllerDispatch<T>\nimplements _StreamController<T> {\n\tvoid _sendData(T data) {\n\t\t_subscription._addPending(new _DelayedData<T>(data));\n\t}\n\n  \tvoid _sendError(Object error, StackTrace stackTrace) {\n    \t_subscription._addPending(new _DelayedError(error, stackTrace));\n  \t}\n\n  \tvoid _sendDone() {\n    \t_subscription._addPending(const _DelayedDone());\n  \t}\n}\n```\n\n那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：\n\n```dart\nvoid schedule(_EventDispatch<T> dispatch) {\n    if (isScheduled) return;\n    assert(!isEmpty);\n    if (_eventScheduled) {\n      assert(_state == _STATE_CANCELED);\n      _state = _STATE_SCHEDULED;\n      return;\n    }\n    scheduleMicrotask(() {\n      int oldState = _state;\n      _state = _STATE_UNSCHEDULED;\n      if (oldState == _STATE_CANCELED) return;\n      handleNext(dispatch);\n    });\n    _state = _STATE_SCHEDULED;\n  }\n```\n\n因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步\n\n![](http://image.jucaiwy.com/image/20220419/flutter_thread.png)\n\n至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析\n\n\n### 三、状态管理——RxDart\n\n说到RxDart就不得不提一下ReactiveX，[http://reactivex.io/](http://reactivex.io/)  \n\n在其官网上，对ReactiveX的介绍为\n\n```dart\n“An API for asynchronous programming with observable streams”\n```\n\n用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。\n\n```dart\n/// 创建一个Subject\nvar subject = PublishSubject<String>();\n\n/// 通过listen实现订阅\nsubject.listen((String data) {\n  print(\"OnData \" + data);\n}, onError: () {\n  print(\"onError \");\n}, onDone: () {\n  print(\"onDone \");\n});\n\n/// 使用完成，关闭\nsubject.close();\n```\n\n这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：\n\n```dart\nfactory PublishSubject({void onListen(), void onCancel(), bool sync = false}) {\n    // ignore: close_sinks\n    final controller = StreamController<T>.broadcast(\n      onListen: onListen,\n      onCancel: onCancel,\n      sync: sync,\n    );\n\n    return PublishSubject<T>._(\n      controller,\n      Observable<T>(controller.stream),\n    );\n}\n```\n\n\n  \t\n至此我们也明白了：\n\n1. 在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController\n\n2. RxDart中的Observable实质上相当于一个Stream\n\n总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。\n\n\n### 四、状态管理——Provider\n\nProvider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。\n\n#### Provider使用\n\n第一步\t添加依赖\n\n```dart\nprovider: ^2.0.1+1\n```\n\n第二步  创建数据模型\n\n```dart\n/// 计数module\nclass CounterModel extends ChangeNotifier {\n  /// 计数\n  int _count = 0;\n  int get value => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。\n\n第三步  创建全局共享数据依赖\n\n```dart\nvoid main() {\n  /// 数据模型\n  final counter = CounterModel();\n  \n  runApp(\n    ChangeNotifierProvider.value(\n      notifier: counter,\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.dark(),\n      home: FirstScreen(),\n    );\n  }\n}\n```\n\n在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。\n\n第四步  在其他页面中获取共享的状态\n\n这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面\n\n```dart\n/// Provider 页面\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n  \tprint(\"Provider \" + \"FirstScreen build\");\n \n    final _counter = Provider.of<CounterModel>(context);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('FirstPage')),\n      body: Center(\n          child: GestureDetector(\n              onTap: () => {_counter.increment()},\n              child: Text(\n                'Value: ${_counter.value}',\n                style: TextStyle(fontSize: 48),\n              ))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context)\n            .push(MaterialPageRoute(builder: (context) => SecondPage())),\n        child: Icon(Icons.navigate_next),\n      ),\n    );\n  }\n}\n```\n\n在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。\n\n```dart\n/// Provider 页面\nclass SecondPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext buildContext) {\n    print(\"Provider \" + \"SecondPage build\");\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('Second Page'),\n        ),\n        body: Consumer<CounterModel>(\n          builder: (context, CounterModel counter, _) => Center(\n              child: GestureDetector(\n                  onTap: () => {counter.increment()},\n                  child: Text(\n                    'Value: ${counter.value}',\n                    style: TextStyle(\n                      fontSize: 48,\n                    ),\n                  ))),\n        ));\n  }\n}\n```\n\n在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。\n\n\n#### Consumer\n\n在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。\n\n```dart\nfinal Widget Function(BuildContext context, T value, Widget child) builder;\n```\n\n从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：\n\t\n```dart\nfinal Widget Function(BuildContext context, A value, B value2, Widget child) builder;\n```\n\n其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。\n\n那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：\n\n```dart\n1. 进入第一个页面，点击两次Value，使数据自增\n2. 点击进入下一个页面\n3. 在第二个页面，同样点击两次Value，使数据自增\n4. 返回第一个页面，点击一次Value，自增\n```\n\n\n​\t\n我们可以看到Log打印如下：\n\n```dart\n2020-12-12 18:30:26.873 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:27.777 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:29.290 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build\n2020-12-12 18:30:30.203 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:31.726 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:35.223 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n```\n\n可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：\n\t\n```dart\n@override\n  Widget build(BuildContext context) {\n    return builder(\n      context,\n      Provider.of<T>(context),\n      child,\n    );\n  }\n```\n\n也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？\n\t\n这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。\n\n![](http://image.jucaiwy.com/image/20220419/flutter_state_code.png)\n\t\n至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。\n\nProvider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析\n\n\n### 五、 总结\n总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。\n\n\n​\t\n\n\n\n","source":"_posts/20220419Flutter状态管理框架.md","raw":"---\n\ntitle: Flutter状态管理\n\ndate: 2022-04-19 14:54:46\n\ntags: [Flutter ,状态管理 ,Provider,Stream]\n\ncategories: Flutter\n\nkeywords: Flutter,状态管理,Provider\n\ndescription: Flutter—状态管理机制\n\ntop_img: http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg\n\ncover: http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg\n\n---\n\n## Flutter状态管理\n\n在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。\n\nFlutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。\n\n常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。\n\n### 一、 状态管理分类：\n\n首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：\n\n#### 局部状态：\n\nFlutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。\n\n#### 全局状态：\n\nFlutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理\n\n#### 最简单的状态管理\n\n我们可以使用 State + InheritedWidget实现最简单的状态管理机制。\n\n\n### 二、 状态管理——Stream\n\nStream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 \n\n```dart\n/// 展示文本\nString textString = \"等待接收文本\";\n\n/// 单订阅Stream\nStream<String> stream = new Stream.fromFuture(_doFutureTask());\n\n@override\nvoid initState() {\nStreamSubscription subscription = stream.listen((data) {\n  textString = data;\n  print(\"接收数据成功\");\n}, onDone: () {\n  print(\"流处理完成\");\n}, onError: () {\n  print(\"流处理出现异常\");\n});\n\n/// Subscription_API\nsubscription.cancel();\nsubscription.pause();\nsubscription.resume();\n}\n\n/// 异步任务\nstatic _doFutureTask() {\n\treturn Future.delayed(Duration(seconds: 5), () {\n  \tprint('Hello World');\n\t});\n}\n\n```\n\n这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流\n\n\n#### 单订阅流\n\n单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。\n\n```dart\n// 初始化\nStreamController<String> singleStream = StreamController();\n\n// 消息发送\nsingleStream.add('Hello World');\n\n```\n\n使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.\n其含义就是指：单订阅流不能有多个收听者\n\t\n\n#### 广播流 \n\n广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件\n\n```dart\n// 初始化\nStreamController<int> singleStream = StreamController.broadcast();\n\n// 消息发送\nsingleStream.sink.add(6);\n```\n\nStreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。\n\n#### StreamBuilder如何实现刷新\n\n在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：\n\n```dart\nStreamBuilder<String>(\n        builder: (context, snapshot) {\n          if (snapshot == null || !snapshot.hasData) {\n            return CircularProgressIndicator();\n          } else {\n            if (snapshot.hasError) {\n              return Text(\"发生错误\");\n            } else {\n              return Text(snapshot.data);\n            }\n          }\n        },\n        stream: singleStream.stream,\n      )\n```\n\n那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。\n\t\n```dart\nvoid _subscribe() {\nif (widget.stream != null) {\n  _subscription = widget.stream.listen((T data) {\n    setState(() {\n      _summary = widget.afterData(_summary, data);\n    });\n  }, onError: (Object error) {\n    setState(() {\n      _summary = widget.afterError(_summary, error);\n    });\n  }, onDone: () {\n    setState(() {\n      _summary = widget.afterDone(_summary);\n    });\n  });\n  _summary = widget.afterConnected(_summary);\n}\n```\n  }\n\n\n而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制\n\t\n\t\n#### StreamController整体架构\n\n从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：\n\n![](http://image.jucaiwy.com/image/20220419/stream_pic.png)\n\n\n整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作\n\n#### StreamController同步、异步处理\n\n在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。\n\n```dart\nreturn sync\n    ? new _SyncStreamController<T>(onListen, onPause, onResume, onCancel)\n    : new _AsyncStreamController<T>(onListen, onPause, onResume, onCancel);\n```\n\n这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：\n\n```dart\nvoid _sendData(T data) {\n    if (_isEmpty) return;\n    if (_hasOneListener) {\n\t      _state |= _BroadcastStreamController._STATE_FIRING;\n\t      _BroadcastSubscription<T> subscription = _firstSubscription;\n\t      subscription._add(data);\n\t      _state &= ~_BroadcastStreamController._STATE_FIRING;\n\t      if (_isEmpty) {\n\t        _callOnCancel();\n\t      }\n\t      return;\t\t\n    }\n    _forEachListener((_BufferingStreamSubscription<T> subscription) {\n      \t   subscription._add(data);\n    });\n}\n```\n\n\n​\t\n而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：\n\n```dart\nabstract class _AsyncStreamControllerDispatch<T>\nimplements _StreamController<T> {\n\tvoid _sendData(T data) {\n\t\t_subscription._addPending(new _DelayedData<T>(data));\n\t}\n\n  \tvoid _sendError(Object error, StackTrace stackTrace) {\n    \t_subscription._addPending(new _DelayedError(error, stackTrace));\n  \t}\n\n  \tvoid _sendDone() {\n    \t_subscription._addPending(const _DelayedDone());\n  \t}\n}\n```\n\n那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：\n\n```dart\nvoid schedule(_EventDispatch<T> dispatch) {\n    if (isScheduled) return;\n    assert(!isEmpty);\n    if (_eventScheduled) {\n      assert(_state == _STATE_CANCELED);\n      _state = _STATE_SCHEDULED;\n      return;\n    }\n    scheduleMicrotask(() {\n      int oldState = _state;\n      _state = _STATE_UNSCHEDULED;\n      if (oldState == _STATE_CANCELED) return;\n      handleNext(dispatch);\n    });\n    _state = _STATE_SCHEDULED;\n  }\n```\n\n因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步\n\n![](http://image.jucaiwy.com/image/20220419/flutter_thread.png)\n\n至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析\n\n\n### 三、状态管理——RxDart\n\n说到RxDart就不得不提一下ReactiveX，[http://reactivex.io/](http://reactivex.io/)  \n\n在其官网上，对ReactiveX的介绍为\n\n```dart\n“An API for asynchronous programming with observable streams”\n```\n\n用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。\n\n```dart\n/// 创建一个Subject\nvar subject = PublishSubject<String>();\n\n/// 通过listen实现订阅\nsubject.listen((String data) {\n  print(\"OnData \" + data);\n}, onError: () {\n  print(\"onError \");\n}, onDone: () {\n  print(\"onDone \");\n});\n\n/// 使用完成，关闭\nsubject.close();\n```\n\n这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：\n\n```dart\nfactory PublishSubject({void onListen(), void onCancel(), bool sync = false}) {\n    // ignore: close_sinks\n    final controller = StreamController<T>.broadcast(\n      onListen: onListen,\n      onCancel: onCancel,\n      sync: sync,\n    );\n\n    return PublishSubject<T>._(\n      controller,\n      Observable<T>(controller.stream),\n    );\n}\n```\n\n\n  \t\n至此我们也明白了：\n\n1. 在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController\n\n2. RxDart中的Observable实质上相当于一个Stream\n\n总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。\n\n\n### 四、状态管理——Provider\n\nProvider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。\n\n#### Provider使用\n\n第一步\t添加依赖\n\n```dart\nprovider: ^2.0.1+1\n```\n\n第二步  创建数据模型\n\n```dart\n/// 计数module\nclass CounterModel extends ChangeNotifier {\n  /// 计数\n  int _count = 0;\n  int get value => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。\n\n第三步  创建全局共享数据依赖\n\n```dart\nvoid main() {\n  /// 数据模型\n  final counter = CounterModel();\n  \n  runApp(\n    ChangeNotifierProvider.value(\n      notifier: counter,\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.dark(),\n      home: FirstScreen(),\n    );\n  }\n}\n```\n\n在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。\n\n第四步  在其他页面中获取共享的状态\n\n这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面\n\n```dart\n/// Provider 页面\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n  \tprint(\"Provider \" + \"FirstScreen build\");\n \n    final _counter = Provider.of<CounterModel>(context);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('FirstPage')),\n      body: Center(\n          child: GestureDetector(\n              onTap: () => {_counter.increment()},\n              child: Text(\n                'Value: ${_counter.value}',\n                style: TextStyle(fontSize: 48),\n              ))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context)\n            .push(MaterialPageRoute(builder: (context) => SecondPage())),\n        child: Icon(Icons.navigate_next),\n      ),\n    );\n  }\n}\n```\n\n在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。\n\n```dart\n/// Provider 页面\nclass SecondPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext buildContext) {\n    print(\"Provider \" + \"SecondPage build\");\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('Second Page'),\n        ),\n        body: Consumer<CounterModel>(\n          builder: (context, CounterModel counter, _) => Center(\n              child: GestureDetector(\n                  onTap: () => {counter.increment()},\n                  child: Text(\n                    'Value: ${counter.value}',\n                    style: TextStyle(\n                      fontSize: 48,\n                    ),\n                  ))),\n        ));\n  }\n}\n```\n\n在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。\n\n\n#### Consumer\n\n在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。\n\n```dart\nfinal Widget Function(BuildContext context, T value, Widget child) builder;\n```\n\n从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：\n\t\n```dart\nfinal Widget Function(BuildContext context, A value, B value2, Widget child) builder;\n```\n\n其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。\n\n那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：\n\n```dart\n1. 进入第一个页面，点击两次Value，使数据自增\n2. 点击进入下一个页面\n3. 在第二个页面，同样点击两次Value，使数据自增\n4. 返回第一个页面，点击一次Value，自增\n```\n\n\n​\t\n我们可以看到Log打印如下：\n\n```dart\n2020-12-12 18:30:26.873 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:27.777 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:29.290 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build\n2020-12-12 18:30:30.203 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:31.726 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n2020-12-12 18:30:35.223 4273-6507/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build\n```\n\n可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：\n\t\n```dart\n@override\n  Widget build(BuildContext context) {\n    return builder(\n      context,\n      Provider.of<T>(context),\n      child,\n    );\n  }\n```\n\n也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？\n\t\n这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。\n\n![](http://image.jucaiwy.com/image/20220419/flutter_state_code.png)\n\t\n至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。\n\nProvider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析\n\n\n### 五、 总结\n总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。\n\n\n​\t\n\n\n\n","slug":"20220419Flutter状态管理框架","published":1,"updated":"2022-04-19T07:16:47.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01a00010nv6dd8n37ld","content":"<h2 id=\"Flutter状态管理\"><a href=\"#Flutter状态管理\" class=\"headerlink\" title=\"Flutter状态管理\"></a>Flutter状态管理</h2><p>在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。</p>\n<p>Flutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。</p>\n<p>常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。</p>\n<h3 id=\"一、-状态管理分类：\"><a href=\"#一、-状态管理分类：\" class=\"headerlink\" title=\"一、 状态管理分类：\"></a>一、 状态管理分类：</h3><p>首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：</p>\n<h4 id=\"局部状态：\"><a href=\"#局部状态：\" class=\"headerlink\" title=\"局部状态：\"></a>局部状态：</h4><p>Flutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。</p>\n<h4 id=\"全局状态：\"><a href=\"#全局状态：\" class=\"headerlink\" title=\"全局状态：\"></a>全局状态：</h4><p>Flutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理</p>\n<h4 id=\"最简单的状态管理\"><a href=\"#最简单的状态管理\" class=\"headerlink\" title=\"最简单的状态管理\"></a>最简单的状态管理</h4><p>我们可以使用 State + InheritedWidget实现最简单的状态管理机制。</p>\n<h3 id=\"二、-状态管理——Stream\"><a href=\"#二、-状态管理——Stream\" class=\"headerlink\" title=\"二、 状态管理——Stream\"></a>二、 状态管理——Stream</h3><p>Stream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">展示文本</span></span></span><br><span class=\"line\"><span class=\"built_in\">String</span> textString = <span class=\"string\">&quot;等待接收文本&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">单订阅Stream</span></span></span><br><span class=\"line\">Stream&lt;<span class=\"built_in\">String</span>&gt; stream = <span class=\"keyword\">new</span> Stream.fromFuture(_doFutureTask());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">StreamSubscription subscription = stream.listen((data) &#123;</span><br><span class=\"line\">  textString = data;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;接收数据成功&quot;</span>);</span><br><span class=\"line\">&#125;, onDone: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;流处理完成&quot;</span>);</span><br><span class=\"line\">&#125;, onError: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;流处理出现异常&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Subscription<span class=\"emphasis\">_API</span></span></span></span><br><span class=\"line\">subscription.cancel();</span><br><span class=\"line\">subscription.pause();</span><br><span class=\"line\">subscription.resume();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\"><span class=\"emphasis\">异步任务</span></span></span></span><br><span class=\"line\"><span class=\"keyword\">static</span> _doFutureTask() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Future.delayed(<span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">5</span>), () &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流</p>\n<h4 id=\"单订阅流\"><a href=\"#单订阅流\" class=\"headerlink\" title=\"单订阅流\"></a>单订阅流</h4><p>单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">StreamController&lt;<span class=\"built_in\">String</span>&gt; singleStream = StreamController();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消息发送</span></span><br><span class=\"line\">singleStream.add(<span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.<br>其含义就是指：单订阅流不能有多个收听者</p>\n<h4 id=\"广播流\"><a href=\"#广播流\" class=\"headerlink\" title=\"广播流\"></a>广播流</h4><p>广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">StreamController&lt;<span class=\"built_in\">int</span>&gt; singleStream = StreamController.broadcast();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消息发送</span></span><br><span class=\"line\">singleStream.sink.add(<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>StreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。</p>\n<h4 id=\"StreamBuilder如何实现刷新\"><a href=\"#StreamBuilder如何实现刷新\" class=\"headerlink\" title=\"StreamBuilder如何实现刷新\"></a>StreamBuilder如何实现刷新</h4><p>在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StreamBuilder&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">        builder: (context, snapshot) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (snapshot == <span class=\"keyword\">null</span> || !snapshot.hasData) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> CircularProgressIndicator();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (snapshot.hasError) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Text(<span class=\"string\">&quot;发生错误&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Text(snapshot.data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        stream: singleStream.stream,</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n\n<p>那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _subscribe() &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (widget.stream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  _subscription = widget.stream.listen((T data) &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterData(_summary, data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, onError: (<span class=\"built_in\">Object</span> error) &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterError(_summary, error);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, onDone: () &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterDone(_summary);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  _summary = widget.afterConnected(_summary);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  }</p>\n<p>而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制</p>\n<h4 id=\"StreamController整体架构\"><a href=\"#StreamController整体架构\" class=\"headerlink\" title=\"StreamController整体架构\"></a>StreamController整体架构</h4><p>从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/stream_pic.png\"></p>\n<p>整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作</p>\n<h4 id=\"StreamController同步、异步处理\"><a href=\"#StreamController同步、异步处理\" class=\"headerlink\" title=\"StreamController同步、异步处理\"></a>StreamController同步、异步处理</h4><p>在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">sync</span></span><br><span class=\"line\">    ? <span class=\"keyword\">new</span> _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)</span><br><span class=\"line\">    : <span class=\"keyword\">new</span> _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);</span><br></pre></td></tr></table></figure>\n\n<p>这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _sendData(T data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isEmpty) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_hasOneListener) &#123;</span><br><span class=\"line\">\t      _state |= _BroadcastStreamController._STATE_FIRING;</span><br><span class=\"line\">\t      _BroadcastSubscription&lt;T&gt; subscription = _firstSubscription;</span><br><span class=\"line\">\t      subscription._add(data);</span><br><span class=\"line\">\t      _state &amp;= ~_BroadcastStreamController._STATE_FIRING;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (_isEmpty) &#123;</span><br><span class=\"line\">\t        _callOnCancel();</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span>;\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _forEachListener((_BufferingStreamSubscription&lt;T&gt; subscription) &#123;</span><br><span class=\"line\">      \t   subscription._add(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>​\t<br>而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_AsyncStreamControllerDispatch</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">_StreamController</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> _sendData(T data) &#123;</span><br><span class=\"line\">\t\t_subscription._addPending(<span class=\"keyword\">new</span> _DelayedData&lt;T&gt;(data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">void</span> _sendError(<span class=\"built_in\">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class=\"line\">    \t_subscription._addPending(<span class=\"keyword\">new</span> _DelayedError(error, stackTrace));</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">void</span> _sendDone() &#123;</span><br><span class=\"line\">    \t_subscription._addPending(<span class=\"keyword\">const</span> _DelayedDone());</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> schedule(_EventDispatch&lt;T&gt; dispatch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isScheduled) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(!isEmpty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_eventScheduled) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(_state == _STATE_CANCELED);</span><br><span class=\"line\">      _state = _STATE_SCHEDULED;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scheduleMicrotask(() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">int</span> oldState = _state;</span><br><span class=\"line\">      _state = _STATE_UNSCHEDULED;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldState == _STATE_CANCELED) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      handleNext(dispatch);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    _state = _STATE_SCHEDULED;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/flutter_thread.png\"></p>\n<p>至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析</p>\n<h3 id=\"三、状态管理——RxDart\"><a href=\"#三、状态管理——RxDart\" class=\"headerlink\" title=\"三、状态管理——RxDart\"></a>三、状态管理——RxDart</h3><p>说到RxDart就不得不提一下ReactiveX，<a href=\"http://reactivex.io/\">http://reactivex.io/</a>  </p>\n<p>在其官网上，对ReactiveX的介绍为</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“An API <span class=\"keyword\">for</span> asynchronous programming <span class=\"keyword\">with</span> observable streams”</span><br></pre></td></tr></table></figure>\n\n<p>用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">创建一个Subject</span></span></span><br><span class=\"line\"><span class=\"keyword\">var</span> subject = PublishSubject&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">通过listen实现订阅</span></span></span><br><span class=\"line\">subject.listen((<span class=\"built_in\">String</span> data) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;OnData &quot;</span> + data);</span><br><span class=\"line\">&#125;, onError: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;onError &quot;</span>);</span><br><span class=\"line\">&#125;, onDone: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;onDone &quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">使用完成，关闭</span></span></span><br><span class=\"line\">subject.close();</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">factory</span> PublishSubject(&#123;<span class=\"keyword\">void</span> onListen(), <span class=\"keyword\">void</span> onCancel(), <span class=\"built_in\">bool</span> <span class=\"keyword\">sync</span> = <span class=\"keyword\">false</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ignore: close_sinks</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> controller = StreamController&lt;T&gt;.broadcast(</span><br><span class=\"line\">      onListen: onListen,</span><br><span class=\"line\">      onCancel: onCancel,</span><br><span class=\"line\">      <span class=\"keyword\">sync</span>: <span class=\"keyword\">sync</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> PublishSubject&lt;T&gt;._(</span><br><span class=\"line\">      controller,</span><br><span class=\"line\">      Observable&lt;T&gt;(controller.stream),</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>至此我们也明白了：</p>\n<ol>\n<li><p>在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController</p>\n</li>\n<li><p>RxDart中的Observable实质上相当于一个Stream</p>\n</li>\n</ol>\n<p>总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。</p>\n<h3 id=\"四、状态管理——Provider\"><a href=\"#四、状态管理——Provider\" class=\"headerlink\" title=\"四、状态管理——Provider\"></a>四、状态管理——Provider</h3><p>Provider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。</p>\n<h4 id=\"Provider使用\"><a href=\"#Provider使用\" class=\"headerlink\" title=\"Provider使用\"></a>Provider使用</h4><p>第一步\t添加依赖</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provider: ^<span class=\"number\">2.0</span><span class=\"number\">.1</span>+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步  创建数据模型</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">计数module</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChangeNotifier</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">计数</span></span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> value =&gt; _count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> increment() &#123;</span><br><span class=\"line\">    _count++;</span><br><span class=\"line\">    notifyListeners();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。</p>\n<p>第三步  创建全局共享数据依赖</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">数据模型</span></span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> counter = CounterModel();</span><br><span class=\"line\">  </span><br><span class=\"line\">  runApp(</span><br><span class=\"line\">    ChangeNotifierProvider.value(</span><br><span class=\"line\">      notifier: counter,</span><br><span class=\"line\">      child: MyApp(),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      theme: ThemeData.dark(),</span><br><span class=\"line\">      home: FirstScreen(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。</p>\n<p>第四步  在其他页面中获取共享的状态</p>\n<p>这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Provider 页面</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Provider &quot;</span> + <span class=\"string\">&quot;FirstScreen build&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">final</span> _counter = Provider.of&lt;CounterModel&gt;(context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(title: Text(<span class=\"string\">&#x27;FirstPage&#x27;</span>)),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">          child: GestureDetector(</span><br><span class=\"line\">              onTap: () =&gt; &#123;_counter.increment()&#125;,</span><br><span class=\"line\">              child: Text(</span><br><span class=\"line\">                <span class=\"string\">&#x27;Value: <span class=\"subst\">$&#123;_counter.value&#125;</span>&#x27;</span>,</span><br><span class=\"line\">                style: TextStyle(fontSize: <span class=\"number\">48</span>),</span><br><span class=\"line\">              ))),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: () =&gt; Navigator.of(context)</span><br><span class=\"line\">            .push(MaterialPageRoute(builder: (context) =&gt; SecondPage())),</span><br><span class=\"line\">        child: Icon(Icons.navigate_next),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Provider 页面</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext buildContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Provider &quot;</span> + <span class=\"string\">&quot;SecondPage build&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">&#x27;Second Page&#x27;</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: Consumer&lt;CounterModel&gt;(</span><br><span class=\"line\">          builder: (context, CounterModel counter, _) =&gt; Center(</span><br><span class=\"line\">              child: GestureDetector(</span><br><span class=\"line\">                  onTap: () =&gt; &#123;counter.increment()&#125;,</span><br><span class=\"line\">                  child: Text(</span><br><span class=\"line\">                    <span class=\"string\">&#x27;Value: <span class=\"subst\">$&#123;counter.value&#125;</span>&#x27;</span>,</span><br><span class=\"line\">                    style: TextStyle(</span><br><span class=\"line\">                      fontSize: <span class=\"number\">48</span>,</span><br><span class=\"line\">                    ),</span><br><span class=\"line\">                  ))),</span><br><span class=\"line\">        ));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。</p>\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Widget <span class=\"built_in\">Function</span>(BuildContext context, T value, Widget child) builder;</span><br></pre></td></tr></table></figure>\n\n<p>从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Widget <span class=\"built_in\">Function</span>(BuildContext context, A value, B value2, Widget child) builder;</span><br></pre></td></tr></table></figure>\n\n<p>其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。</p>\n<p>那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 进入第一个页面，点击两次Value，使数据自增</span><br><span class=\"line\"><span class=\"number\">2.</span> 点击进入下一个页面</span><br><span class=\"line\"><span class=\"number\">3.</span> 在第二个页面，同样点击两次Value，使数据自增</span><br><span class=\"line\"><span class=\"number\">4.</span> 返回第一个页面，点击一次Value，自增</span><br></pre></td></tr></table></figure>\n\n\n<p>​\t<br>我们可以看到Log打印如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">26.873</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">27.777</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">29.290</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">30.203</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">31.726</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">35.223</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br></pre></td></tr></table></figure>\n\n<p>可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder(</span><br><span class=\"line\">      context,</span><br><span class=\"line\">      Provider.of&lt;T&gt;(context),</span><br><span class=\"line\">      child,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？</p>\n<p>这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/flutter_state_code.png\"></p>\n<p>至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。</p>\n<p>Provider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析</p>\n<h3 id=\"五、-总结\"><a href=\"#五、-总结\" class=\"headerlink\" title=\"五、 总结\"></a>五、 总结</h3><p>总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。</p>\n<p>​\t</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Flutter状态管理\"><a href=\"#Flutter状态管理\" class=\"headerlink\" title=\"Flutter状态管理\"></a>Flutter状态管理</h2><p>在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。</p>\n<p>Flutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。</p>\n<p>常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。</p>\n<h3 id=\"一、-状态管理分类：\"><a href=\"#一、-状态管理分类：\" class=\"headerlink\" title=\"一、 状态管理分类：\"></a>一、 状态管理分类：</h3><p>首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：</p>\n<h4 id=\"局部状态：\"><a href=\"#局部状态：\" class=\"headerlink\" title=\"局部状态：\"></a>局部状态：</h4><p>Flutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。</p>\n<h4 id=\"全局状态：\"><a href=\"#全局状态：\" class=\"headerlink\" title=\"全局状态：\"></a>全局状态：</h4><p>Flutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理</p>\n<h4 id=\"最简单的状态管理\"><a href=\"#最简单的状态管理\" class=\"headerlink\" title=\"最简单的状态管理\"></a>最简单的状态管理</h4><p>我们可以使用 State + InheritedWidget实现最简单的状态管理机制。</p>\n<h3 id=\"二、-状态管理——Stream\"><a href=\"#二、-状态管理——Stream\" class=\"headerlink\" title=\"二、 状态管理——Stream\"></a>二、 状态管理——Stream</h3><p>Stream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">展示文本</span></span></span><br><span class=\"line\"><span class=\"built_in\">String</span> textString = <span class=\"string\">&quot;等待接收文本&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">单订阅Stream</span></span></span><br><span class=\"line\">Stream&lt;<span class=\"built_in\">String</span>&gt; stream = <span class=\"keyword\">new</span> Stream.fromFuture(_doFutureTask());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">StreamSubscription subscription = stream.listen((data) &#123;</span><br><span class=\"line\">  textString = data;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;接收数据成功&quot;</span>);</span><br><span class=\"line\">&#125;, onDone: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;流处理完成&quot;</span>);</span><br><span class=\"line\">&#125;, onError: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;流处理出现异常&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Subscription<span class=\"emphasis\">_API</span></span></span></span><br><span class=\"line\">subscription.cancel();</span><br><span class=\"line\">subscription.pause();</span><br><span class=\"line\">subscription.resume();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\"><span class=\"emphasis\">异步任务</span></span></span></span><br><span class=\"line\"><span class=\"keyword\">static</span> _doFutureTask() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Future.delayed(<span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">5</span>), () &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流</p>\n<h4 id=\"单订阅流\"><a href=\"#单订阅流\" class=\"headerlink\" title=\"单订阅流\"></a>单订阅流</h4><p>单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">StreamController&lt;<span class=\"built_in\">String</span>&gt; singleStream = StreamController();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消息发送</span></span><br><span class=\"line\">singleStream.add(<span class=\"string\">&#x27;Hello World&#x27;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.<br>其含义就是指：单订阅流不能有多个收听者</p>\n<h4 id=\"广播流\"><a href=\"#广播流\" class=\"headerlink\" title=\"广播流\"></a>广播流</h4><p>广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">StreamController&lt;<span class=\"built_in\">int</span>&gt; singleStream = StreamController.broadcast();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消息发送</span></span><br><span class=\"line\">singleStream.sink.add(<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>StreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。</p>\n<h4 id=\"StreamBuilder如何实现刷新\"><a href=\"#StreamBuilder如何实现刷新\" class=\"headerlink\" title=\"StreamBuilder如何实现刷新\"></a>StreamBuilder如何实现刷新</h4><p>在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StreamBuilder&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">        builder: (context, snapshot) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (snapshot == <span class=\"keyword\">null</span> || !snapshot.hasData) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> CircularProgressIndicator();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (snapshot.hasError) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Text(<span class=\"string\">&quot;发生错误&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Text(snapshot.data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        stream: singleStream.stream,</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n\n<p>那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _subscribe() &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (widget.stream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  _subscription = widget.stream.listen((T data) &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterData(_summary, data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, onError: (<span class=\"built_in\">Object</span> error) &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterError(_summary, error);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, onDone: () &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _summary = widget.afterDone(_summary);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  _summary = widget.afterConnected(_summary);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  }</p>\n<p>而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制</p>\n<h4 id=\"StreamController整体架构\"><a href=\"#StreamController整体架构\" class=\"headerlink\" title=\"StreamController整体架构\"></a>StreamController整体架构</h4><p>从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/stream_pic.png\"></p>\n<p>整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作</p>\n<h4 id=\"StreamController同步、异步处理\"><a href=\"#StreamController同步、异步处理\" class=\"headerlink\" title=\"StreamController同步、异步处理\"></a>StreamController同步、异步处理</h4><p>在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">sync</span></span><br><span class=\"line\">    ? <span class=\"keyword\">new</span> _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)</span><br><span class=\"line\">    : <span class=\"keyword\">new</span> _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);</span><br></pre></td></tr></table></figure>\n\n<p>这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _sendData(T data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isEmpty) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_hasOneListener) &#123;</span><br><span class=\"line\">\t      _state |= _BroadcastStreamController._STATE_FIRING;</span><br><span class=\"line\">\t      _BroadcastSubscription&lt;T&gt; subscription = _firstSubscription;</span><br><span class=\"line\">\t      subscription._add(data);</span><br><span class=\"line\">\t      _state &amp;= ~_BroadcastStreamController._STATE_FIRING;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (_isEmpty) &#123;</span><br><span class=\"line\">\t        _callOnCancel();</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span>;\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _forEachListener((_BufferingStreamSubscription&lt;T&gt; subscription) &#123;</span><br><span class=\"line\">      \t   subscription._add(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>​\t<br>而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_AsyncStreamControllerDispatch</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">_StreamController</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> _sendData(T data) &#123;</span><br><span class=\"line\">\t\t_subscription._addPending(<span class=\"keyword\">new</span> _DelayedData&lt;T&gt;(data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">void</span> _sendError(<span class=\"built_in\">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class=\"line\">    \t_subscription._addPending(<span class=\"keyword\">new</span> _DelayedError(error, stackTrace));</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">void</span> _sendDone() &#123;</span><br><span class=\"line\">    \t_subscription._addPending(<span class=\"keyword\">const</span> _DelayedDone());</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> schedule(_EventDispatch&lt;T&gt; dispatch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isScheduled) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(!isEmpty);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_eventScheduled) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(_state == _STATE_CANCELED);</span><br><span class=\"line\">      _state = _STATE_SCHEDULED;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scheduleMicrotask(() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">int</span> oldState = _state;</span><br><span class=\"line\">      _state = _STATE_UNSCHEDULED;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldState == _STATE_CANCELED) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      handleNext(dispatch);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    _state = _STATE_SCHEDULED;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/flutter_thread.png\"></p>\n<p>至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析</p>\n<h3 id=\"三、状态管理——RxDart\"><a href=\"#三、状态管理——RxDart\" class=\"headerlink\" title=\"三、状态管理——RxDart\"></a>三、状态管理——RxDart</h3><p>说到RxDart就不得不提一下ReactiveX，<a href=\"http://reactivex.io/\">http://reactivex.io/</a>  </p>\n<p>在其官网上，对ReactiveX的介绍为</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“An API <span class=\"keyword\">for</span> asynchronous programming <span class=\"keyword\">with</span> observable streams”</span><br></pre></td></tr></table></figure>\n\n<p>用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">创建一个Subject</span></span></span><br><span class=\"line\"><span class=\"keyword\">var</span> subject = PublishSubject&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">通过listen实现订阅</span></span></span><br><span class=\"line\">subject.listen((<span class=\"built_in\">String</span> data) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;OnData &quot;</span> + data);</span><br><span class=\"line\">&#125;, onError: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;onError &quot;</span>);</span><br><span class=\"line\">&#125;, onDone: () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;onDone &quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">使用完成，关闭</span></span></span><br><span class=\"line\">subject.close();</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">factory</span> PublishSubject(&#123;<span class=\"keyword\">void</span> onListen(), <span class=\"keyword\">void</span> onCancel(), <span class=\"built_in\">bool</span> <span class=\"keyword\">sync</span> = <span class=\"keyword\">false</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ignore: close_sinks</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> controller = StreamController&lt;T&gt;.broadcast(</span><br><span class=\"line\">      onListen: onListen,</span><br><span class=\"line\">      onCancel: onCancel,</span><br><span class=\"line\">      <span class=\"keyword\">sync</span>: <span class=\"keyword\">sync</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> PublishSubject&lt;T&gt;._(</span><br><span class=\"line\">      controller,</span><br><span class=\"line\">      Observable&lt;T&gt;(controller.stream),</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>至此我们也明白了：</p>\n<ol>\n<li><p>在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController</p>\n</li>\n<li><p>RxDart中的Observable实质上相当于一个Stream</p>\n</li>\n</ol>\n<p>总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。</p>\n<h3 id=\"四、状态管理——Provider\"><a href=\"#四、状态管理——Provider\" class=\"headerlink\" title=\"四、状态管理——Provider\"></a>四、状态管理——Provider</h3><p>Provider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。</p>\n<h4 id=\"Provider使用\"><a href=\"#Provider使用\" class=\"headerlink\" title=\"Provider使用\"></a>Provider使用</h4><p>第一步\t添加依赖</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provider: ^<span class=\"number\">2.0</span><span class=\"number\">.1</span>+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步  创建数据模型</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">计数module</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChangeNotifier</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">计数</span></span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> value =&gt; _count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> increment() &#123;</span><br><span class=\"line\">    _count++;</span><br><span class=\"line\">    notifyListeners();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。</p>\n<p>第三步  创建全局共享数据依赖</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"comment\">/// <span class=\"language-markdown\">数据模型</span></span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> counter = CounterModel();</span><br><span class=\"line\">  </span><br><span class=\"line\">  runApp(</span><br><span class=\"line\">    ChangeNotifierProvider.value(</span><br><span class=\"line\">      notifier: counter,</span><br><span class=\"line\">      child: MyApp(),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      theme: ThemeData.dark(),</span><br><span class=\"line\">      home: FirstScreen(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。</p>\n<p>第四步  在其他页面中获取共享的状态</p>\n<p>这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Provider 页面</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Provider &quot;</span> + <span class=\"string\">&quot;FirstScreen build&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">final</span> _counter = Provider.of&lt;CounterModel&gt;(context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(title: Text(<span class=\"string\">&#x27;FirstPage&#x27;</span>)),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">          child: GestureDetector(</span><br><span class=\"line\">              onTap: () =&gt; &#123;_counter.increment()&#125;,</span><br><span class=\"line\">              child: Text(</span><br><span class=\"line\">                <span class=\"string\">&#x27;Value: <span class=\"subst\">$&#123;_counter.value&#125;</span>&#x27;</span>,</span><br><span class=\"line\">                style: TextStyle(fontSize: <span class=\"number\">48</span>),</span><br><span class=\"line\">              ))),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: () =&gt; Navigator.of(context)</span><br><span class=\"line\">            .push(MaterialPageRoute(builder: (context) =&gt; SecondPage())),</span><br><span class=\"line\">        child: Icon(Icons.navigate_next),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// <span class=\"language-markdown\">Provider 页面</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext buildContext) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Provider &quot;</span> + <span class=\"string\">&quot;SecondPage build&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">&#x27;Second Page&#x27;</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: Consumer&lt;CounterModel&gt;(</span><br><span class=\"line\">          builder: (context, CounterModel counter, _) =&gt; Center(</span><br><span class=\"line\">              child: GestureDetector(</span><br><span class=\"line\">                  onTap: () =&gt; &#123;counter.increment()&#125;,</span><br><span class=\"line\">                  child: Text(</span><br><span class=\"line\">                    <span class=\"string\">&#x27;Value: <span class=\"subst\">$&#123;counter.value&#125;</span>&#x27;</span>,</span><br><span class=\"line\">                    style: TextStyle(</span><br><span class=\"line\">                      fontSize: <span class=\"number\">48</span>,</span><br><span class=\"line\">                    ),</span><br><span class=\"line\">                  ))),</span><br><span class=\"line\">        ));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。</p>\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Widget <span class=\"built_in\">Function</span>(BuildContext context, T value, Widget child) builder;</span><br></pre></td></tr></table></figure>\n\n<p>从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Widget <span class=\"built_in\">Function</span>(BuildContext context, A value, B value2, Widget child) builder;</span><br></pre></td></tr></table></figure>\n\n<p>其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。</p>\n<p>那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 进入第一个页面，点击两次Value，使数据自增</span><br><span class=\"line\"><span class=\"number\">2.</span> 点击进入下一个页面</span><br><span class=\"line\"><span class=\"number\">3.</span> 在第二个页面，同样点击两次Value，使数据自增</span><br><span class=\"line\"><span class=\"number\">4.</span> 返回第一个页面，点击一次Value，自增</span><br></pre></td></tr></table></figure>\n\n\n<p>​\t<br>我们可以看到Log打印如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">26.873</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">27.777</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">29.290</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">30.203</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">31.726</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class=\"line\"><span class=\"number\">2020</span><span class=\"number\">-12</span><span class=\"number\">-12</span> <span class=\"number\">18</span>:<span class=\"number\">30</span>:<span class=\"number\">35.223</span> <span class=\"number\">4273</span><span class=\"number\">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br></pre></td></tr></table></figure>\n\n<p>可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder(</span><br><span class=\"line\">      context,</span><br><span class=\"line\">      Provider.of&lt;T&gt;(context),</span><br><span class=\"line\">      child,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？</p>\n<p>这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。</p>\n<p><img src=\"http://image.jucaiwy.com/image/20220419/flutter_state_code.png\"></p>\n<p>至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。</p>\n<p>Provider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析</p>\n<h3 id=\"五、-总结\"><a href=\"#五、-总结\" class=\"headerlink\" title=\"五、 总结\"></a>五、 总结</h3><p>总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。</p>\n<p>​\t</p>\n"},{"_content":"---\t\n\ntitle: HarmonyOS开发—基础—基础组件\n\ndate: 2024-01-29 19:32:46\n\ntags: [HarmonyOS开发,基础组件]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,基础组件\n\ndescription: 基础组件\n\ntop_img: http://image.jucaiwy.com/image/Harmony/Basic/basic.png\n\ncover: http://image.jucaiwy.com/image/Harmony/Basic/basic.png\n\n---\n\n## HarmonyOS开发—基础—基础组件\n\n课程链接：\n\nhttps://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997\n\n\n\n### 一、基础组件—Image\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4\n\n\n\nImage支持 str图片链接、PixelMap、Resource三种类型，但是在使用string链接加载网络图片时，需要在module.json5文件中，增加网络访问权限：\n\n```typescript\n\"requestPermissions\": [\n  {\n    \"name\": \"ohos.permission.INTERNET\"\n  }\n],\n```\n\nResource使用时，需要将图片放在resources 目录下的media文件夹中，然后使用进行展示：\n\n```typescript\nImage($r(\"app.media.image2\"))\n  .objectFit(ImageFit.Cover)\n  .backgroundColor(0xCCCCCC)\n  .width(100)\n  .height(100)\n```\n\n图片宽高可以直接设置为数字，或者string “100VP”\n\n\n\n### 二、基础组件—Text\n\n针对包含文本元素的组件，例如Text、Span、Button、TextInput等，可使用fontColor、fontSize、fontStyle、 fontWeight、fontFamily这些文本样式，分别设置文本的颜色、大小、样式、粗细以及字体，文本样式的属性如下表：\n\n| 名称         | 参数类型                       | 描述                                                         |\n| ------------ | ------------------------------ | ------------------------------------------------------------ |\n| fontColor    | ResourceColor                  | 设置文本颜色。                                               |\n| fontSize     | Length \\| Resource             | 设置文本尺寸，Length为number类型时，使用fp单位。             |\n| fontStyle    | FontStyle                      | 设置文本的字体样式。默认值：FontStyle.Normal。               |\n| fontWeight   | number \\| FontWeight \\| string | 设置文本的字体粗细，number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如“400”，以及“bold”、“bolder”、“lighter”、“regular”、“medium”，分别对应FontWeight中相应的枚举值。默认值：FontWeight.Normal。 |\n| fontFamily   | string \\| Resource             | 设置文本的字体列表。使用多个字体，使用“，”进行分割，优先级按顺序生效。例如：“Arial，sans-serif”。 |\n| textOverflow |                                | {overflow:TextOverflow.Ellipsis}                             |\n| maxLines     | number                         | 文本行数                                                     |\n\n常用的文本超长展示如下：\n\n```typescript\nText('This is the text content of Text Component This is the text content of Text Component')\n  .fontSize(16)\n  .maxLines(1)\n  .textOverflow({overflow:TextOverflow.Ellipsis})\n  .backgroundColor(0xE6F2FD) \n```\n\n### 三、基础组件—InputText\n\n#### 3.1 输入类型\n\ntype的参数类型为InputType，包含以下几种输入类型：\n\n- Normal：基本输入模式。支持输入数字、字母、下划线、空格、特殊字符。\n- Password：密码输入模式。\n- Email：e-mail地址输入模式。\n- Number：纯数字输入模式。\n\n#### 3.2 光标设置\n\n可以使用TextInputController动态设置光位置，下面的示例代码使用TextInputController的caretPosition方法，将光标移动到了第二个字符后。\n\n```typescript\n@Entry\n@Component\nstruct TextInputDemo {\n  controller: TextInputController = new TextInputController()\n \n  build() {\n    Column() {\n      TextInput({ controller: this.controller })\n      Button('设置光标位置')\n        .onClick(() => {\n          this.controller.caretPosition(2)\n        })\n    }\n    .height('100%')\n    .backgroundColor(0xE6F2FD)\n  }\n}\n```\n\n### 四、基础组件—Button\n\n#### 4.1 按钮类型\n\nCapsule：胶囊型，左右圆角\n\nNormal：普通长方形\n\nCircle：圆形按钮\n\n#### 4.2 按钮点击事件\n\n可以给Button绑定onClick事件，每当用户点击Button的时候，就会回调执行onClick方法，调用里面的逻辑代码。\n\n```typescript\nButton('登录', { type: ButtonType.Capsule, stateEffect: true })\n  .onClick(() => {\n  // 处理点击事件逻辑\n  })\n```\n\n#### 4.3 包含子组件\n\nButton组件可以包含子组件，让您可以开发出更丰富多样的Button，下面的示例代码中Button组件包含了一个Image组件：\n\n```typescript\nButton({ type: ButtonType.Circle, stateEffect: true }) {\n  Image($r('app.media.icon_delete'))\n    .width(30)\n    .height(30)\n}\n.width(55)\n.height(55)\n.backgroundColor(0x317aff)\n```\n\n### 五、基础组建—容器\n\n#### 5.1 布局容器中存在两个轴：\n\n主轴：Column容器中，主轴为从上到下，Row容器中，主轴为从左到右\n\n交叉轴：和主轴垂直\n\n#### 5.2 核心API：\n\nspace：容器在主轴上的间距，可以用来做分割线；\n\n#### 5.3 Column组件对齐方式\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4\n\njustifyContent：设置主轴上的对齐方式，其参数类型是FlexAlign\n\n- Start：元素在主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。\n- Center：元素在主轴方向中心对齐，第一个元素与行首的距离以及最后一个元素与行尾距离相同。\n- End：元素在主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。\n- SpaceBetween：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素与行首对齐，最后一个元素与行尾对齐。\n- SpaceAround：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。\n- SpaceEvenly：元素在主轴方向等间距布局，无论是相邻元素还是边界元素到容器的间距都一样。\n\nalignltems：设置交叉轴的对齐方式，其参数类型为HorizontalAlign（水平对齐）\n\n- Start：设置子组件在水平方向上按照起始端对齐。\n- Center（默认值）：设置子组件在水平方向上居中对齐。\n- End：设置子组件在水平方向上按照末端对齐。\n\n\n\n#### 5.4 Row容器组件对齐方式\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4\n\n主轴和Column的主轴对齐设置方式一致：\n\nalignItems：设置主轴上的对齐方式，其参数类型为VerticalAlign（垂直对齐）\n\n- Top：设置子组件在垂直方向上居顶部对齐。\n\n- Center（默认值）：设置子组件在竖直方向上居中对齐。\n\n- Bottom：设置子组件在竖直方向上居底部对齐。\n\n  \n\n### 六、基础组建—列表\n\n#### 6.1 List组建三个重要API\n\nspace：设置列表Item的间距\n\ninitialIndex：设置当前List初始化时，展示的位置\n\nscroller：用来控制List滑动\n\ndivider：分割线\n\nlistDirection：方向\n\n\n\n### 七、基础组建—Tabs\n\n","source":"_posts/20240129-HarmonyOS开发—基础—基础组件.md","raw":"---\t\n\ntitle: HarmonyOS开发—基础—基础组件\n\ndate: 2024-01-29 19:32:46\n\ntags: [HarmonyOS开发,基础组件]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,基础组件\n\ndescription: 基础组件\n\ntop_img: http://image.jucaiwy.com/image/Harmony/Basic/basic.png\n\ncover: http://image.jucaiwy.com/image/Harmony/Basic/basic.png\n\n---\n\n## HarmonyOS开发—基础—基础组件\n\n课程链接：\n\nhttps://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997\n\n\n\n### 一、基础组件—Image\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4\n\n\n\nImage支持 str图片链接、PixelMap、Resource三种类型，但是在使用string链接加载网络图片时，需要在module.json5文件中，增加网络访问权限：\n\n```typescript\n\"requestPermissions\": [\n  {\n    \"name\": \"ohos.permission.INTERNET\"\n  }\n],\n```\n\nResource使用时，需要将图片放在resources 目录下的media文件夹中，然后使用进行展示：\n\n```typescript\nImage($r(\"app.media.image2\"))\n  .objectFit(ImageFit.Cover)\n  .backgroundColor(0xCCCCCC)\n  .width(100)\n  .height(100)\n```\n\n图片宽高可以直接设置为数字，或者string “100VP”\n\n\n\n### 二、基础组件—Text\n\n针对包含文本元素的组件，例如Text、Span、Button、TextInput等，可使用fontColor、fontSize、fontStyle、 fontWeight、fontFamily这些文本样式，分别设置文本的颜色、大小、样式、粗细以及字体，文本样式的属性如下表：\n\n| 名称         | 参数类型                       | 描述                                                         |\n| ------------ | ------------------------------ | ------------------------------------------------------------ |\n| fontColor    | ResourceColor                  | 设置文本颜色。                                               |\n| fontSize     | Length \\| Resource             | 设置文本尺寸，Length为number类型时，使用fp单位。             |\n| fontStyle    | FontStyle                      | 设置文本的字体样式。默认值：FontStyle.Normal。               |\n| fontWeight   | number \\| FontWeight \\| string | 设置文本的字体粗细，number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如“400”，以及“bold”、“bolder”、“lighter”、“regular”、“medium”，分别对应FontWeight中相应的枚举值。默认值：FontWeight.Normal。 |\n| fontFamily   | string \\| Resource             | 设置文本的字体列表。使用多个字体，使用“，”进行分割，优先级按顺序生效。例如：“Arial，sans-serif”。 |\n| textOverflow |                                | {overflow:TextOverflow.Ellipsis}                             |\n| maxLines     | number                         | 文本行数                                                     |\n\n常用的文本超长展示如下：\n\n```typescript\nText('This is the text content of Text Component This is the text content of Text Component')\n  .fontSize(16)\n  .maxLines(1)\n  .textOverflow({overflow:TextOverflow.Ellipsis})\n  .backgroundColor(0xE6F2FD) \n```\n\n### 三、基础组件—InputText\n\n#### 3.1 输入类型\n\ntype的参数类型为InputType，包含以下几种输入类型：\n\n- Normal：基本输入模式。支持输入数字、字母、下划线、空格、特殊字符。\n- Password：密码输入模式。\n- Email：e-mail地址输入模式。\n- Number：纯数字输入模式。\n\n#### 3.2 光标设置\n\n可以使用TextInputController动态设置光位置，下面的示例代码使用TextInputController的caretPosition方法，将光标移动到了第二个字符后。\n\n```typescript\n@Entry\n@Component\nstruct TextInputDemo {\n  controller: TextInputController = new TextInputController()\n \n  build() {\n    Column() {\n      TextInput({ controller: this.controller })\n      Button('设置光标位置')\n        .onClick(() => {\n          this.controller.caretPosition(2)\n        })\n    }\n    .height('100%')\n    .backgroundColor(0xE6F2FD)\n  }\n}\n```\n\n### 四、基础组件—Button\n\n#### 4.1 按钮类型\n\nCapsule：胶囊型，左右圆角\n\nNormal：普通长方形\n\nCircle：圆形按钮\n\n#### 4.2 按钮点击事件\n\n可以给Button绑定onClick事件，每当用户点击Button的时候，就会回调执行onClick方法，调用里面的逻辑代码。\n\n```typescript\nButton('登录', { type: ButtonType.Capsule, stateEffect: true })\n  .onClick(() => {\n  // 处理点击事件逻辑\n  })\n```\n\n#### 4.3 包含子组件\n\nButton组件可以包含子组件，让您可以开发出更丰富多样的Button，下面的示例代码中Button组件包含了一个Image组件：\n\n```typescript\nButton({ type: ButtonType.Circle, stateEffect: true }) {\n  Image($r('app.media.icon_delete'))\n    .width(30)\n    .height(30)\n}\n.width(55)\n.height(55)\n.backgroundColor(0x317aff)\n```\n\n### 五、基础组建—容器\n\n#### 5.1 布局容器中存在两个轴：\n\n主轴：Column容器中，主轴为从上到下，Row容器中，主轴为从左到右\n\n交叉轴：和主轴垂直\n\n#### 5.2 核心API：\n\nspace：容器在主轴上的间距，可以用来做分割线；\n\n#### 5.3 Column组件对齐方式\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4\n\njustifyContent：设置主轴上的对齐方式，其参数类型是FlexAlign\n\n- Start：元素在主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。\n- Center：元素在主轴方向中心对齐，第一个元素与行首的距离以及最后一个元素与行尾距离相同。\n- End：元素在主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。\n- SpaceBetween：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素与行首对齐，最后一个元素与行尾对齐。\n- SpaceAround：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。\n- SpaceEvenly：元素在主轴方向等间距布局，无论是相邻元素还是边界元素到容器的间距都一样。\n\nalignltems：设置交叉轴的对齐方式，其参数类型为HorizontalAlign（水平对齐）\n\n- Start：设置子组件在水平方向上按照起始端对齐。\n- Center（默认值）：设置子组件在水平方向上居中对齐。\n- End：设置子组件在水平方向上按照末端对齐。\n\n\n\n#### 5.4 Row容器组件对齐方式\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4\n\n主轴和Column的主轴对齐设置方式一致：\n\nalignItems：设置主轴上的对齐方式，其参数类型为VerticalAlign（垂直对齐）\n\n- Top：设置子组件在垂直方向上居顶部对齐。\n\n- Center（默认值）：设置子组件在竖直方向上居中对齐。\n\n- Bottom：设置子组件在竖直方向上居底部对齐。\n\n  \n\n### 六、基础组建—列表\n\n#### 6.1 List组建三个重要API\n\nspace：设置列表Item的间距\n\ninitialIndex：设置当前List初始化时，展示的位置\n\nscroller：用来控制List滑动\n\ndivider：分割线\n\nlistDirection：方向\n\n\n\n### 七、基础组建—Tabs\n\n","slug":"20240129-HarmonyOS开发—基础—基础组件","published":1,"date":"2020-12-06T07:45:59.000Z","updated":"2024-07-10T10:24:02.825Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01i00040nv64gq5anus","content":"<hr>\n<p>title: HarmonyOS开发—基础—基础组件</p>\n<p>date: 2024-01-29 19:32:46</p>\n<p>tags: [HarmonyOS开发,基础组件]</p>\n<p>categories: HarmonyOS</p>\n<p>keywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,基础组件</p>\n<p>description: 基础组件</p>\n<p>top_img: <a href=\"http://image.jucaiwy.com/image/Harmony/Basic/basic.png\">http://image.jucaiwy.com/image/Harmony/Basic/basic.png</a></p>\n<p>cover: <a href=\"http://image.jucaiwy.com/image/Harmony/Basic/basic.png\">http://image.jucaiwy.com/image/Harmony/Basic/basic.png</a></p>\n<hr>\n<h2 id=\"HarmonyOS开发—基础—基础组件\"><a href=\"#HarmonyOS开发—基础—基础组件\" class=\"headerlink\" title=\"HarmonyOS开发—基础—基础组件\"></a>HarmonyOS开发—基础—基础组件</h2><p>课程链接：</p>\n<p><a href=\"https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997\">https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997</a></p>\n<h3 id=\"一、基础组件—Image\"><a href=\"#一、基础组件—Image\" class=\"headerlink\" title=\"一、基础组件—Image\"></a>一、基础组件—Image</h3><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4</a></p>\n<p>Image支持 str图片链接、PixelMap、Resource三种类型，但是在使用string链接加载网络图片时，需要在module.json5文件中，增加网络访问权限：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;requestPermissions&quot;</span>: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;ohos.permission.INTERNET&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>Resource使用时，需要将图片放在resources 目录下的media文件夹中，然后使用进行展示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Image</span>($r(<span class=\"string\">&quot;app.media.image2&quot;</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">objectFit</span>(<span class=\"title class_\">ImageFit</span>.<span class=\"property\">Cover</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xCCCCCC</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">width</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">height</span>(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p>图片宽高可以直接设置为数字，或者string “100VP”</p>\n<h3 id=\"二、基础组件—Text\"><a href=\"#二、基础组件—Text\" class=\"headerlink\" title=\"二、基础组件—Text\"></a>二、基础组件—Text</h3><p>针对包含文本元素的组件，例如Text、Span、Button、TextInput等，可使用fontColor、fontSize、fontStyle、 fontWeight、fontFamily这些文本样式，分别设置文本的颜色、大小、样式、粗细以及字体，文本样式的属性如下表：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>参数类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>fontColor</td>\n<td>ResourceColor</td>\n<td>设置文本颜色。</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>Length | Resource</td>\n<td>设置文本尺寸，Length为number类型时，使用fp单位。</td>\n</tr>\n<tr>\n<td>fontStyle</td>\n<td>FontStyle</td>\n<td>设置文本的字体样式。默认值：FontStyle.Normal。</td>\n</tr>\n<tr>\n<td>fontWeight</td>\n<td>number | FontWeight | string</td>\n<td>设置文本的字体粗细，number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如“400”，以及“bold”、“bolder”、“lighter”、“regular”、“medium”，分别对应FontWeight中相应的枚举值。默认值：FontWeight.Normal。</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>string | Resource</td>\n<td>设置文本的字体列表。使用多个字体，使用“，”进行分割，优先级按顺序生效。例如：“Arial，sans-serif”。</td>\n</tr>\n<tr>\n<td>textOverflow</td>\n<td></td>\n<td>{overflow:TextOverflow.Ellipsis}</td>\n</tr>\n<tr>\n<td>maxLines</td>\n<td>number</td>\n<td>文本行数</td>\n</tr>\n</tbody></table>\n<p>常用的文本超长展示如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;This is the text content of Text Component This is the text content of Text Component&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">fontSize</span>(<span class=\"number\">16</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">maxLines</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">textOverflow</span>(&#123;<span class=\"attr\">overflow</span>:<span class=\"title class_\">TextOverflow</span>.<span class=\"property\">Ellipsis</span>&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xE6F2FD</span>) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、基础组件—InputText\"><a href=\"#三、基础组件—InputText\" class=\"headerlink\" title=\"三、基础组件—InputText\"></a>三、基础组件—InputText</h3><h4 id=\"3-1-输入类型\"><a href=\"#3-1-输入类型\" class=\"headerlink\" title=\"3.1 输入类型\"></a>3.1 输入类型</h4><p>type的参数类型为InputType，包含以下几种输入类型：</p>\n<ul>\n<li>Normal：基本输入模式。支持输入数字、字母、下划线、空格、特殊字符。</li>\n<li>Password：密码输入模式。</li>\n<li>Email：e-mail地址输入模式。</li>\n<li>Number：纯数字输入模式。</li>\n</ul>\n<h4 id=\"3-2-光标设置\"><a href=\"#3-2-光标设置\" class=\"headerlink\" title=\"3.2 光标设置\"></a>3.2 光标设置</h4><p>可以使用TextInputController动态设置光位置，下面的示例代码使用TextInputController的caretPosition方法，将光标移动到了第二个字符后。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">TextInputDemo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">controller</span>: <span class=\"title class_\">TextInputController</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TextInputController</span>()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">TextInput</span>(&#123; <span class=\"attr\">controller</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">controller</span> &#125;)</span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;设置光标位置&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">controller</span>.<span class=\"title function_\">caretPosition</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .<span class=\"title function_\">height</span>(<span class=\"string\">&#x27;100%&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xE6F2FD</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、基础组件—Button\"><a href=\"#四、基础组件—Button\" class=\"headerlink\" title=\"四、基础组件—Button\"></a>四、基础组件—Button</h3><h4 id=\"4-1-按钮类型\"><a href=\"#4-1-按钮类型\" class=\"headerlink\" title=\"4.1 按钮类型\"></a>4.1 按钮类型</h4><p>Capsule：胶囊型，左右圆角</p>\n<p>Normal：普通长方形</p>\n<p>Circle：圆形按钮</p>\n<h4 id=\"4-2-按钮点击事件\"><a href=\"#4-2-按钮点击事件\" class=\"headerlink\" title=\"4.2 按钮点击事件\"></a>4.2 按钮点击事件</h4><p>可以给Button绑定onClick事件，每当用户点击Button的时候，就会回调执行onClick方法，调用里面的逻辑代码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;登录&#x27;</span>, &#123; <span class=\"attr\">type</span>: <span class=\"title class_\">ButtonType</span>.<span class=\"property\">Capsule</span>, <span class=\"attr\">stateEffect</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理点击事件逻辑</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-包含子组件\"><a href=\"#4-3-包含子组件\" class=\"headerlink\" title=\"4.3 包含子组件\"></a>4.3 包含子组件</h4><p>Button组件可以包含子组件，让您可以开发出更丰富多样的Button，下面的示例代码中Button组件包含了一个Image组件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Button</span>(&#123; <span class=\"attr\">type</span>: <span class=\"title class_\">ButtonType</span>.<span class=\"property\">Circle</span>, <span class=\"attr\">stateEffect</span>: <span class=\"literal\">true</span> &#125;) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Image</span>($r(<span class=\"string\">&#x27;app.media.icon_delete&#x27;</span>))</span><br><span class=\"line\">    .<span class=\"title function_\">width</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">height</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.<span class=\"title function_\">width</span>(<span class=\"number\">55</span>)</span><br><span class=\"line\">.<span class=\"title function_\">height</span>(<span class=\"number\">55</span>)</span><br><span class=\"line\">.<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0x317aff</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、基础组建—容器\"><a href=\"#五、基础组建—容器\" class=\"headerlink\" title=\"五、基础组建—容器\"></a>五、基础组建—容器</h3><h4 id=\"5-1-布局容器中存在两个轴：\"><a href=\"#5-1-布局容器中存在两个轴：\" class=\"headerlink\" title=\"5.1 布局容器中存在两个轴：\"></a>5.1 布局容器中存在两个轴：</h4><p>主轴：Column容器中，主轴为从上到下，Row容器中，主轴为从左到右</p>\n<p>交叉轴：和主轴垂直</p>\n<h4 id=\"5-2-核心API：\"><a href=\"#5-2-核心API：\" class=\"headerlink\" title=\"5.2 核心API：\"></a>5.2 核心API：</h4><p>space：容器在主轴上的间距，可以用来做分割线；</p>\n<h4 id=\"5-3-Column组件对齐方式\"><a href=\"#5-3-Column组件对齐方式\" class=\"headerlink\" title=\"5.3 Column组件对齐方式\"></a>5.3 Column组件对齐方式</h4><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4</a></p>\n<p>justifyContent：设置主轴上的对齐方式，其参数类型是FlexAlign</p>\n<ul>\n<li>Start：元素在主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。</li>\n<li>Center：元素在主轴方向中心对齐，第一个元素与行首的距离以及最后一个元素与行尾距离相同。</li>\n<li>End：元素在主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。</li>\n<li>SpaceBetween：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素与行首对齐，最后一个元素与行尾对齐。</li>\n<li>SpaceAround：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。</li>\n<li>SpaceEvenly：元素在主轴方向等间距布局，无论是相邻元素还是边界元素到容器的间距都一样。</li>\n</ul>\n<p>alignltems：设置交叉轴的对齐方式，其参数类型为HorizontalAlign（水平对齐）</p>\n<ul>\n<li>Start：设置子组件在水平方向上按照起始端对齐。</li>\n<li>Center（默认值）：设置子组件在水平方向上居中对齐。</li>\n<li>End：设置子组件在水平方向上按照末端对齐。</li>\n</ul>\n<h4 id=\"5-4-Row容器组件对齐方式\"><a href=\"#5-4-Row容器组件对齐方式\" class=\"headerlink\" title=\"5.4 Row容器组件对齐方式\"></a>5.4 Row容器组件对齐方式</h4><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4</a></p>\n<p>主轴和Column的主轴对齐设置方式一致：</p>\n<p>alignItems：设置主轴上的对齐方式，其参数类型为VerticalAlign（垂直对齐）</p>\n<ul>\n<li><p>Top：设置子组件在垂直方向上居顶部对齐。</p>\n</li>\n<li><p>Center（默认值）：设置子组件在竖直方向上居中对齐。</p>\n</li>\n<li><p>Bottom：设置子组件在竖直方向上居底部对齐。</p>\n</li>\n</ul>\n<h3 id=\"六、基础组建—列表\"><a href=\"#六、基础组建—列表\" class=\"headerlink\" title=\"六、基础组建—列表\"></a>六、基础组建—列表</h3><h4 id=\"6-1-List组建三个重要API\"><a href=\"#6-1-List组建三个重要API\" class=\"headerlink\" title=\"6.1 List组建三个重要API\"></a>6.1 List组建三个重要API</h4><p>space：设置列表Item的间距</p>\n<p>initialIndex：设置当前List初始化时，展示的位置</p>\n<p>scroller：用来控制List滑动</p>\n<p>divider：分割线</p>\n<p>listDirection：方向</p>\n<h3 id=\"七、基础组建—Tabs\"><a href=\"#七、基础组建—Tabs\" class=\"headerlink\" title=\"七、基础组建—Tabs\"></a>七、基础组建—Tabs</h3>","site":{"data":{}},"cover":"http://image.jucaiwy.com/back_001.jpg","excerpt":"","more":"<hr>\n<p>title: HarmonyOS开发—基础—基础组件</p>\n<p>date: 2024-01-29 19:32:46</p>\n<p>tags: [HarmonyOS开发,基础组件]</p>\n<p>categories: HarmonyOS</p>\n<p>keywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,基础组件</p>\n<p>description: 基础组件</p>\n<p>top_img: <a href=\"http://image.jucaiwy.com/image/Harmony/Basic/basic.png\">http://image.jucaiwy.com/image/Harmony/Basic/basic.png</a></p>\n<p>cover: <a href=\"http://image.jucaiwy.com/image/Harmony/Basic/basic.png\">http://image.jucaiwy.com/image/Harmony/Basic/basic.png</a></p>\n<hr>\n<h2 id=\"HarmonyOS开发—基础—基础组件\"><a href=\"#HarmonyOS开发—基础—基础组件\" class=\"headerlink\" title=\"HarmonyOS开发—基础—基础组件\"></a>HarmonyOS开发—基础—基础组件</h2><p>课程链接：</p>\n<p><a href=\"https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997\">https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997</a></p>\n<h3 id=\"一、基础组件—Image\"><a href=\"#一、基础组件—Image\" class=\"headerlink\" title=\"一、基础组件—Image\"></a>一、基础组件—Image</h3><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-basic-components-image-0000001580026342-V4</a></p>\n<p>Image支持 str图片链接、PixelMap、Resource三种类型，但是在使用string链接加载网络图片时，需要在module.json5文件中，增加网络访问权限：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;requestPermissions&quot;</span>: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;ohos.permission.INTERNET&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>Resource使用时，需要将图片放在resources 目录下的media文件夹中，然后使用进行展示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Image</span>($r(<span class=\"string\">&quot;app.media.image2&quot;</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">objectFit</span>(<span class=\"title class_\">ImageFit</span>.<span class=\"property\">Cover</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xCCCCCC</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">width</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">height</span>(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p>图片宽高可以直接设置为数字，或者string “100VP”</p>\n<h3 id=\"二、基础组件—Text\"><a href=\"#二、基础组件—Text\" class=\"headerlink\" title=\"二、基础组件—Text\"></a>二、基础组件—Text</h3><p>针对包含文本元素的组件，例如Text、Span、Button、TextInput等，可使用fontColor、fontSize、fontStyle、 fontWeight、fontFamily这些文本样式，分别设置文本的颜色、大小、样式、粗细以及字体，文本样式的属性如下表：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>参数类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>fontColor</td>\n<td>ResourceColor</td>\n<td>设置文本颜色。</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>Length | Resource</td>\n<td>设置文本尺寸，Length为number类型时，使用fp单位。</td>\n</tr>\n<tr>\n<td>fontStyle</td>\n<td>FontStyle</td>\n<td>设置文本的字体样式。默认值：FontStyle.Normal。</td>\n</tr>\n<tr>\n<td>fontWeight</td>\n<td>number | FontWeight | string</td>\n<td>设置文本的字体粗细，number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如“400”，以及“bold”、“bolder”、“lighter”、“regular”、“medium”，分别对应FontWeight中相应的枚举值。默认值：FontWeight.Normal。</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>string | Resource</td>\n<td>设置文本的字体列表。使用多个字体，使用“，”进行分割，优先级按顺序生效。例如：“Arial，sans-serif”。</td>\n</tr>\n<tr>\n<td>textOverflow</td>\n<td></td>\n<td>{overflow:TextOverflow.Ellipsis}</td>\n</tr>\n<tr>\n<td>maxLines</td>\n<td>number</td>\n<td>文本行数</td>\n</tr>\n</tbody></table>\n<p>常用的文本超长展示如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;This is the text content of Text Component This is the text content of Text Component&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">fontSize</span>(<span class=\"number\">16</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">maxLines</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">textOverflow</span>(&#123;<span class=\"attr\">overflow</span>:<span class=\"title class_\">TextOverflow</span>.<span class=\"property\">Ellipsis</span>&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xE6F2FD</span>) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、基础组件—InputText\"><a href=\"#三、基础组件—InputText\" class=\"headerlink\" title=\"三、基础组件—InputText\"></a>三、基础组件—InputText</h3><h4 id=\"3-1-输入类型\"><a href=\"#3-1-输入类型\" class=\"headerlink\" title=\"3.1 输入类型\"></a>3.1 输入类型</h4><p>type的参数类型为InputType，包含以下几种输入类型：</p>\n<ul>\n<li>Normal：基本输入模式。支持输入数字、字母、下划线、空格、特殊字符。</li>\n<li>Password：密码输入模式。</li>\n<li>Email：e-mail地址输入模式。</li>\n<li>Number：纯数字输入模式。</li>\n</ul>\n<h4 id=\"3-2-光标设置\"><a href=\"#3-2-光标设置\" class=\"headerlink\" title=\"3.2 光标设置\"></a>3.2 光标设置</h4><p>可以使用TextInputController动态设置光位置，下面的示例代码使用TextInputController的caretPosition方法，将光标移动到了第二个字符后。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">TextInputDemo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">controller</span>: <span class=\"title class_\">TextInputController</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TextInputController</span>()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">TextInput</span>(&#123; <span class=\"attr\">controller</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">controller</span> &#125;)</span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;设置光标位置&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">controller</span>.<span class=\"title function_\">caretPosition</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .<span class=\"title function_\">height</span>(<span class=\"string\">&#x27;100%&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0xE6F2FD</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、基础组件—Button\"><a href=\"#四、基础组件—Button\" class=\"headerlink\" title=\"四、基础组件—Button\"></a>四、基础组件—Button</h3><h4 id=\"4-1-按钮类型\"><a href=\"#4-1-按钮类型\" class=\"headerlink\" title=\"4.1 按钮类型\"></a>4.1 按钮类型</h4><p>Capsule：胶囊型，左右圆角</p>\n<p>Normal：普通长方形</p>\n<p>Circle：圆形按钮</p>\n<h4 id=\"4-2-按钮点击事件\"><a href=\"#4-2-按钮点击事件\" class=\"headerlink\" title=\"4.2 按钮点击事件\"></a>4.2 按钮点击事件</h4><p>可以给Button绑定onClick事件，每当用户点击Button的时候，就会回调执行onClick方法，调用里面的逻辑代码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;登录&#x27;</span>, &#123; <span class=\"attr\">type</span>: <span class=\"title class_\">ButtonType</span>.<span class=\"property\">Capsule</span>, <span class=\"attr\">stateEffect</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理点击事件逻辑</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-包含子组件\"><a href=\"#4-3-包含子组件\" class=\"headerlink\" title=\"4.3 包含子组件\"></a>4.3 包含子组件</h4><p>Button组件可以包含子组件，让您可以开发出更丰富多样的Button，下面的示例代码中Button组件包含了一个Image组件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Button</span>(&#123; <span class=\"attr\">type</span>: <span class=\"title class_\">ButtonType</span>.<span class=\"property\">Circle</span>, <span class=\"attr\">stateEffect</span>: <span class=\"literal\">true</span> &#125;) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Image</span>($r(<span class=\"string\">&#x27;app.media.icon_delete&#x27;</span>))</span><br><span class=\"line\">    .<span class=\"title function_\">width</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">height</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.<span class=\"title function_\">width</span>(<span class=\"number\">55</span>)</span><br><span class=\"line\">.<span class=\"title function_\">height</span>(<span class=\"number\">55</span>)</span><br><span class=\"line\">.<span class=\"title function_\">backgroundColor</span>(<span class=\"number\">0x317aff</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、基础组建—容器\"><a href=\"#五、基础组建—容器\" class=\"headerlink\" title=\"五、基础组建—容器\"></a>五、基础组建—容器</h3><h4 id=\"5-1-布局容器中存在两个轴：\"><a href=\"#5-1-布局容器中存在两个轴：\" class=\"headerlink\" title=\"5.1 布局容器中存在两个轴：\"></a>5.1 布局容器中存在两个轴：</h4><p>主轴：Column容器中，主轴为从上到下，Row容器中，主轴为从左到右</p>\n<p>交叉轴：和主轴垂直</p>\n<h4 id=\"5-2-核心API：\"><a href=\"#5-2-核心API：\" class=\"headerlink\" title=\"5.2 核心API：\"></a>5.2 核心API：</h4><p>space：容器在主轴上的间距，可以用来做分割线；</p>\n<h4 id=\"5-3-Column组件对齐方式\"><a href=\"#5-3-Column组件对齐方式\" class=\"headerlink\" title=\"5.3 Column组件对齐方式\"></a>5.3 Column组件对齐方式</h4><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-column-0000001579866558-V4</a></p>\n<p>justifyContent：设置主轴上的对齐方式，其参数类型是FlexAlign</p>\n<ul>\n<li>Start：元素在主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。</li>\n<li>Center：元素在主轴方向中心对齐，第一个元素与行首的距离以及最后一个元素与行尾距离相同。</li>\n<li>End：元素在主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。</li>\n<li>SpaceBetween：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素与行首对齐，最后一个元素与行尾对齐。</li>\n<li>SpaceAround：元素在主轴方向均匀分配弹性元素，相邻元素之间距离相同。 第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。</li>\n<li>SpaceEvenly：元素在主轴方向等间距布局，无论是相邻元素还是边界元素到容器的间距都一样。</li>\n</ul>\n<p>alignltems：设置交叉轴的对齐方式，其参数类型为HorizontalAlign（水平对齐）</p>\n<ul>\n<li>Start：设置子组件在水平方向上按照起始端对齐。</li>\n<li>Center（默认值）：设置子组件在水平方向上居中对齐。</li>\n<li>End：设置子组件在水平方向上按照末端对齐。</li>\n</ul>\n<h4 id=\"5-4-Row容器组件对齐方式\"><a href=\"#5-4-Row容器组件对齐方式\" class=\"headerlink\" title=\"5.4 Row容器组件对齐方式\"></a>5.4 Row容器组件对齐方式</h4><p><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4\">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V4/ts-container-row-0000001579866566-V4</a></p>\n<p>主轴和Column的主轴对齐设置方式一致：</p>\n<p>alignItems：设置主轴上的对齐方式，其参数类型为VerticalAlign（垂直对齐）</p>\n<ul>\n<li><p>Top：设置子组件在垂直方向上居顶部对齐。</p>\n</li>\n<li><p>Center（默认值）：设置子组件在竖直方向上居中对齐。</p>\n</li>\n<li><p>Bottom：设置子组件在竖直方向上居底部对齐。</p>\n</li>\n</ul>\n<h3 id=\"六、基础组建—列表\"><a href=\"#六、基础组建—列表\" class=\"headerlink\" title=\"六、基础组建—列表\"></a>六、基础组建—列表</h3><h4 id=\"6-1-List组建三个重要API\"><a href=\"#6-1-List组建三个重要API\" class=\"headerlink\" title=\"6.1 List组建三个重要API\"></a>6.1 List组建三个重要API</h4><p>space：设置列表Item的间距</p>\n<p>initialIndex：设置当前List初始化时，展示的位置</p>\n<p>scroller：用来控制List滑动</p>\n<p>divider：分割线</p>\n<p>listDirection：方向</p>\n<h3 id=\"七、基础组建—Tabs\"><a href=\"#七、基础组建—Tabs\" class=\"headerlink\" title=\"七、基础组建—Tabs\"></a>七、基础组建—Tabs</h3>"},{"title":"HarmonyOS开发—基础—应用程序入口-UIAbility","date":"2023-12-29T01:52:46.000Z","keywords":"HarmonyOS,HarmonyOS开发,HarmonyOS入门,UIAbility","description":"UIAbility","top_img":"http://image.jucaiwy.com/image/Harmony/UIAbility/UIAbility.png","cover":"http://image.jucaiwy.com/image/Harmony/UIAbility/UIAbility.png","_content":"\n## HarmonyOS开发—基础—应用程序入口-UIAbility\n\n\n\n### 一、什么是UIAbility\n\nUIAbility是一种包含用户界面的UI组件，主要用于和用户进行交互。一个应用，可以有一个UIAbility也可以有多个UIAbility，自鸿蒙API10以后，建议一个应用只有一个UIAbility，多个页面为**多个组件**。\n\n![img](http://image.jucaiwy.com/image/Harmony/UIAbility/single.png)\n\n\n\n### 二、UIAbilit之间跳转\n\n 多个UIAbility之间跳转，API9之前推荐使用Router\n\n```\nrouter.pushUrl({\n  url: 'pages/Second',\n  params: {\n    src: 'Index页面传来的数据',\n  }\n}, router.RouterMode.Single)\n```\n\nrouter.pushUrl支持两种模式跳转，分别为single和standard，设置为single时，每次会先看堆栈内是否有单个实例，没有的话，会创建一个，有的话，会推倒栈顶；设置为standard时，每次pushUrl会多一个实例\n\n返回页面可以使用：\n\n```\n// 返回上一个页面\nrouter.back();\n\n// 返回指定页面\nrouter.back({ url: 'pages/Index' });\n```\n\nAPI10 及之后，推荐使用Navigation进行页面之间跳转，因为此时建议一个应用内部只有一个UIAbility，所以，页面在这个UIAbility中，作为组建进行存在，此时页面跳转变成了UI组件跳转，因此推荐使用Navigation。\n\n\n\n**案例待补充**\n\n\n\n### 三、UIAbility生命周期\n\nUIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，WindowStageCreate和WindowStageDestroy为窗口管理器（WindowStage）在UIAbility中管理UI界面功能的两个生命周期回调，从而实现UIAbility与窗口之间的弱耦合。\n\n![img](http://image.jucaiwy.com/image/Harmony/UIAbility/lifecycle.png)\n\n\n\n**Create:** 应用初始化操作，变量定义、资源加载，用于后续UI展示\n\n**onWindowStageCreate**：UIAbility创建完成以后，进入Foreground之前，系统会创建一个WindowStage，WindowStage创建完成以后，回掉onWindowStageCreate，可以在这里进行UI页面加载、WindowStage订阅等操作，获取焦点、失去焦点、可见不可见等；通过loadContent加载指定的页面：\n\n```typescript\nonWindowStageCreate(windowStage: window.WindowStage): void {\n  windowStage.loadContent('pages/Index', (err, data) => {\n    if (err.code) {\n      return;\n    }\n  });\n}\n```\n\n**onForeground**：应用切换至前台时回掉，申请系统需要资源\n\n**onBackground**：应用切换至后台时回掉，释放无用资源，执行耗时操作，例如状态保存\n\n**onWindowStageDestroy**：释放UI界面资源，注销WindowStage相关事件\n\n**onDestroy：**在UIAbility销毁时触发，可以在onDestroy回调中进行系统资源的释放\n\n### 四、UIAbility启动模式：\n\nUIAbility启动模式需要在module.json5文件中配置**lunchType**字段？\n\n- singleton（单实例模式）\n- standard（标准实例模式）\n- specified（指定实例模式）\n\n","source":"_posts/20231229-HarmonyOS开发—基础—应用程序入口-UIAbility.md","raw":"---\n\ntitle: HarmonyOS开发—基础—应用程序入口-UIAbility\n\ndate: 2023-12-29 9:52:46\n\ntags: [HarmonyOS开发,UIAbility]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,UIAbility\n\ndescription: UIAbility\n\ntop_img: http://image.jucaiwy.com/image/Harmony/UIAbility/UIAbility.png\t\n\ncover: http://image.jucaiwy.com/image/Harmony/UIAbility/UIAbility.png\n\n---\n\n## HarmonyOS开发—基础—应用程序入口-UIAbility\n\n\n\n### 一、什么是UIAbility\n\nUIAbility是一种包含用户界面的UI组件，主要用于和用户进行交互。一个应用，可以有一个UIAbility也可以有多个UIAbility，自鸿蒙API10以后，建议一个应用只有一个UIAbility，多个页面为**多个组件**。\n\n![img](http://image.jucaiwy.com/image/Harmony/UIAbility/single.png)\n\n\n\n### 二、UIAbilit之间跳转\n\n 多个UIAbility之间跳转，API9之前推荐使用Router\n\n```\nrouter.pushUrl({\n  url: 'pages/Second',\n  params: {\n    src: 'Index页面传来的数据',\n  }\n}, router.RouterMode.Single)\n```\n\nrouter.pushUrl支持两种模式跳转，分别为single和standard，设置为single时，每次会先看堆栈内是否有单个实例，没有的话，会创建一个，有的话，会推倒栈顶；设置为standard时，每次pushUrl会多一个实例\n\n返回页面可以使用：\n\n```\n// 返回上一个页面\nrouter.back();\n\n// 返回指定页面\nrouter.back({ url: 'pages/Index' });\n```\n\nAPI10 及之后，推荐使用Navigation进行页面之间跳转，因为此时建议一个应用内部只有一个UIAbility，所以，页面在这个UIAbility中，作为组建进行存在，此时页面跳转变成了UI组件跳转，因此推荐使用Navigation。\n\n\n\n**案例待补充**\n\n\n\n### 三、UIAbility生命周期\n\nUIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，WindowStageCreate和WindowStageDestroy为窗口管理器（WindowStage）在UIAbility中管理UI界面功能的两个生命周期回调，从而实现UIAbility与窗口之间的弱耦合。\n\n![img](http://image.jucaiwy.com/image/Harmony/UIAbility/lifecycle.png)\n\n\n\n**Create:** 应用初始化操作，变量定义、资源加载，用于后续UI展示\n\n**onWindowStageCreate**：UIAbility创建完成以后，进入Foreground之前，系统会创建一个WindowStage，WindowStage创建完成以后，回掉onWindowStageCreate，可以在这里进行UI页面加载、WindowStage订阅等操作，获取焦点、失去焦点、可见不可见等；通过loadContent加载指定的页面：\n\n```typescript\nonWindowStageCreate(windowStage: window.WindowStage): void {\n  windowStage.loadContent('pages/Index', (err, data) => {\n    if (err.code) {\n      return;\n    }\n  });\n}\n```\n\n**onForeground**：应用切换至前台时回掉，申请系统需要资源\n\n**onBackground**：应用切换至后台时回掉，释放无用资源，执行耗时操作，例如状态保存\n\n**onWindowStageDestroy**：释放UI界面资源，注销WindowStage相关事件\n\n**onDestroy：**在UIAbility销毁时触发，可以在onDestroy回调中进行系统资源的释放\n\n### 四、UIAbility启动模式：\n\nUIAbility启动模式需要在module.json5文件中配置**lunchType**字段？\n\n- singleton（单实例模式）\n- standard（标准实例模式）\n- specified（指定实例模式）\n\n","slug":"20231229-HarmonyOS开发—基础—应用程序入口-UIAbility","published":1,"updated":"2024-07-10T10:23:48.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01k00060nv6fe01fxxr","content":"<h2 id=\"HarmonyOS开发—基础—应用程序入口-UIAbility\"><a href=\"#HarmonyOS开发—基础—应用程序入口-UIAbility\" class=\"headerlink\" title=\"HarmonyOS开发—基础—应用程序入口-UIAbility\"></a>HarmonyOS开发—基础—应用程序入口-UIAbility</h2><h3 id=\"一、什么是UIAbility\"><a href=\"#一、什么是UIAbility\" class=\"headerlink\" title=\"一、什么是UIAbility\"></a>一、什么是UIAbility</h3><p>UIAbility是一种包含用户界面的UI组件，主要用于和用户进行交互。一个应用，可以有一个UIAbility也可以有多个UIAbility，自鸿蒙API10以后，建议一个应用只有一个UIAbility，多个页面为<strong>多个组件</strong>。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/UIAbility/single.png\" alt=\"img\"></p>\n<h3 id=\"二、UIAbilit之间跳转\"><a href=\"#二、UIAbilit之间跳转\" class=\"headerlink\" title=\"二、UIAbilit之间跳转\"></a>二、UIAbilit之间跳转</h3><p> 多个UIAbility之间跳转，API9之前推荐使用Router</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.pushUrl(&#123;</span><br><span class=\"line\">  url: &#x27;pages/Second&#x27;,</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    src: &#x27;Index页面传来的数据&#x27;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, router.RouterMode.Single)</span><br></pre></td></tr></table></figure>\n\n<p>router.pushUrl支持两种模式跳转，分别为single和standard，设置为single时，每次会先看堆栈内是否有单个实例，没有的话，会创建一个，有的话，会推倒栈顶；设置为standard时，每次pushUrl会多一个实例</p>\n<p>返回页面可以使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回上一个页面</span><br><span class=\"line\">router.back();</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回指定页面</span><br><span class=\"line\">router.back(&#123; url: &#x27;pages/Index&#x27; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>API10 及之后，推荐使用Navigation进行页面之间跳转，因为此时建议一个应用内部只有一个UIAbility，所以，页面在这个UIAbility中，作为组建进行存在，此时页面跳转变成了UI组件跳转，因此推荐使用Navigation。</p>\n<p><strong>案例待补充</strong></p>\n<h3 id=\"三、UIAbility生命周期\"><a href=\"#三、UIAbility生命周期\" class=\"headerlink\" title=\"三、UIAbility生命周期\"></a>三、UIAbility生命周期</h3><p>UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，WindowStageCreate和WindowStageDestroy为窗口管理器（WindowStage）在UIAbility中管理UI界面功能的两个生命周期回调，从而实现UIAbility与窗口之间的弱耦合。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/UIAbility/lifecycle.png\" alt=\"img\"></p>\n<p><strong>Create:</strong> 应用初始化操作，变量定义、资源加载，用于后续UI展示</p>\n<p><strong>onWindowStageCreate</strong>：UIAbility创建完成以后，进入Foreground之前，系统会创建一个WindowStage，WindowStage创建完成以后，回掉onWindowStageCreate，可以在这里进行UI页面加载、WindowStage订阅等操作，获取焦点、失去焦点、可见不可见等；通过loadContent加载指定的页面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onWindowStageCreate</span>(<span class=\"attr\">windowStage</span>: <span class=\"variable language_\">window</span>.<span class=\"property\">WindowStage</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  windowStage.<span class=\"title function_\">loadContent</span>(<span class=\"string\">&#x27;pages/Index&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err.<span class=\"property\">code</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>onForeground</strong>：应用切换至前台时回掉，申请系统需要资源</p>\n<p><strong>onBackground</strong>：应用切换至后台时回掉，释放无用资源，执行耗时操作，例如状态保存</p>\n<p><strong>onWindowStageDestroy</strong>：释放UI界面资源，注销WindowStage相关事件</p>\n<p><strong>onDestroy：</strong>在UIAbility销毁时触发，可以在onDestroy回调中进行系统资源的释放</p>\n<h3 id=\"四、UIAbility启动模式：\"><a href=\"#四、UIAbility启动模式：\" class=\"headerlink\" title=\"四、UIAbility启动模式：\"></a>四、UIAbility启动模式：</h3><p>UIAbility启动模式需要在module.json5文件中配置<strong>lunchType</strong>字段？</p>\n<ul>\n<li>singleton（单实例模式）</li>\n<li>standard（标准实例模式）</li>\n<li>specified（指定实例模式）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HarmonyOS开发—基础—应用程序入口-UIAbility\"><a href=\"#HarmonyOS开发—基础—应用程序入口-UIAbility\" class=\"headerlink\" title=\"HarmonyOS开发—基础—应用程序入口-UIAbility\"></a>HarmonyOS开发—基础—应用程序入口-UIAbility</h2><h3 id=\"一、什么是UIAbility\"><a href=\"#一、什么是UIAbility\" class=\"headerlink\" title=\"一、什么是UIAbility\"></a>一、什么是UIAbility</h3><p>UIAbility是一种包含用户界面的UI组件，主要用于和用户进行交互。一个应用，可以有一个UIAbility也可以有多个UIAbility，自鸿蒙API10以后，建议一个应用只有一个UIAbility，多个页面为<strong>多个组件</strong>。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/UIAbility/single.png\" alt=\"img\"></p>\n<h3 id=\"二、UIAbilit之间跳转\"><a href=\"#二、UIAbilit之间跳转\" class=\"headerlink\" title=\"二、UIAbilit之间跳转\"></a>二、UIAbilit之间跳转</h3><p> 多个UIAbility之间跳转，API9之前推荐使用Router</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.pushUrl(&#123;</span><br><span class=\"line\">  url: &#x27;pages/Second&#x27;,</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    src: &#x27;Index页面传来的数据&#x27;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, router.RouterMode.Single)</span><br></pre></td></tr></table></figure>\n\n<p>router.pushUrl支持两种模式跳转，分别为single和standard，设置为single时，每次会先看堆栈内是否有单个实例，没有的话，会创建一个，有的话，会推倒栈顶；设置为standard时，每次pushUrl会多一个实例</p>\n<p>返回页面可以使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回上一个页面</span><br><span class=\"line\">router.back();</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回指定页面</span><br><span class=\"line\">router.back(&#123; url: &#x27;pages/Index&#x27; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>API10 及之后，推荐使用Navigation进行页面之间跳转，因为此时建议一个应用内部只有一个UIAbility，所以，页面在这个UIAbility中，作为组建进行存在，此时页面跳转变成了UI组件跳转，因此推荐使用Navigation。</p>\n<p><strong>案例待补充</strong></p>\n<h3 id=\"三、UIAbility生命周期\"><a href=\"#三、UIAbility生命周期\" class=\"headerlink\" title=\"三、UIAbility生命周期\"></a>三、UIAbility生命周期</h3><p>UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，WindowStageCreate和WindowStageDestroy为窗口管理器（WindowStage）在UIAbility中管理UI界面功能的两个生命周期回调，从而实现UIAbility与窗口之间的弱耦合。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/UIAbility/lifecycle.png\" alt=\"img\"></p>\n<p><strong>Create:</strong> 应用初始化操作，变量定义、资源加载，用于后续UI展示</p>\n<p><strong>onWindowStageCreate</strong>：UIAbility创建完成以后，进入Foreground之前，系统会创建一个WindowStage，WindowStage创建完成以后，回掉onWindowStageCreate，可以在这里进行UI页面加载、WindowStage订阅等操作，获取焦点、失去焦点、可见不可见等；通过loadContent加载指定的页面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onWindowStageCreate</span>(<span class=\"attr\">windowStage</span>: <span class=\"variable language_\">window</span>.<span class=\"property\">WindowStage</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  windowStage.<span class=\"title function_\">loadContent</span>(<span class=\"string\">&#x27;pages/Index&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err.<span class=\"property\">code</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>onForeground</strong>：应用切换至前台时回掉，申请系统需要资源</p>\n<p><strong>onBackground</strong>：应用切换至后台时回掉，释放无用资源，执行耗时操作，例如状态保存</p>\n<p><strong>onWindowStageDestroy</strong>：释放UI界面资源，注销WindowStage相关事件</p>\n<p><strong>onDestroy：</strong>在UIAbility销毁时触发，可以在onDestroy回调中进行系统资源的释放</p>\n<h3 id=\"四、UIAbility启动模式：\"><a href=\"#四、UIAbility启动模式：\" class=\"headerlink\" title=\"四、UIAbility启动模式：\"></a>四、UIAbility启动模式：</h3><p>UIAbility启动模式需要在module.json5文件中配置<strong>lunchType</strong>字段？</p>\n<ul>\n<li>singleton（单实例模式）</li>\n<li>standard（标准实例模式）</li>\n<li>specified（指定实例模式）</li>\n</ul>\n"},{"title":"HarmonyOS开发—进阶—ArkUI进阶","date":"2024-02-17T06:12:26.000Z","keywords":"HarmonyOS,HarmonyOS开发,HarmonyOS入门,ArkUI进阶","description":"ArkUI进阶","top_img":"http://image.jucaiwy.com/image/Harmony/ArkUI/harmony-ui.jpg","cover":"http://image.jucaiwy.com/image/Harmony/ArkUI/harmony-ui.jpg","_content":"\n## HarmonyOS开发—进阶—ArkUI进阶\n\n依赖安装：ohpm install ../library\n\n### 一、什么是ArkUI\n\n方舟开发框架，对标iOS里边的 Swift UI， 对表Android里边的Jetpack Compose ，一种声明式的开发范式。\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkUI/ArkUI.png)\n\n\n\n### 二、声明式的开发范式优点\n\n语法语义上更为简洁，代码量更少，更新机制更简洁\n\n类自然语言的UI描述和组合\n\n开箱即用的多态组件，自定义组件\n\n@State（修饰符，数据变化，UI会跟随变化）\n\n@sharedState（跨设备状态管理）等状态管理注解\n\n\n\n### 三、长列表加载性能优化实践\n\n#### 3.1 ForEach\n\n对于有限的可以预测数量的列表，建议使用ForEach进行，例如List的Item可以使用ForEach进行包装，提高加载性能\n\n\n\n```typescript\nList() {\n  ForEach(this.floors, (item: BaseFloorData) => {\n    ListItem() {\n      buildFloor(item.mId, JSON.stringify(item.data))\n    }\n  })\n}\n```\n\n同样，ForEach是一个接口，可以用于List，也可以用于包装任意Item\n\n\n\n```typescript\nSwiper() {\n  ForEach(this.floorTemplate.imageList, (item: string) => {\n    Image(item)\n      .width(\"100%\")\n      .height(300)\n      .objectFit(ImageFit.Cover)\n  }, (item: string) => JSON.stringify(item))\n}\n```\n\n#### 3.2 LazyForeach\n\nLazyForeach对比Android系统的RecyclerView，具备以下特性：\n\n1. 对于不可预估数量的列表加载，比如推荐位、首页上拉加载更多这种场景，可以使用LazyForeach，该框架会根据滚动容器的可视区域进行按需加载，可视区域外会自动进行销毁或者回收，从而降低内存消耗\n2. 对于不可滚动的容器中，使用LazyForeach  系统会自动降级为Foreach\n3. 使用LazyForeach的数据源需要继承自IDatasource接口\n\n其中IDatasource 类似RecyclerView的Adapter，提供了以下四个接口，需要继承者实现：\n\n```typescript\ntotalCount(): number {\n  return this.imageDataList.length\n}\n\ngetData(index: number): string {\n  return this.imageDataList[index]\n}\n\nregisterDataChangeListener(listener: DataChangeListener): void {\n  listener.onDataReloaded()\n}\n\nunregisterDataChangeListener(listener: DataChangeListener): void {\n\n}\n```\n\n对比ForEach，加载时会全部将所有的View挂在到组件树上，而不是按需挂载，导致ForEach加载较慢\n\n而LazyForeach 为按需加载，只挂载可视区域范围内的组件，类似RecyclerView\n\n\n\n```typescript\nWaterFlow() {\n  LazyForEach(this.dataSource, (item: string) => {\n    FlowItem() {\n      Image(item).width(300).height(300)\n    }\n  }, (item: string) => JSON.stringify(item))\n}.width(\"100%\").height(\"100%\")\n```\n\n### 四、性能优化指标\n\n华为内部测量性能优化三个关键指标，我们也可以进行借鉴\n\n1. 完全显示所用时间（Time To Full Display，TTFD）：从应用生成到第一帧展示所用的时间\n2. 丢帧率（Janky Frames）：一个周期内的丢帧比率，HarmonyOS要求每一帧都在11.1ms内绘制完成，也就是要求90Hz的刷新率，如果11.1ms没有绘制完成，就会丢帧。单帧丢失用户无感知，连续丢帧会有感知\n3. 独占内存（Unique Set Size，USS）一个进程所占用的私有内存，即该进程独占的内存，反应一个进程的真实成本\n\n### 五、优化方案\n\n1. 使用LazyForeach替代ForEach，加载性能更高\n2. LazyForeach上设置缓存加载数，可以预加载，避免出现白块的问题，一般来讲cachedCount的数量设置为n/2，此时丢帧率最小。例如当前屏幕展示10个，则设置cachedCount的数量为5\n3. 组件复用：鸿蒙提供了组件敷用的能力，可复用组件，从树上的移除时，也就是划出屏幕时，会先进入回收缓存区，**此时会对数据进行回收，但是组件节点不会被回收**，后续创建新的节点时，会优先敷用缓存区中的节点，节约组件重新创建的时间，提高加载速度和响应速度\n\n```typescript\n@Component\n@Reusable  // 1. 通过@Reusable 设置组件可以复用\nstruct Index {\n  @State message: string = '楼层化SDK';\n  dataSource = OrderCenterJsonString.generateWaterFlowData()\n  ........\n  // 3. 数据更新和重新绑定\n  aboutToReuse(): void {\n  }\n  ........\n  WaterFlow() {\n    LazyForEach(this.dataSource, (item: string) => {\n      FlowItem() {\n        // 2. 设置组件复用ID .reuseId(\"order_detail_string_floor\")\n        Image(item).width(300).height(300).reuseId(\"order_detail_string_floor\")\n      }\n    }, (item: string) => JSON.stringify(item))\n  }\n  .width(\"100%\").height(\"100%\")\n}\n```\n\n4. 布局优化，通过层级优化，进而对布局进行优化\n","source":"_posts/20240217-HarmonyOS开发—进阶—ArkUI进阶.md","raw":"---\n\ntitle: HarmonyOS开发—进阶—ArkUI进阶\n\ndate: 2024-02-17 14:12:26\n\ntags: [HarmonyOS开发,自定义组件]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,ArkUI进阶\n\ndescription: ArkUI进阶\n\ntop_img: http://image.jucaiwy.com/image/Harmony/ArkUI/harmony-ui.jpg\n\ncover: http://image.jucaiwy.com/image/Harmony/ArkUI/harmony-ui.jpg\n\n---\n\n## HarmonyOS开发—进阶—ArkUI进阶\n\n依赖安装：ohpm install ../library\n\n### 一、什么是ArkUI\n\n方舟开发框架，对标iOS里边的 Swift UI， 对表Android里边的Jetpack Compose ，一种声明式的开发范式。\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkUI/ArkUI.png)\n\n\n\n### 二、声明式的开发范式优点\n\n语法语义上更为简洁，代码量更少，更新机制更简洁\n\n类自然语言的UI描述和组合\n\n开箱即用的多态组件，自定义组件\n\n@State（修饰符，数据变化，UI会跟随变化）\n\n@sharedState（跨设备状态管理）等状态管理注解\n\n\n\n### 三、长列表加载性能优化实践\n\n#### 3.1 ForEach\n\n对于有限的可以预测数量的列表，建议使用ForEach进行，例如List的Item可以使用ForEach进行包装，提高加载性能\n\n\n\n```typescript\nList() {\n  ForEach(this.floors, (item: BaseFloorData) => {\n    ListItem() {\n      buildFloor(item.mId, JSON.stringify(item.data))\n    }\n  })\n}\n```\n\n同样，ForEach是一个接口，可以用于List，也可以用于包装任意Item\n\n\n\n```typescript\nSwiper() {\n  ForEach(this.floorTemplate.imageList, (item: string) => {\n    Image(item)\n      .width(\"100%\")\n      .height(300)\n      .objectFit(ImageFit.Cover)\n  }, (item: string) => JSON.stringify(item))\n}\n```\n\n#### 3.2 LazyForeach\n\nLazyForeach对比Android系统的RecyclerView，具备以下特性：\n\n1. 对于不可预估数量的列表加载，比如推荐位、首页上拉加载更多这种场景，可以使用LazyForeach，该框架会根据滚动容器的可视区域进行按需加载，可视区域外会自动进行销毁或者回收，从而降低内存消耗\n2. 对于不可滚动的容器中，使用LazyForeach  系统会自动降级为Foreach\n3. 使用LazyForeach的数据源需要继承自IDatasource接口\n\n其中IDatasource 类似RecyclerView的Adapter，提供了以下四个接口，需要继承者实现：\n\n```typescript\ntotalCount(): number {\n  return this.imageDataList.length\n}\n\ngetData(index: number): string {\n  return this.imageDataList[index]\n}\n\nregisterDataChangeListener(listener: DataChangeListener): void {\n  listener.onDataReloaded()\n}\n\nunregisterDataChangeListener(listener: DataChangeListener): void {\n\n}\n```\n\n对比ForEach，加载时会全部将所有的View挂在到组件树上，而不是按需挂载，导致ForEach加载较慢\n\n而LazyForeach 为按需加载，只挂载可视区域范围内的组件，类似RecyclerView\n\n\n\n```typescript\nWaterFlow() {\n  LazyForEach(this.dataSource, (item: string) => {\n    FlowItem() {\n      Image(item).width(300).height(300)\n    }\n  }, (item: string) => JSON.stringify(item))\n}.width(\"100%\").height(\"100%\")\n```\n\n### 四、性能优化指标\n\n华为内部测量性能优化三个关键指标，我们也可以进行借鉴\n\n1. 完全显示所用时间（Time To Full Display，TTFD）：从应用生成到第一帧展示所用的时间\n2. 丢帧率（Janky Frames）：一个周期内的丢帧比率，HarmonyOS要求每一帧都在11.1ms内绘制完成，也就是要求90Hz的刷新率，如果11.1ms没有绘制完成，就会丢帧。单帧丢失用户无感知，连续丢帧会有感知\n3. 独占内存（Unique Set Size，USS）一个进程所占用的私有内存，即该进程独占的内存，反应一个进程的真实成本\n\n### 五、优化方案\n\n1. 使用LazyForeach替代ForEach，加载性能更高\n2. LazyForeach上设置缓存加载数，可以预加载，避免出现白块的问题，一般来讲cachedCount的数量设置为n/2，此时丢帧率最小。例如当前屏幕展示10个，则设置cachedCount的数量为5\n3. 组件复用：鸿蒙提供了组件敷用的能力，可复用组件，从树上的移除时，也就是划出屏幕时，会先进入回收缓存区，**此时会对数据进行回收，但是组件节点不会被回收**，后续创建新的节点时，会优先敷用缓存区中的节点，节约组件重新创建的时间，提高加载速度和响应速度\n\n```typescript\n@Component\n@Reusable  // 1. 通过@Reusable 设置组件可以复用\nstruct Index {\n  @State message: string = '楼层化SDK';\n  dataSource = OrderCenterJsonString.generateWaterFlowData()\n  ........\n  // 3. 数据更新和重新绑定\n  aboutToReuse(): void {\n  }\n  ........\n  WaterFlow() {\n    LazyForEach(this.dataSource, (item: string) => {\n      FlowItem() {\n        // 2. 设置组件复用ID .reuseId(\"order_detail_string_floor\")\n        Image(item).width(300).height(300).reuseId(\"order_detail_string_floor\")\n      }\n    }, (item: string) => JSON.stringify(item))\n  }\n  .width(\"100%\").height(\"100%\")\n}\n```\n\n4. 布局优化，通过层级优化，进而对布局进行优化\n","slug":"20240217-HarmonyOS开发—进阶—ArkUI进阶","published":1,"updated":"2024-07-10T10:24:33.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01m00080nv6cxks0lpe","content":"<h2 id=\"HarmonyOS开发—进阶—ArkUI进阶\"><a href=\"#HarmonyOS开发—进阶—ArkUI进阶\" class=\"headerlink\" title=\"HarmonyOS开发—进阶—ArkUI进阶\"></a>HarmonyOS开发—进阶—ArkUI进阶</h2><p>依赖安装：ohpm install ..&#x2F;library</p>\n<h3 id=\"一、什么是ArkUI\"><a href=\"#一、什么是ArkUI\" class=\"headerlink\" title=\"一、什么是ArkUI\"></a>一、什么是ArkUI</h3><p>方舟开发框架，对标iOS里边的 Swift UI， 对表Android里边的Jetpack Compose ，一种声明式的开发范式。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkUI/ArkUI.png\" alt=\"img\"></p>\n<h3 id=\"二、声明式的开发范式优点\"><a href=\"#二、声明式的开发范式优点\" class=\"headerlink\" title=\"二、声明式的开发范式优点\"></a>二、声明式的开发范式优点</h3><p>语法语义上更为简洁，代码量更少，更新机制更简洁</p>\n<p>类自然语言的UI描述和组合</p>\n<p>开箱即用的多态组件，自定义组件</p>\n<p>@State（修饰符，数据变化，UI会跟随变化）</p>\n<p>@sharedState（跨设备状态管理）等状态管理注解</p>\n<h3 id=\"三、长列表加载性能优化实践\"><a href=\"#三、长列表加载性能优化实践\" class=\"headerlink\" title=\"三、长列表加载性能优化实践\"></a>三、长列表加载性能优化实践</h3><h4 id=\"3-1-ForEach\"><a href=\"#3-1-ForEach\" class=\"headerlink\" title=\"3.1 ForEach\"></a>3.1 ForEach</h4><p>对于有限的可以预测数量的列表，建议使用ForEach进行，例如List的Item可以使用ForEach进行包装，提高加载性能</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">List</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">floors</span>, <span class=\"function\">(<span class=\"params\">item: BaseFloorData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ListItem</span>() &#123;</span><br><span class=\"line\">      <span class=\"title function_\">buildFloor</span>(item.<span class=\"property\">mId</span>, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item.<span class=\"property\">data</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，ForEach是一个接口，可以用于List，也可以用于包装任意Item</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Swiper</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">floorTemplate</span>.<span class=\"property\">imageList</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Image</span>(item)</span><br><span class=\"line\">      .<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">objectFit</span>(<span class=\"title class_\">ImageFit</span>.<span class=\"property\">Cover</span>)</span><br><span class=\"line\">  &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-LazyForeach\"><a href=\"#3-2-LazyForeach\" class=\"headerlink\" title=\"3.2 LazyForeach\"></a>3.2 LazyForeach</h4><p>LazyForeach对比Android系统的RecyclerView，具备以下特性：</p>\n<ol>\n<li>对于不可预估数量的列表加载，比如推荐位、首页上拉加载更多这种场景，可以使用LazyForeach，该框架会根据滚动容器的可视区域进行按需加载，可视区域外会自动进行销毁或者回收，从而降低内存消耗</li>\n<li>对于不可滚动的容器中，使用LazyForeach  系统会自动降级为Foreach</li>\n<li>使用LazyForeach的数据源需要继承自IDatasource接口</li>\n</ol>\n<p>其中IDatasource 类似RecyclerView的Adapter，提供了以下四个接口，需要继承者实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">totalCount</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">imageDataList</span>.<span class=\"property\">length</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getData</span>(<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">imageDataList</span>[index]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerDataChangeListener</span>(<span class=\"attr\">listener</span>: <span class=\"title class_\">DataChangeListener</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  listener.<span class=\"title function_\">onDataReloaded</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">unregisterDataChangeListener</span>(<span class=\"attr\">listener</span>: <span class=\"title class_\">DataChangeListener</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比ForEach，加载时会全部将所有的View挂在到组件树上，而不是按需挂载，导致ForEach加载较慢</p>\n<p>而LazyForeach 为按需加载，只挂载可视区域范围内的组件，类似RecyclerView</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">WaterFlow</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">LazyForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">dataSource</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">FlowItem</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Image</span>(item).<span class=\"title function_\">width</span>(<span class=\"number\">300</span>).<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">&#125;.<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>).<span class=\"title function_\">height</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、性能优化指标\"><a href=\"#四、性能优化指标\" class=\"headerlink\" title=\"四、性能优化指标\"></a>四、性能优化指标</h3><p>华为内部测量性能优化三个关键指标，我们也可以进行借鉴</p>\n<ol>\n<li>完全显示所用时间（Time To Full Display，TTFD）：从应用生成到第一帧展示所用的时间</li>\n<li>丢帧率（Janky Frames）：一个周期内的丢帧比率，HarmonyOS要求每一帧都在11.1ms内绘制完成，也就是要求90Hz的刷新率，如果11.1ms没有绘制完成，就会丢帧。单帧丢失用户无感知，连续丢帧会有感知</li>\n<li>独占内存（Unique Set Size，USS）一个进程所占用的私有内存，即该进程独占的内存，反应一个进程的真实成本</li>\n</ol>\n<h3 id=\"五、优化方案\"><a href=\"#五、优化方案\" class=\"headerlink\" title=\"五、优化方案\"></a>五、优化方案</h3><ol>\n<li>使用LazyForeach替代ForEach，加载性能更高</li>\n<li>LazyForeach上设置缓存加载数，可以预加载，避免出现白块的问题，一般来讲cachedCount的数量设置为n&#x2F;2，此时丢帧率最小。例如当前屏幕展示10个，则设置cachedCount的数量为5</li>\n<li>组件复用：鸿蒙提供了组件敷用的能力，可复用组件，从树上的移除时，也就是划出屏幕时，会先进入回收缓存区，<strong>此时会对数据进行回收，但是组件节点不会被回收</strong>，后续创建新的节点时，会优先敷用缓存区中的节点，节约组件重新创建的时间，提高加载速度和响应速度</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Reusable</span>  <span class=\"comment\">// 1. 通过@Reusable 设置组件可以复用</span></span><br><span class=\"line\">struct <span class=\"title class_\">Index</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;楼层化SDK&#x27;</span>;</span><br><span class=\"line\">  dataSource = <span class=\"title class_\">OrderCenterJsonString</span>.<span class=\"title function_\">generateWaterFlowData</span>()</span><br><span class=\"line\">  ........</span><br><span class=\"line\">  <span class=\"comment\">// 3. 数据更新和重新绑定</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToReuse</span>(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ........</span><br><span class=\"line\">  <span class=\"title class_\">WaterFlow</span>() &#123;</span><br><span class=\"line\">    <span class=\"title class_\">LazyForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">dataSource</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">FlowItem</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 设置组件复用ID .reuseId(&quot;order_detail_string_floor&quot;)</span></span><br><span class=\"line\">        <span class=\"title class_\">Image</span>(item).<span class=\"title function_\">width</span>(<span class=\"number\">300</span>).<span class=\"title function_\">height</span>(<span class=\"number\">300</span>).<span class=\"title function_\">reuseId</span>(<span class=\"string\">&quot;order_detail_string_floor&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>).<span class=\"title function_\">height</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>布局优化，通过层级优化，进而对布局进行优化</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HarmonyOS开发—进阶—ArkUI进阶\"><a href=\"#HarmonyOS开发—进阶—ArkUI进阶\" class=\"headerlink\" title=\"HarmonyOS开发—进阶—ArkUI进阶\"></a>HarmonyOS开发—进阶—ArkUI进阶</h2><p>依赖安装：ohpm install ..&#x2F;library</p>\n<h3 id=\"一、什么是ArkUI\"><a href=\"#一、什么是ArkUI\" class=\"headerlink\" title=\"一、什么是ArkUI\"></a>一、什么是ArkUI</h3><p>方舟开发框架，对标iOS里边的 Swift UI， 对表Android里边的Jetpack Compose ，一种声明式的开发范式。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkUI/ArkUI.png\" alt=\"img\"></p>\n<h3 id=\"二、声明式的开发范式优点\"><a href=\"#二、声明式的开发范式优点\" class=\"headerlink\" title=\"二、声明式的开发范式优点\"></a>二、声明式的开发范式优点</h3><p>语法语义上更为简洁，代码量更少，更新机制更简洁</p>\n<p>类自然语言的UI描述和组合</p>\n<p>开箱即用的多态组件，自定义组件</p>\n<p>@State（修饰符，数据变化，UI会跟随变化）</p>\n<p>@sharedState（跨设备状态管理）等状态管理注解</p>\n<h3 id=\"三、长列表加载性能优化实践\"><a href=\"#三、长列表加载性能优化实践\" class=\"headerlink\" title=\"三、长列表加载性能优化实践\"></a>三、长列表加载性能优化实践</h3><h4 id=\"3-1-ForEach\"><a href=\"#3-1-ForEach\" class=\"headerlink\" title=\"3.1 ForEach\"></a>3.1 ForEach</h4><p>对于有限的可以预测数量的列表，建议使用ForEach进行，例如List的Item可以使用ForEach进行包装，提高加载性能</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">List</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">floors</span>, <span class=\"function\">(<span class=\"params\">item: BaseFloorData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ListItem</span>() &#123;</span><br><span class=\"line\">      <span class=\"title function_\">buildFloor</span>(item.<span class=\"property\">mId</span>, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item.<span class=\"property\">data</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，ForEach是一个接口，可以用于List，也可以用于包装任意Item</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Swiper</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">floorTemplate</span>.<span class=\"property\">imageList</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Image</span>(item)</span><br><span class=\"line\">      .<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">objectFit</span>(<span class=\"title class_\">ImageFit</span>.<span class=\"property\">Cover</span>)</span><br><span class=\"line\">  &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-LazyForeach\"><a href=\"#3-2-LazyForeach\" class=\"headerlink\" title=\"3.2 LazyForeach\"></a>3.2 LazyForeach</h4><p>LazyForeach对比Android系统的RecyclerView，具备以下特性：</p>\n<ol>\n<li>对于不可预估数量的列表加载，比如推荐位、首页上拉加载更多这种场景，可以使用LazyForeach，该框架会根据滚动容器的可视区域进行按需加载，可视区域外会自动进行销毁或者回收，从而降低内存消耗</li>\n<li>对于不可滚动的容器中，使用LazyForeach  系统会自动降级为Foreach</li>\n<li>使用LazyForeach的数据源需要继承自IDatasource接口</li>\n</ol>\n<p>其中IDatasource 类似RecyclerView的Adapter，提供了以下四个接口，需要继承者实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">totalCount</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">imageDataList</span>.<span class=\"property\">length</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getData</span>(<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">imageDataList</span>[index]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerDataChangeListener</span>(<span class=\"attr\">listener</span>: <span class=\"title class_\">DataChangeListener</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  listener.<span class=\"title function_\">onDataReloaded</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">unregisterDataChangeListener</span>(<span class=\"attr\">listener</span>: <span class=\"title class_\">DataChangeListener</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比ForEach，加载时会全部将所有的View挂在到组件树上，而不是按需挂载，导致ForEach加载较慢</p>\n<p>而LazyForeach 为按需加载，只挂载可视区域范围内的组件，类似RecyclerView</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">WaterFlow</span>() &#123;</span><br><span class=\"line\">  <span class=\"title class_\">LazyForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">dataSource</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">FlowItem</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Image</span>(item).<span class=\"title function_\">width</span>(<span class=\"number\">300</span>).<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">&#125;.<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>).<span class=\"title function_\">height</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、性能优化指标\"><a href=\"#四、性能优化指标\" class=\"headerlink\" title=\"四、性能优化指标\"></a>四、性能优化指标</h3><p>华为内部测量性能优化三个关键指标，我们也可以进行借鉴</p>\n<ol>\n<li>完全显示所用时间（Time To Full Display，TTFD）：从应用生成到第一帧展示所用的时间</li>\n<li>丢帧率（Janky Frames）：一个周期内的丢帧比率，HarmonyOS要求每一帧都在11.1ms内绘制完成，也就是要求90Hz的刷新率，如果11.1ms没有绘制完成，就会丢帧。单帧丢失用户无感知，连续丢帧会有感知</li>\n<li>独占内存（Unique Set Size，USS）一个进程所占用的私有内存，即该进程独占的内存，反应一个进程的真实成本</li>\n</ol>\n<h3 id=\"五、优化方案\"><a href=\"#五、优化方案\" class=\"headerlink\" title=\"五、优化方案\"></a>五、优化方案</h3><ol>\n<li>使用LazyForeach替代ForEach，加载性能更高</li>\n<li>LazyForeach上设置缓存加载数，可以预加载，避免出现白块的问题，一般来讲cachedCount的数量设置为n&#x2F;2，此时丢帧率最小。例如当前屏幕展示10个，则设置cachedCount的数量为5</li>\n<li>组件复用：鸿蒙提供了组件敷用的能力，可复用组件，从树上的移除时，也就是划出屏幕时，会先进入回收缓存区，<strong>此时会对数据进行回收，但是组件节点不会被回收</strong>，后续创建新的节点时，会优先敷用缓存区中的节点，节约组件重新创建的时间，提高加载速度和响应速度</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Reusable</span>  <span class=\"comment\">// 1. 通过@Reusable 设置组件可以复用</span></span><br><span class=\"line\">struct <span class=\"title class_\">Index</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;楼层化SDK&#x27;</span>;</span><br><span class=\"line\">  dataSource = <span class=\"title class_\">OrderCenterJsonString</span>.<span class=\"title function_\">generateWaterFlowData</span>()</span><br><span class=\"line\">  ........</span><br><span class=\"line\">  <span class=\"comment\">// 3. 数据更新和重新绑定</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToReuse</span>(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ........</span><br><span class=\"line\">  <span class=\"title class_\">WaterFlow</span>() &#123;</span><br><span class=\"line\">    <span class=\"title class_\">LazyForEach</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">dataSource</span>, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">FlowItem</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 设置组件复用ID .reuseId(&quot;order_detail_string_floor&quot;)</span></span><br><span class=\"line\">        <span class=\"title class_\">Image</span>(item).<span class=\"title function_\">width</span>(<span class=\"number\">300</span>).<span class=\"title function_\">height</span>(<span class=\"number\">300</span>).<span class=\"title function_\">reuseId</span>(<span class=\"string\">&quot;order_detail_string_floor&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"function\">(<span class=\"params\">item: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(item))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .<span class=\"title function_\">width</span>(<span class=\"string\">&quot;100%&quot;</span>).<span class=\"title function_\">height</span>(<span class=\"string\">&quot;100%&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>布局优化，通过层级优化，进而对布局进行优化</li>\n</ol>\n"},{"title":"HarmonyOS开发—基础—ArkTS语言介绍","date":"2023-12-23T08:52:46.000Z","keywords":"HarmonyOS,HarmonyOS开发,HarmonyOS入门,ArkTS语言介绍","description":"ArkTS语言介绍","top_img":"http://image.jucaiwy.com/image/20240710/ArkTS.png","cover":"http://image.jucaiwy.com/image/20240710/ArkTS.png","_content":"\n## HarmonyOS开发—基础—ArkTS语言介绍\n\n\n\nHarmonyOS使用ArkTS语言开发，ArkTS语言是TypeScript的基础上的拓展，而TypeScript是JavaScript的超集。\n\n### 一、JavaScript\n\nJavaScript（通常缩写为JS）是用来和HTML和CSS结合创建交互式网页，是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程序设计、指令式编程和函数式编程。它提供了操作文本、数组、日期以及正则表达式等能力。JavaScript虽然不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化（ES6）。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari和Opera）所支持。\n\n\n\n对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT， Just-in-Time）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。\n\n### 二、TypeScript\n\nTypeScript是由微软进行开发和维护的一种开源的编程语言。提到TypeScript，第一个解释均为：TypeScript是JavaScript的超集。是的，随着JavaScript项目的复杂性呈指数级地增长，JavaScript用于编辑大规模应用程序时，在服务端会变得混乱和复杂，难以维护，此时TypeScript应运而生。TypeScript更强调显式类型，使研发人员能掌握各种组件的交互方式，并且TypeScript支持编译时调试，对于处理大型复杂应用程序的团队而言，这无疑是一个优点。\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/ArkTs.png)\n\n\n\n#### 2.1 TypeScript基础语法-基础类型\n\n**boolean**：TypeScript中使用boolean来标志布尔类型，可以为true和false\n\n**number**：TypeScript中所有的数字均为浮点型，这些浮点型的类型为number，除了支持十进制、二进制、八进制还支持了十六进制。\n\n**string**：字符串，使用string标志为文本类型。TypeScript中可以使用单引号或者双引号标记字符串\n\n**数组**：第一种，在元素后边加上方括号，表示为数组：let list1: number[] = [1,2,3]  另外一种，范型let list2: Array<number> = [1,2,3] \n\n**元组**：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。let x :[string,number]\n\n**枚举**：enum类型是对JavaScript基础类型的一个补充，使用枚举可以给一组数据类型友好的赋予一个名字。\n\n**unknow**：有时候我们编程的时候，不清楚数据可能出现的类型，可以用unknow进行定义。unknow可以是string、boolean、number\n\n**void**:当一个函数没有返回值时，这个类型为void\n\n**undefined 和null** ：在TypeScript中，undefined和null是两种不同的基础类型，需要注意\n\n**联合类型**：取值可以为多种类型中的一种  let state:string|number 这时  state可以被赋值为string或者number。\n\n\n\n#### 2.2 TypeScript基础语法-条件\n\nTypeScript支持按照不同的条件执行不同的逻辑代码，和Java类似，也支持if else \n\n```typescript\n/**\n * IfElse示例代码\n */\nstatic testIfElse() {\n  let num: number = 5;\n  if (num > 0) {\n    console.log(num + \"大于0\");\n  } else if (num = 0) {\n    console.log(num + \"等于0\");\n  } else {\n    console.log(num + \"小于0\");\n  }\n}\n```\n\n同样也支持Switch语法\n\n```typescript\n/**\n * Switch示例代码\n */\nstatic testSwitch() {\n  let num: number = 5;\n  switch (num) {\n    case 1: {\n      console.log(\"当前数字是：1\")\n    }\n      break;\n    case 1: {\n      console.log(\"当前数字是：2\")\n    }\n      break;\n    default:\n      break;\n  }\n}\n```\n\n#### 2.3 TypeScript基础语法-函数\n\n```typescript\n/**\n * 有名函数\n * @param x\n * @param y\n * @returns\n */\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\n/**\n * 匿名函数，没有函数名\n * @param x\n * @param y\n * @returns\n */\nlet addResult = function (x: number, y: number): number {\n  return x + y\n}\n```\n\n#### 2.4 TypeScript基础语法-可选参数\n\nTypeScript中，函数构造参数可以使用？标记当前参数为可选参数：\n\n```typescript\n/**\n * 入参带着age，表明是可选参数\n * @param name\n * @param age\n * @returns \n */\nfunction appendStr(name: string, age?: string): string {\n  if (age) {\n    return name + age;\n  } else {\n    return name\n  }\n}\n\n// 这两种调用都可以\nappendStr(\"duanbokan\")\nappendStr(\"duanbokan\",\"18\")\n```\n\n#### 2.5 TypeScript基础语法-箭头函数\n\nES6版本的TypeScript提供了箭头函数，省略了function关键字，其函数是一个语句块：\n\n```typescript\n/**\n * 箭头函数\n * @param name\n * @param age\n */\n(name: string, age: string) => {\n\n}\n\n/**\n * 箭头函数赋值\n * @param name\n * @param age\n */\nlet appendResult = (name: string, age: string) => {\n  return name + age\n}\n```\n\n#### 2.6 TypeScript基础语法-类\n\nclass 开头，直接跟着类名，类可以是public、private、通过这个关键字，控制类的访问权限\n\n\n\n#### 2.7 TypeScript基础语法-继承\n\nclass 支持继承，对应关键字是extends\n\n\n\n#### 2.8 TypeScript基础语法-模块\n\n1. 应用越来越大的时候，可以通过使用模块（module）进行拆分，module可以相互加载、可以通过export和import来交换功能，即调用从另外一个模块的函数。\n2. 两个模块是通过文件上的引用进行import和export的。\n3. 正常模块中的变量、函数、类都不可以被别的模块访问，除非添加export\n4. import以后，可以访问其变量、函数、类\n\n\n\n#### 2.9 TypeScript基础语法-迭代器\n\n迭代器用来循环和遍历数组for of 语句和for in语句 \n\nfor in语句：遍历数组的下标\n\nfor of语句： 遍历数组的元素\n\n \n\n### 三、ArkTS\n\nArkTS是HarmonyOS及整个鸿蒙生态优选的主力应用开发语言，它是在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了**声明式UI**、**状态管理**等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用，可以这么说，ArkTSTypeScript的超集。\n\n当前，ArkTS在TS的基础上主要扩展了如下能力：\n\n- [基本语法](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-basic-syntax-overview-0000001531611153-V3)：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。\n- [状态管理](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-management-overview-0000001524537145-V3)：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。\n- [渲染控制](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-rendering-control-overview-0000001543911149-V3)：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。\n\n未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。\n\n#### 3.1 装饰器：\n\n装饰类、结构、方法、变量，赋予其特殊的含义\n\n@Component 表示自定义组件装饰器，需要添加export关键字，进行导出\n\n@Entry  修饰的自定义组件作为页面的入口，加载页面时，首先家在@Entry修饰的自定义组件页面\n\n@Component struct 自定义结构体\n\n@State  状态管理装饰器\n\n@Link 可以和父组件中@State修饰的变量建立双向绑定，任何一方数据修改都会反馈另外一方，需要使用$进行引用\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/Compont.png)\n\n\n\n#### 3.2  @Component自定义组件的生命周期：\n\naboutToAppear：自定义组件被加载时调用，一般在这里进行数据处理和赋值\n\naboutToDisAppear:  自定义组件销毁时调用，一般在这里进行数据回收，避免资源泄漏\n\n\n\n#### 3.3  @Entry修饰的页面入口组件生命周期\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/Entry.png)\n\n\n\n#### 3.3  条件渲染\n\n#### 3.4  ForEach\n\n第一个参数为数据源、\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/ForEach.png)\n\n\n\n#### 3.5  声明式UI特征\n\n1. 声名式描述\n2. 状态驱动视图更新\n\n","source":"_posts/20231222-HarmonyOS开发—基础—ArkTS语言介绍.md","raw":"---\n\ntitle: HarmonyOS开发—基础—ArkTS语言介绍\n\ndate: 2023-12-23 16:52:46\n\ntags: [HarmonyOS开发,ArkTS语言介绍]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,ArkTS语言介绍\n\ndescription: ArkTS语言介绍\n\ntop_img: http://image.jucaiwy.com/image/20240710/ArkTS.png\n\ncover: http://image.jucaiwy.com/image/20240710/ArkTS.png\n\n---\n\n## HarmonyOS开发—基础—ArkTS语言介绍\n\n\n\nHarmonyOS使用ArkTS语言开发，ArkTS语言是TypeScript的基础上的拓展，而TypeScript是JavaScript的超集。\n\n### 一、JavaScript\n\nJavaScript（通常缩写为JS）是用来和HTML和CSS结合创建交互式网页，是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程序设计、指令式编程和函数式编程。它提供了操作文本、数组、日期以及正则表达式等能力。JavaScript虽然不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化（ES6）。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari和Opera）所支持。\n\n\n\n对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT， Just-in-Time）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。\n\n### 二、TypeScript\n\nTypeScript是由微软进行开发和维护的一种开源的编程语言。提到TypeScript，第一个解释均为：TypeScript是JavaScript的超集。是的，随着JavaScript项目的复杂性呈指数级地增长，JavaScript用于编辑大规模应用程序时，在服务端会变得混乱和复杂，难以维护，此时TypeScript应运而生。TypeScript更强调显式类型，使研发人员能掌握各种组件的交互方式，并且TypeScript支持编译时调试，对于处理大型复杂应用程序的团队而言，这无疑是一个优点。\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/ArkTs.png)\n\n\n\n#### 2.1 TypeScript基础语法-基础类型\n\n**boolean**：TypeScript中使用boolean来标志布尔类型，可以为true和false\n\n**number**：TypeScript中所有的数字均为浮点型，这些浮点型的类型为number，除了支持十进制、二进制、八进制还支持了十六进制。\n\n**string**：字符串，使用string标志为文本类型。TypeScript中可以使用单引号或者双引号标记字符串\n\n**数组**：第一种，在元素后边加上方括号，表示为数组：let list1: number[] = [1,2,3]  另外一种，范型let list2: Array<number> = [1,2,3] \n\n**元组**：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。let x :[string,number]\n\n**枚举**：enum类型是对JavaScript基础类型的一个补充，使用枚举可以给一组数据类型友好的赋予一个名字。\n\n**unknow**：有时候我们编程的时候，不清楚数据可能出现的类型，可以用unknow进行定义。unknow可以是string、boolean、number\n\n**void**:当一个函数没有返回值时，这个类型为void\n\n**undefined 和null** ：在TypeScript中，undefined和null是两种不同的基础类型，需要注意\n\n**联合类型**：取值可以为多种类型中的一种  let state:string|number 这时  state可以被赋值为string或者number。\n\n\n\n#### 2.2 TypeScript基础语法-条件\n\nTypeScript支持按照不同的条件执行不同的逻辑代码，和Java类似，也支持if else \n\n```typescript\n/**\n * IfElse示例代码\n */\nstatic testIfElse() {\n  let num: number = 5;\n  if (num > 0) {\n    console.log(num + \"大于0\");\n  } else if (num = 0) {\n    console.log(num + \"等于0\");\n  } else {\n    console.log(num + \"小于0\");\n  }\n}\n```\n\n同样也支持Switch语法\n\n```typescript\n/**\n * Switch示例代码\n */\nstatic testSwitch() {\n  let num: number = 5;\n  switch (num) {\n    case 1: {\n      console.log(\"当前数字是：1\")\n    }\n      break;\n    case 1: {\n      console.log(\"当前数字是：2\")\n    }\n      break;\n    default:\n      break;\n  }\n}\n```\n\n#### 2.3 TypeScript基础语法-函数\n\n```typescript\n/**\n * 有名函数\n * @param x\n * @param y\n * @returns\n */\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\n/**\n * 匿名函数，没有函数名\n * @param x\n * @param y\n * @returns\n */\nlet addResult = function (x: number, y: number): number {\n  return x + y\n}\n```\n\n#### 2.4 TypeScript基础语法-可选参数\n\nTypeScript中，函数构造参数可以使用？标记当前参数为可选参数：\n\n```typescript\n/**\n * 入参带着age，表明是可选参数\n * @param name\n * @param age\n * @returns \n */\nfunction appendStr(name: string, age?: string): string {\n  if (age) {\n    return name + age;\n  } else {\n    return name\n  }\n}\n\n// 这两种调用都可以\nappendStr(\"duanbokan\")\nappendStr(\"duanbokan\",\"18\")\n```\n\n#### 2.5 TypeScript基础语法-箭头函数\n\nES6版本的TypeScript提供了箭头函数，省略了function关键字，其函数是一个语句块：\n\n```typescript\n/**\n * 箭头函数\n * @param name\n * @param age\n */\n(name: string, age: string) => {\n\n}\n\n/**\n * 箭头函数赋值\n * @param name\n * @param age\n */\nlet appendResult = (name: string, age: string) => {\n  return name + age\n}\n```\n\n#### 2.6 TypeScript基础语法-类\n\nclass 开头，直接跟着类名，类可以是public、private、通过这个关键字，控制类的访问权限\n\n\n\n#### 2.7 TypeScript基础语法-继承\n\nclass 支持继承，对应关键字是extends\n\n\n\n#### 2.8 TypeScript基础语法-模块\n\n1. 应用越来越大的时候，可以通过使用模块（module）进行拆分，module可以相互加载、可以通过export和import来交换功能，即调用从另外一个模块的函数。\n2. 两个模块是通过文件上的引用进行import和export的。\n3. 正常模块中的变量、函数、类都不可以被别的模块访问，除非添加export\n4. import以后，可以访问其变量、函数、类\n\n\n\n#### 2.9 TypeScript基础语法-迭代器\n\n迭代器用来循环和遍历数组for of 语句和for in语句 \n\nfor in语句：遍历数组的下标\n\nfor of语句： 遍历数组的元素\n\n \n\n### 三、ArkTS\n\nArkTS是HarmonyOS及整个鸿蒙生态优选的主力应用开发语言，它是在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了**声明式UI**、**状态管理**等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用，可以这么说，ArkTSTypeScript的超集。\n\n当前，ArkTS在TS的基础上主要扩展了如下能力：\n\n- [基本语法](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-basic-syntax-overview-0000001531611153-V3)：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。\n- [状态管理](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-management-overview-0000001524537145-V3)：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。\n- [渲染控制](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-rendering-control-overview-0000001543911149-V3)：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。\n\n未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。\n\n#### 3.1 装饰器：\n\n装饰类、结构、方法、变量，赋予其特殊的含义\n\n@Component 表示自定义组件装饰器，需要添加export关键字，进行导出\n\n@Entry  修饰的自定义组件作为页面的入口，加载页面时，首先家在@Entry修饰的自定义组件页面\n\n@Component struct 自定义结构体\n\n@State  状态管理装饰器\n\n@Link 可以和父组件中@State修饰的变量建立双向绑定，任何一方数据修改都会反馈另外一方，需要使用$进行引用\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/Compont.png)\n\n\n\n#### 3.2  @Component自定义组件的生命周期：\n\naboutToAppear：自定义组件被加载时调用，一般在这里进行数据处理和赋值\n\naboutToDisAppear:  自定义组件销毁时调用，一般在这里进行数据回收，避免资源泄漏\n\n\n\n#### 3.3  @Entry修饰的页面入口组件生命周期\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/Entry.png)\n\n\n\n#### 3.3  条件渲染\n\n#### 3.4  ForEach\n\n第一个参数为数据源、\n\n![img](http://image.jucaiwy.com/image/Harmony/ArkTs/ForEach.png)\n\n\n\n#### 3.5  声明式UI特征\n\n1. 声名式描述\n2. 状态驱动视图更新\n\n","slug":"20231222-HarmonyOS开发—基础—ArkTS语言介绍","published":1,"updated":"2024-07-10T10:23:14.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01n000c0nv61o103566","content":"<h2 id=\"HarmonyOS开发—基础—ArkTS语言介绍\"><a href=\"#HarmonyOS开发—基础—ArkTS语言介绍\" class=\"headerlink\" title=\"HarmonyOS开发—基础—ArkTS语言介绍\"></a>HarmonyOS开发—基础—ArkTS语言介绍</h2><p>HarmonyOS使用ArkTS语言开发，ArkTS语言是TypeScript的基础上的拓展，而TypeScript是JavaScript的超集。</p>\n<h3 id=\"一、JavaScript\"><a href=\"#一、JavaScript\" class=\"headerlink\" title=\"一、JavaScript\"></a>一、JavaScript</h3><p>JavaScript（通常缩写为JS）是用来和HTML和CSS结合创建交互式网页，是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程序设计、指令式编程和函数式编程。它提供了操作文本、数组、日期以及正则表达式等能力。JavaScript虽然不支持I&#x2F;O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化（ES6）。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari和Opera）所支持。</p>\n<p>对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT， Just-in-Time）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。</p>\n<h3 id=\"二、TypeScript\"><a href=\"#二、TypeScript\" class=\"headerlink\" title=\"二、TypeScript\"></a>二、TypeScript</h3><p>TypeScript是由微软进行开发和维护的一种开源的编程语言。提到TypeScript，第一个解释均为：TypeScript是JavaScript的超集。是的，随着JavaScript项目的复杂性呈指数级地增长，JavaScript用于编辑大规模应用程序时，在服务端会变得混乱和复杂，难以维护，此时TypeScript应运而生。TypeScript更强调显式类型，使研发人员能掌握各种组件的交互方式，并且TypeScript支持编译时调试，对于处理大型复杂应用程序的团队而言，这无疑是一个优点。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/ArkTs.png\" alt=\"img\"></p>\n<h4 id=\"2-1-TypeScript基础语法-基础类型\"><a href=\"#2-1-TypeScript基础语法-基础类型\" class=\"headerlink\" title=\"2.1 TypeScript基础语法-基础类型\"></a>2.1 TypeScript基础语法-基础类型</h4><p><strong>boolean</strong>：TypeScript中使用boolean来标志布尔类型，可以为true和false</p>\n<p><strong>number</strong>：TypeScript中所有的数字均为浮点型，这些浮点型的类型为number，除了支持十进制、二进制、八进制还支持了十六进制。</p>\n<p><strong>string</strong>：字符串，使用string标志为文本类型。TypeScript中可以使用单引号或者双引号标记字符串</p>\n<p><strong>数组</strong>：第一种，在元素后边加上方括号，表示为数组：let list1: number[] &#x3D; [1,2,3]  另外一种，范型let list2: Array<number> &#x3D; [1,2,3] </p>\n<p><strong>元组</strong>：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。let x :[string,number]</p>\n<p><strong>枚举</strong>：enum类型是对JavaScript基础类型的一个补充，使用枚举可以给一组数据类型友好的赋予一个名字。</p>\n<p><strong>unknow</strong>：有时候我们编程的时候，不清楚数据可能出现的类型，可以用unknow进行定义。unknow可以是string、boolean、number</p>\n<p><strong>void</strong>:当一个函数没有返回值时，这个类型为void</p>\n<p><strong>undefined 和null</strong> ：在TypeScript中，undefined和null是两种不同的基础类型，需要注意</p>\n<p><strong>联合类型</strong>：取值可以为多种类型中的一种  let state:string|number 这时  state可以被赋值为string或者number。</p>\n<h4 id=\"2-2-TypeScript基础语法-条件\"><a href=\"#2-2-TypeScript基础语法-条件\" class=\"headerlink\" title=\"2.2 TypeScript基础语法-条件\"></a>2.2 TypeScript基础语法-条件</h4><p>TypeScript支持按照不同的条件执行不同的逻辑代码，和Java类似，也支持if else </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * IfElse示例代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"title function_\">testIfElse</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;大于0&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;等于0&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;小于0&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样也支持Switch语法</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Switch示例代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"title function_\">testSwitch</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;当前数字是：1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;当前数字是：2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-TypeScript基础语法-函数\"><a href=\"#2-3-TypeScript基础语法-函数\" class=\"headerlink\" title=\"2.3 TypeScript基础语法-函数\"></a>2.3 TypeScript基础语法-函数</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 有名函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 匿名函数，没有函数名</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> addResult = <span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-TypeScript基础语法-可选参数\"><a href=\"#2-4-TypeScript基础语法-可选参数\" class=\"headerlink\" title=\"2.4 TypeScript基础语法-可选参数\"></a>2.4 TypeScript基础语法-可选参数</h4><p>TypeScript中，函数构造参数可以使用？标记当前参数为可选参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 入参带着age，表明是可选参数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">appendStr</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, age?: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name + age;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两种调用都可以</span></span><br><span class=\"line\"><span class=\"title function_\">appendStr</span>(<span class=\"string\">&quot;duanbokan&quot;</span>)</span><br><span class=\"line\"><span class=\"title function_\">appendStr</span>(<span class=\"string\">&quot;duanbokan&quot;</span>,<span class=\"string\">&quot;18&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-TypeScript基础语法-箭头函数\"><a href=\"#2-5-TypeScript基础语法-箭头函数\" class=\"headerlink\" title=\"2.5 TypeScript基础语法-箭头函数\"></a>2.5 TypeScript基础语法-箭头函数</h4><p>ES6版本的TypeScript提供了箭头函数，省略了function关键字，其函数是一个语句块：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 箭头函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">(<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">string</span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 箭头函数赋值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">appendResult</span> = (<span class=\"params\">name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name + age</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-TypeScript基础语法-类\"><a href=\"#2-6-TypeScript基础语法-类\" class=\"headerlink\" title=\"2.6 TypeScript基础语法-类\"></a>2.6 TypeScript基础语法-类</h4><p>class 开头，直接跟着类名，类可以是public、private、通过这个关键字，控制类的访问权限</p>\n<h4 id=\"2-7-TypeScript基础语法-继承\"><a href=\"#2-7-TypeScript基础语法-继承\" class=\"headerlink\" title=\"2.7 TypeScript基础语法-继承\"></a>2.7 TypeScript基础语法-继承</h4><p>class 支持继承，对应关键字是extends</p>\n<h4 id=\"2-8-TypeScript基础语法-模块\"><a href=\"#2-8-TypeScript基础语法-模块\" class=\"headerlink\" title=\"2.8 TypeScript基础语法-模块\"></a>2.8 TypeScript基础语法-模块</h4><ol>\n<li>应用越来越大的时候，可以通过使用模块（module）进行拆分，module可以相互加载、可以通过export和import来交换功能，即调用从另外一个模块的函数。</li>\n<li>两个模块是通过文件上的引用进行import和export的。</li>\n<li>正常模块中的变量、函数、类都不可以被别的模块访问，除非添加export</li>\n<li>import以后，可以访问其变量、函数、类</li>\n</ol>\n<h4 id=\"2-9-TypeScript基础语法-迭代器\"><a href=\"#2-9-TypeScript基础语法-迭代器\" class=\"headerlink\" title=\"2.9 TypeScript基础语法-迭代器\"></a>2.9 TypeScript基础语法-迭代器</h4><p>迭代器用来循环和遍历数组for of 语句和for in语句 </p>\n<p>for in语句：遍历数组的下标</p>\n<p>for of语句： 遍历数组的元素</p>\n<h3 id=\"三、ArkTS\"><a href=\"#三、ArkTS\" class=\"headerlink\" title=\"三、ArkTS\"></a>三、ArkTS</h3><p>ArkTS是HarmonyOS及整个鸿蒙生态优选的主力应用开发语言，它是在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了<strong>声明式UI</strong>、<strong>状态管理</strong>等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用，可以这么说，ArkTSTypeScript的超集。</p>\n<p>当前，ArkTS在TS的基础上主要扩展了如下能力：</p>\n<ul>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-basic-syntax-overview-0000001531611153-V3\">基本语法</a>：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-management-overview-0000001524537145-V3\">状态管理</a>：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。</li>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-rendering-control-overview-0000001543911149-V3\">渲染控制</a>：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li>\n</ul>\n<p>未来，ArkTS会结合应用开发&#x2F;运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。</p>\n<h4 id=\"3-1-装饰器：\"><a href=\"#3-1-装饰器：\" class=\"headerlink\" title=\"3.1 装饰器：\"></a>3.1 装饰器：</h4><p>装饰类、结构、方法、变量，赋予其特殊的含义</p>\n<p>@Component 表示自定义组件装饰器，需要添加export关键字，进行导出</p>\n<p>@Entry  修饰的自定义组件作为页面的入口，加载页面时，首先家在@Entry修饰的自定义组件页面</p>\n<p>@Component struct 自定义结构体</p>\n<p>@State  状态管理装饰器</p>\n<p>@Link 可以和父组件中@State修饰的变量建立双向绑定，任何一方数据修改都会反馈另外一方，需要使用$进行引用</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/Compont.png\" alt=\"img\"></p>\n<h4 id=\"3-2-Component自定义组件的生命周期：\"><a href=\"#3-2-Component自定义组件的生命周期：\" class=\"headerlink\" title=\"3.2  @Component自定义组件的生命周期：\"></a>3.2  @Component自定义组件的生命周期：</h4><p>aboutToAppear：自定义组件被加载时调用，一般在这里进行数据处理和赋值</p>\n<p>aboutToDisAppear:  自定义组件销毁时调用，一般在这里进行数据回收，避免资源泄漏</p>\n<h4 id=\"3-3-Entry修饰的页面入口组件生命周期\"><a href=\"#3-3-Entry修饰的页面入口组件生命周期\" class=\"headerlink\" title=\"3.3  @Entry修饰的页面入口组件生命周期\"></a>3.3  @Entry修饰的页面入口组件生命周期</h4><p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/Entry.png\" alt=\"img\"></p>\n<h4 id=\"3-3-条件渲染\"><a href=\"#3-3-条件渲染\" class=\"headerlink\" title=\"3.3  条件渲染\"></a>3.3  条件渲染</h4><h4 id=\"3-4-ForEach\"><a href=\"#3-4-ForEach\" class=\"headerlink\" title=\"3.4  ForEach\"></a>3.4  ForEach</h4><p>第一个参数为数据源、</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/ForEach.png\" alt=\"img\"></p>\n<h4 id=\"3-5-声明式UI特征\"><a href=\"#3-5-声明式UI特征\" class=\"headerlink\" title=\"3.5  声明式UI特征\"></a>3.5  声明式UI特征</h4><ol>\n<li>声名式描述</li>\n<li>状态驱动视图更新</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HarmonyOS开发—基础—ArkTS语言介绍\"><a href=\"#HarmonyOS开发—基础—ArkTS语言介绍\" class=\"headerlink\" title=\"HarmonyOS开发—基础—ArkTS语言介绍\"></a>HarmonyOS开发—基础—ArkTS语言介绍</h2><p>HarmonyOS使用ArkTS语言开发，ArkTS语言是TypeScript的基础上的拓展，而TypeScript是JavaScript的超集。</p>\n<h3 id=\"一、JavaScript\"><a href=\"#一、JavaScript\" class=\"headerlink\" title=\"一、JavaScript\"></a>一、JavaScript</h3><p>JavaScript（通常缩写为JS）是用来和HTML和CSS结合创建交互式网页，是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程序设计、指令式编程和函数式编程。它提供了操作文本、数组、日期以及正则表达式等能力。JavaScript虽然不支持I&#x2F;O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化（ES6）。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari和Opera）所支持。</p>\n<p>对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT， Just-in-Time）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。</p>\n<h3 id=\"二、TypeScript\"><a href=\"#二、TypeScript\" class=\"headerlink\" title=\"二、TypeScript\"></a>二、TypeScript</h3><p>TypeScript是由微软进行开发和维护的一种开源的编程语言。提到TypeScript，第一个解释均为：TypeScript是JavaScript的超集。是的，随着JavaScript项目的复杂性呈指数级地增长，JavaScript用于编辑大规模应用程序时，在服务端会变得混乱和复杂，难以维护，此时TypeScript应运而生。TypeScript更强调显式类型，使研发人员能掌握各种组件的交互方式，并且TypeScript支持编译时调试，对于处理大型复杂应用程序的团队而言，这无疑是一个优点。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/ArkTs.png\" alt=\"img\"></p>\n<h4 id=\"2-1-TypeScript基础语法-基础类型\"><a href=\"#2-1-TypeScript基础语法-基础类型\" class=\"headerlink\" title=\"2.1 TypeScript基础语法-基础类型\"></a>2.1 TypeScript基础语法-基础类型</h4><p><strong>boolean</strong>：TypeScript中使用boolean来标志布尔类型，可以为true和false</p>\n<p><strong>number</strong>：TypeScript中所有的数字均为浮点型，这些浮点型的类型为number，除了支持十进制、二进制、八进制还支持了十六进制。</p>\n<p><strong>string</strong>：字符串，使用string标志为文本类型。TypeScript中可以使用单引号或者双引号标记字符串</p>\n<p><strong>数组</strong>：第一种，在元素后边加上方括号，表示为数组：let list1: number[] &#x3D; [1,2,3]  另外一种，范型let list2: Array<number> &#x3D; [1,2,3] </p>\n<p><strong>元组</strong>：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。let x :[string,number]</p>\n<p><strong>枚举</strong>：enum类型是对JavaScript基础类型的一个补充，使用枚举可以给一组数据类型友好的赋予一个名字。</p>\n<p><strong>unknow</strong>：有时候我们编程的时候，不清楚数据可能出现的类型，可以用unknow进行定义。unknow可以是string、boolean、number</p>\n<p><strong>void</strong>:当一个函数没有返回值时，这个类型为void</p>\n<p><strong>undefined 和null</strong> ：在TypeScript中，undefined和null是两种不同的基础类型，需要注意</p>\n<p><strong>联合类型</strong>：取值可以为多种类型中的一种  let state:string|number 这时  state可以被赋值为string或者number。</p>\n<h4 id=\"2-2-TypeScript基础语法-条件\"><a href=\"#2-2-TypeScript基础语法-条件\" class=\"headerlink\" title=\"2.2 TypeScript基础语法-条件\"></a>2.2 TypeScript基础语法-条件</h4><p>TypeScript支持按照不同的条件执行不同的逻辑代码，和Java类似，也支持if else </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * IfElse示例代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"title function_\">testIfElse</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;大于0&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;等于0&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num + <span class=\"string\">&quot;小于0&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样也支持Switch语法</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Switch示例代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"title function_\">testSwitch</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;当前数字是：1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;当前数字是：2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-TypeScript基础语法-函数\"><a href=\"#2-3-TypeScript基础语法-函数\" class=\"headerlink\" title=\"2.3 TypeScript基础语法-函数\"></a>2.3 TypeScript基础语法-函数</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 有名函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 匿名函数，没有函数名</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> addResult = <span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-TypeScript基础语法-可选参数\"><a href=\"#2-4-TypeScript基础语法-可选参数\" class=\"headerlink\" title=\"2.4 TypeScript基础语法-可选参数\"></a>2.4 TypeScript基础语法-可选参数</h4><p>TypeScript中，函数构造参数可以使用？标记当前参数为可选参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 入参带着age，表明是可选参数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">appendStr</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, age?: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name + age;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两种调用都可以</span></span><br><span class=\"line\"><span class=\"title function_\">appendStr</span>(<span class=\"string\">&quot;duanbokan&quot;</span>)</span><br><span class=\"line\"><span class=\"title function_\">appendStr</span>(<span class=\"string\">&quot;duanbokan&quot;</span>,<span class=\"string\">&quot;18&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-TypeScript基础语法-箭头函数\"><a href=\"#2-5-TypeScript基础语法-箭头函数\" class=\"headerlink\" title=\"2.5 TypeScript基础语法-箭头函数\"></a>2.5 TypeScript基础语法-箭头函数</h4><p>ES6版本的TypeScript提供了箭头函数，省略了function关键字，其函数是一个语句块：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 箭头函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">(<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">string</span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 箭头函数赋值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">name</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> <span class=\"variable\">age</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">appendResult</span> = (<span class=\"params\">name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name + age</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-TypeScript基础语法-类\"><a href=\"#2-6-TypeScript基础语法-类\" class=\"headerlink\" title=\"2.6 TypeScript基础语法-类\"></a>2.6 TypeScript基础语法-类</h4><p>class 开头，直接跟着类名，类可以是public、private、通过这个关键字，控制类的访问权限</p>\n<h4 id=\"2-7-TypeScript基础语法-继承\"><a href=\"#2-7-TypeScript基础语法-继承\" class=\"headerlink\" title=\"2.7 TypeScript基础语法-继承\"></a>2.7 TypeScript基础语法-继承</h4><p>class 支持继承，对应关键字是extends</p>\n<h4 id=\"2-8-TypeScript基础语法-模块\"><a href=\"#2-8-TypeScript基础语法-模块\" class=\"headerlink\" title=\"2.8 TypeScript基础语法-模块\"></a>2.8 TypeScript基础语法-模块</h4><ol>\n<li>应用越来越大的时候，可以通过使用模块（module）进行拆分，module可以相互加载、可以通过export和import来交换功能，即调用从另外一个模块的函数。</li>\n<li>两个模块是通过文件上的引用进行import和export的。</li>\n<li>正常模块中的变量、函数、类都不可以被别的模块访问，除非添加export</li>\n<li>import以后，可以访问其变量、函数、类</li>\n</ol>\n<h4 id=\"2-9-TypeScript基础语法-迭代器\"><a href=\"#2-9-TypeScript基础语法-迭代器\" class=\"headerlink\" title=\"2.9 TypeScript基础语法-迭代器\"></a>2.9 TypeScript基础语法-迭代器</h4><p>迭代器用来循环和遍历数组for of 语句和for in语句 </p>\n<p>for in语句：遍历数组的下标</p>\n<p>for of语句： 遍历数组的元素</p>\n<h3 id=\"三、ArkTS\"><a href=\"#三、ArkTS\" class=\"headerlink\" title=\"三、ArkTS\"></a>三、ArkTS</h3><p>ArkTS是HarmonyOS及整个鸿蒙生态优选的主力应用开发语言，它是在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了<strong>声明式UI</strong>、<strong>状态管理</strong>等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用，可以这么说，ArkTSTypeScript的超集。</p>\n<p>当前，ArkTS在TS的基础上主要扩展了如下能力：</p>\n<ul>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-basic-syntax-overview-0000001531611153-V3\">基本语法</a>：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-management-overview-0000001524537145-V3\">状态管理</a>：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。</li>\n<li><a href=\"https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-rendering-control-overview-0000001543911149-V3\">渲染控制</a>：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li>\n</ul>\n<p>未来，ArkTS会结合应用开发&#x2F;运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。</p>\n<h4 id=\"3-1-装饰器：\"><a href=\"#3-1-装饰器：\" class=\"headerlink\" title=\"3.1 装饰器：\"></a>3.1 装饰器：</h4><p>装饰类、结构、方法、变量，赋予其特殊的含义</p>\n<p>@Component 表示自定义组件装饰器，需要添加export关键字，进行导出</p>\n<p>@Entry  修饰的自定义组件作为页面的入口，加载页面时，首先家在@Entry修饰的自定义组件页面</p>\n<p>@Component struct 自定义结构体</p>\n<p>@State  状态管理装饰器</p>\n<p>@Link 可以和父组件中@State修饰的变量建立双向绑定，任何一方数据修改都会反馈另外一方，需要使用$进行引用</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/Compont.png\" alt=\"img\"></p>\n<h4 id=\"3-2-Component自定义组件的生命周期：\"><a href=\"#3-2-Component自定义组件的生命周期：\" class=\"headerlink\" title=\"3.2  @Component自定义组件的生命周期：\"></a>3.2  @Component自定义组件的生命周期：</h4><p>aboutToAppear：自定义组件被加载时调用，一般在这里进行数据处理和赋值</p>\n<p>aboutToDisAppear:  自定义组件销毁时调用，一般在这里进行数据回收，避免资源泄漏</p>\n<h4 id=\"3-3-Entry修饰的页面入口组件生命周期\"><a href=\"#3-3-Entry修饰的页面入口组件生命周期\" class=\"headerlink\" title=\"3.3  @Entry修饰的页面入口组件生命周期\"></a>3.3  @Entry修饰的页面入口组件生命周期</h4><p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/Entry.png\" alt=\"img\"></p>\n<h4 id=\"3-3-条件渲染\"><a href=\"#3-3-条件渲染\" class=\"headerlink\" title=\"3.3  条件渲染\"></a>3.3  条件渲染</h4><h4 id=\"3-4-ForEach\"><a href=\"#3-4-ForEach\" class=\"headerlink\" title=\"3.4  ForEach\"></a>3.4  ForEach</h4><p>第一个参数为数据源、</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/ArkTs/ForEach.png\" alt=\"img\"></p>\n<h4 id=\"3-5-声明式UI特征\"><a href=\"#3-5-声明式UI特征\" class=\"headerlink\" title=\"3.5  声明式UI特征\"></a>3.5  声明式UI特征</h4><ol>\n<li>声名式描述</li>\n<li>状态驱动视图更新</li>\n</ol>\n"},{"title":"HarmonyOS开发—基础—自定义组件","date":"2024-02-16T11:32:46.000Z","keywords":"HarmonyOS,HarmonyOS开发,HarmonyOS入门,自定义组件","description":"自定义组件","top_img":"http://image.jucaiwy.com/image/Harmony/Plugin/harmony.jpg","cover":"http://image.jucaiwy.com/image/Harmony/Plugin/harmony.jpg","_content":"\n## HarmonyOS开发—基础—自定义组件\n\n## 一、创建自定义组件\n\n在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。\n\n自定义组件具有以下特点：\n\n● 可组合：允许开发者组合使用系统组件、及其属性和方法。\n\n● 可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。\n\n● 数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。\n\n\n\n以下示例展示了自定义组件的基本用法。\n\n```typescript\n@Component\nstruct HelloComponent {\n  @State message: string = 'Hello, World!';\n\n  build() {\n    // HelloComponent自定义组件组合系统组件Row和Text\n    Row() {\n      Text(this.message)\n        .onClick(() => {\n          // 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'\n          this.message = 'Hello, ArkUI!';\n        })\n    }\n  }\n}\n```\n\n复制\n\nHelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。\n\n```typescript\nclass HelloComponentParam {\n  message: string = \"\"\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  param: HelloComponentParam = {\n    message: 'Hello, World!'\n  }\n\n  build() {\n    Column() {\n      Text('ArkUI message')\n      HelloComponent(param);\n      Divider()\n      HelloComponent(param);\n    }\n  }\n}\n```\n\n要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：\n\n ● [自定义组件的基本结构](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件的基本结构)\n\n ● [成员函数/变量](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#成员函数变量)\n\n ● [自定义组件的参数规定](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件的参数规定)\n\n ● [build()函数](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#build函数)\n\n ● [自定义组件通用样式](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件通用样式)\n\n### 1.1 自定义组件的基本结构\n\n● struct：自定义组件基于struct实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。\n\n说明：自定义组件名、类名、函数名不能和系统组件名相同。\n\n● @Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。\n\n说明：从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n\n```typescript\n@Component\nstruct MyComponent {\n}\n```\n\n● build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。\n\n```typescript\n@Component\nstruct MyComponent {\n  build() {\n  }\n}\n```\n\n ● @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的[LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md)的参数。\n\n说明：\n\n从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n\n从API version 10开始，@Entry可以接受一个可选的[LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md)的参数或者一个可选的[EntryOptions](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#entryOptions)参数。\n\n```typescript\n@Entry\n@Component\nstruct MyComponent {\n}\n```\n\n复制\n\nEntryOptions10+命名路由跳转选项。\n\n| 名称      | 类型                                                         | 必填 | 说明                         |\n| --------- | ------------------------------------------------------------ | ---- | ---------------------------- |\n| routeName | string                                                       | 否   | 表示作为命名路由页面的名字。 |\n| storage   | [LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md) | 否   | 页面级的UI状态存储。         |\n\n```typescript\n@Entry({ routeName : 'myPage' })\n@Component\nstruct MyComponent {\n}\n```\n\n● @Reusable：@Reusable装饰的自定义组件具备可复用能力\n\n说明：\n\n从API version 10开始，该装饰器支持在ArkTS卡片中使用。\n\n```typescript\n@Reusable\n@Component\nstruct MyComponent {\n}\n```\n\n### 1.2 成员函数/变量\n\n自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：\n\n● 不支持静态函数。\n\n● 成员函数的访问始终是私有的。\n\n自定义组件可以包含成员变量，成员变量具有以下约束：\n\n● 不支持静态成员变量。\n\n● 所有成员变量都是私有的，变量的访问规则与成员函数的访问规则相同。\n\n ● 自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考[状态管理](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md)。\n\n### 1.3 自定义组件的参数规定\n\n从上文的示例中，我们已经了解到，可以在build方法或者[@Builder](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-builder.md)装饰的函数里创建自定义组件，在创建的过程中，参数可以被提供给组件。\n\n```typescript\n@Component\nstruct MyComponent {\n  private countDownFrom: number = 0;\n  private color: Color = Color.Blue;\n  build() {\n  }\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  private someColor: Color = Color.Pink;\n  build() {\n    Column() {\n      // 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor\n      MyComponent({ countDownFrom: 10, color: this.someColor })\n    }\n  }\n}\n```\n\n### 1.4 build()函数\n\n所有声明在build()函数的语言，我们统称为UI描述语言，UI描述语言需要遵循以下规则：\n\n● @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。\n\n```typescript\n@Entry\n@Component\nstruct MyComponent {\n  build() {\n    // 根节点唯一且必要，必须为容器组件\n    Row() {\n      ChildComponent() \n    }\n  }\n}\n\n@Component\nstruct ChildComponent {\n  build() {\n    // 根节点唯一且必要，可为非容器组件\n    Image('test.jpg')\n  }\n}\n```\n\n● 不允许声明本地变量，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许声明本地变量\n  let a: number = 1;\n}1.2.3.4.\n```\n\n ● [不允许在UI描述里直接使用console.info](http://xn--uiconsole-kc6ni1khwgi7w4h5b8ras43tmng274ho0q9pi.info/)，但允许在方法或者函数里使用，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许console.info\n  console.info('print debug log');\n}\n```\n\n● 不允许创建本地的作用域，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许本地作用域\n  {\n    ...\n  }\n}\n```\n\n● 不允许调用除了被@Builder装饰以外的方法，允许系统组件的参数是TS方法的返回值。\n\n```typescript\n@Component\nstruct ParentComponent {\n  doSomeCalculations() {\n  }\n\n  calcTextValue(): string {\n    return 'Hello World';\n  }\n\n  @Builder doSomeRender() {\n    Text(`Hello World`)\n  }\n\n  build() {\n    Column() {\n      // 反例：不能调用没有用@Builder装饰的方法\n      this.doSomeCalculations();\n      // 正例：可以调用\n      this.doSomeRender();\n      // 正例：参数可以为调用TS方法的返回值\n      Text(this.calcTextValue())\n    }\n  }\n}\n```\n\n复制\n\n● 不允许使用switch语法，如果需要使用条件判断，请使用if。反例如下。\n\n```typescript\nbuild() {\n  Column() {\n    // 反例：不允许使用switch语法\n    switch (expression) {\n      case 1:\n        Text('...')\n        break;\n      case 2:\n        Image('...')\n        break;\n      default:\n        Text('...')\n        break;\n    }\n  }\n}\n```\n\n● 不允许使用表达式，反例如下。\n\n```typescript\nbuild() {\n  Column() {\n    // 反例：不允许使用表达式\n    (this.aVar > 10) ? Text('...') : Image('...')\n  }\n}\n```\n\n### 1.5 自定义组件通用样式\n\n自定义组件通过“.”链式调用的形式设置通用样式。\n\n```typescript\n@Component\nstruct MyComponent2 {\n  build() {\n    Button(`Hello World`)\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  build() {\n    Row() {\n      MyComponent2()\n        .width(200)\n        .height(300)\n        .backgroundColor(Color.Red)\n    }\n  }\n}\n```\n\n说明：\n\nArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。\n\n## 二、页面和自定义组件生命周期\n\n在开始之前，我们先明确自定义组件和页面的关系：\n\n● 自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。\n\n● 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。\n\n页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：\n\n ● [onPageShow](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpageshow)：页面每次显示时触发。\n\n ● [onPageHide](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpagehide)：页面每次隐藏时触发一次。\n\n ● [onBackPress](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onbackpress)：当用户点击返回按钮时触发。\n\n组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：\n\n ● [aboutToAppear](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttoappear)：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。\n\n ● [aboutToDisappear](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttodisappear)：在自定义组件即将析构销毁时执行。\n\n生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（首页）生命周期。\n\n![img](http://image.jucaiwy.com/image/Harmony/Plugin/plugin-lifecycle.png)\n\n根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。\n\n### 2.1 自定义组件的创建和渲染流程\n\n1. 自定义组件的创建：自定义组件的实例由ArkUI框架创建。\n2. 初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。\n3. 如果开发者定义了aboutToAppear，则执行aboutToAppear方法。\n4. 在首次渲染的时候，执行build方法渲染系统组件，如果有自定义子组件，则创建自定义组件的实例。在执行build()函数的过程中，框架会观察每个状态变量的读取状态，将保存两个map：\n\na. 状态变量 -> UI组件（包括ForEach和if）。\n\nb. UI组件 -> 此组件的更新函数，即一个lambda方法，作为build()函数的子集，创建对应的UI组件并执行其属性方法，示意如下。\n\n```typescript\nbuild() {\n  ...\n  this.observeComponentCreation(() => {\n    Button.create();\n  })\n\n  this.observeComponentCreation(() => {\n    Text.create();\n  })\n  ...\n}\n```\n\n当应用在后台启动时，此时应用进程并没有销毁，所以仅需要执行onPageShow。\n\n### 2.2 自定义组件重新渲染\n\n当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage / AppStorage中的属性更改，并导致绑定的状态变量更改其值时：\n\n1. 框架观察到了变化，将启动重新渲染。\n2. 根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。\n\n### 2.3 自定义组件的删除\n\n如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：\n\n1. 在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，当前端节点已经没有引用时，将被JS虚拟机垃圾回收。\n\n 2. 自定义组件和它的变量将被删除，如果其有同步的变量，比如[@Link](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-link.md)、[@Prop](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-prop.md)、[@StorageLink](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-appstorage.md#storagelink)，将从[同步源](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md#基本概念)上取消注册。\n\n不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。\n\n以下示例展示了生命周期的调用时机：\n\n```typescript\n// Index.ets\nimport router from '@ohos.router';\n\n@Entry\n@Component\nstruct MyComponent {\n  @State showChild: boolean = true;\n\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onPageShow() {\n    console.info('Index onPageShow');\n  }\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onPageHide() {\n    console.info('Index onPageHide');\n  }\n\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onBackPress() {\n    console.info('Index onBackPress');\n  }\n\n  // 组件生命周期\n  aboutToAppear() {\n    console.info('MyComponent aboutToAppear');\n  }\n\n  // 组件生命周期\n  aboutToDisappear() {\n    console.info('MyComponent aboutToDisappear');\n  }\n\n  build() {\n    Column() {\n      // this.showChild为true，创建Child子组件，执行Child aboutToAppear\n      if (this.showChild) {\n        Child()\n      }\n      // this.showChild为false，删除Child子组件，执行Child aboutToDisappear\n      Button('delete Child').onClick(() => {\n        this.showChild = false;\n      })\n      // push到Page2页面，执行onPageHide\n      Button('push to next page')\n        .onClick(() => {\n          router.pushUrl({ url: 'pages/Page2' });\n        })\n    }\n\n  }\n}\n\n@Component\nstruct Child {\n  @State title: string = 'Hello World';\n  // 组件生命周期\n  aboutToDisappear() {\n    console.info('[lifeCycle] Child aboutToDisappear')\n  }\n  // 组件生命周期\n  aboutToAppear() {\n    console.info('[lifeCycle] Child aboutToAppear')\n  }\n\n  build() {\n    Text(this.title).fontSize(50).onClick(() => {\n      this.title = 'Hello ArkUI';\n    })\n  }\n}\n```\n\n以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以生效页面的生命周期方法，所以MyComponent中声明了当前Index页面的页面生命周期函数。MyComponent和其子组件Child也同时声明了组件的生命周期函数。\n\n● 应用冷启动的初始化流程为：MyComponent aboutToAppear --> MyComponent build --> Child aboutToAppear --> Child build --> Child build执行完毕 --> MyComponent build执行完毕 --> Index onPageShow。\n\n● 点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。\n\n● 点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。\n\n● 如果调用的是router.replaceUrl，则当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。上文已经提到，组件的销毁是从组件树上直接摘下子树，所以先调用父组件的aboutToDisappear，再调用子组件的aboutToDisappear，然后执行初始化新页面的生命周期流程。\n\n● 点击返回按钮，触发页面生命周期Index onBackPress，且触发返回一个页面后会导致当前Index页面被销毁。\n\n● 最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。\n\n● 退出应用，执行Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。\n\n","source":"_posts/20240216-HarmonyOS开发—基础—自定义组件.md","raw":"---\n\ntitle: HarmonyOS开发—基础—自定义组件\n\ndate: 2024-02-16 19:32:46\n\ntags: [HarmonyOS开发,自定义组件]\n\ncategories: HarmonyOS\n\nkeywords: HarmonyOS,HarmonyOS开发,HarmonyOS入门,自定义组件\n\ndescription: 自定义组件\n\ntop_img: http://image.jucaiwy.com/image/Harmony/Plugin/harmony.jpg\n\ncover: http://image.jucaiwy.com/image/Harmony/Plugin/harmony.jpg\n\n---\n\n## HarmonyOS开发—基础—自定义组件\n\n## 一、创建自定义组件\n\n在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。\n\n自定义组件具有以下特点：\n\n● 可组合：允许开发者组合使用系统组件、及其属性和方法。\n\n● 可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。\n\n● 数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。\n\n\n\n以下示例展示了自定义组件的基本用法。\n\n```typescript\n@Component\nstruct HelloComponent {\n  @State message: string = 'Hello, World!';\n\n  build() {\n    // HelloComponent自定义组件组合系统组件Row和Text\n    Row() {\n      Text(this.message)\n        .onClick(() => {\n          // 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'\n          this.message = 'Hello, ArkUI!';\n        })\n    }\n  }\n}\n```\n\n复制\n\nHelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。\n\n```typescript\nclass HelloComponentParam {\n  message: string = \"\"\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  param: HelloComponentParam = {\n    message: 'Hello, World!'\n  }\n\n  build() {\n    Column() {\n      Text('ArkUI message')\n      HelloComponent(param);\n      Divider()\n      HelloComponent(param);\n    }\n  }\n}\n```\n\n要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：\n\n ● [自定义组件的基本结构](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件的基本结构)\n\n ● [成员函数/变量](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#成员函数变量)\n\n ● [自定义组件的参数规定](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件的参数规定)\n\n ● [build()函数](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#build函数)\n\n ● [自定义组件通用样式](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#自定义组件通用样式)\n\n### 1.1 自定义组件的基本结构\n\n● struct：自定义组件基于struct实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。\n\n说明：自定义组件名、类名、函数名不能和系统组件名相同。\n\n● @Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。\n\n说明：从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n\n```typescript\n@Component\nstruct MyComponent {\n}\n```\n\n● build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。\n\n```typescript\n@Component\nstruct MyComponent {\n  build() {\n  }\n}\n```\n\n ● @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的[LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md)的参数。\n\n说明：\n\n从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n\n从API version 10开始，@Entry可以接受一个可选的[LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md)的参数或者一个可选的[EntryOptions](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#entryOptions)参数。\n\n```typescript\n@Entry\n@Component\nstruct MyComponent {\n}\n```\n\n复制\n\nEntryOptions10+命名路由跳转选项。\n\n| 名称      | 类型                                                         | 必填 | 说明                         |\n| --------- | ------------------------------------------------------------ | ---- | ---------------------------- |\n| routeName | string                                                       | 否   | 表示作为命名路由页面的名字。 |\n| storage   | [LocalStorage](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md) | 否   | 页面级的UI状态存储。         |\n\n```typescript\n@Entry({ routeName : 'myPage' })\n@Component\nstruct MyComponent {\n}\n```\n\n● @Reusable：@Reusable装饰的自定义组件具备可复用能力\n\n说明：\n\n从API version 10开始，该装饰器支持在ArkTS卡片中使用。\n\n```typescript\n@Reusable\n@Component\nstruct MyComponent {\n}\n```\n\n### 1.2 成员函数/变量\n\n自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：\n\n● 不支持静态函数。\n\n● 成员函数的访问始终是私有的。\n\n自定义组件可以包含成员变量，成员变量具有以下约束：\n\n● 不支持静态成员变量。\n\n● 所有成员变量都是私有的，变量的访问规则与成员函数的访问规则相同。\n\n ● 自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考[状态管理](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md)。\n\n### 1.3 自定义组件的参数规定\n\n从上文的示例中，我们已经了解到，可以在build方法或者[@Builder](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-builder.md)装饰的函数里创建自定义组件，在创建的过程中，参数可以被提供给组件。\n\n```typescript\n@Component\nstruct MyComponent {\n  private countDownFrom: number = 0;\n  private color: Color = Color.Blue;\n  build() {\n  }\n}\n\n@Entry\n@Component\nstruct ParentComponent {\n  private someColor: Color = Color.Pink;\n  build() {\n    Column() {\n      // 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor\n      MyComponent({ countDownFrom: 10, color: this.someColor })\n    }\n  }\n}\n```\n\n### 1.4 build()函数\n\n所有声明在build()函数的语言，我们统称为UI描述语言，UI描述语言需要遵循以下规则：\n\n● @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。\n\n```typescript\n@Entry\n@Component\nstruct MyComponent {\n  build() {\n    // 根节点唯一且必要，必须为容器组件\n    Row() {\n      ChildComponent() \n    }\n  }\n}\n\n@Component\nstruct ChildComponent {\n  build() {\n    // 根节点唯一且必要，可为非容器组件\n    Image('test.jpg')\n  }\n}\n```\n\n● 不允许声明本地变量，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许声明本地变量\n  let a: number = 1;\n}1.2.3.4.\n```\n\n ● [不允许在UI描述里直接使用console.info](http://xn--uiconsole-kc6ni1khwgi7w4h5b8ras43tmng274ho0q9pi.info/)，但允许在方法或者函数里使用，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许console.info\n  console.info('print debug log');\n}\n```\n\n● 不允许创建本地的作用域，反例如下。\n\n```typescript\nbuild() {\n  // 反例：不允许本地作用域\n  {\n    ...\n  }\n}\n```\n\n● 不允许调用除了被@Builder装饰以外的方法，允许系统组件的参数是TS方法的返回值。\n\n```typescript\n@Component\nstruct ParentComponent {\n  doSomeCalculations() {\n  }\n\n  calcTextValue(): string {\n    return 'Hello World';\n  }\n\n  @Builder doSomeRender() {\n    Text(`Hello World`)\n  }\n\n  build() {\n    Column() {\n      // 反例：不能调用没有用@Builder装饰的方法\n      this.doSomeCalculations();\n      // 正例：可以调用\n      this.doSomeRender();\n      // 正例：参数可以为调用TS方法的返回值\n      Text(this.calcTextValue())\n    }\n  }\n}\n```\n\n复制\n\n● 不允许使用switch语法，如果需要使用条件判断，请使用if。反例如下。\n\n```typescript\nbuild() {\n  Column() {\n    // 反例：不允许使用switch语法\n    switch (expression) {\n      case 1:\n        Text('...')\n        break;\n      case 2:\n        Image('...')\n        break;\n      default:\n        Text('...')\n        break;\n    }\n  }\n}\n```\n\n● 不允许使用表达式，反例如下。\n\n```typescript\nbuild() {\n  Column() {\n    // 反例：不允许使用表达式\n    (this.aVar > 10) ? Text('...') : Image('...')\n  }\n}\n```\n\n### 1.5 自定义组件通用样式\n\n自定义组件通过“.”链式调用的形式设置通用样式。\n\n```typescript\n@Component\nstruct MyComponent2 {\n  build() {\n    Button(`Hello World`)\n  }\n}\n\n@Entry\n@Component\nstruct MyComponent {\n  build() {\n    Row() {\n      MyComponent2()\n        .width(200)\n        .height(300)\n        .backgroundColor(Color.Red)\n    }\n  }\n}\n```\n\n说明：\n\nArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。\n\n## 二、页面和自定义组件生命周期\n\n在开始之前，我们先明确自定义组件和页面的关系：\n\n● 自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。\n\n● 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。\n\n页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：\n\n ● [onPageShow](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpageshow)：页面每次显示时触发。\n\n ● [onPageHide](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpagehide)：页面每次隐藏时触发一次。\n\n ● [onBackPress](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onbackpress)：当用户点击返回按钮时触发。\n\n组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：\n\n ● [aboutToAppear](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttoappear)：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。\n\n ● [aboutToDisappear](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttodisappear)：在自定义组件即将析构销毁时执行。\n\n生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（首页）生命周期。\n\n![img](http://image.jucaiwy.com/image/Harmony/Plugin/plugin-lifecycle.png)\n\n根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。\n\n### 2.1 自定义组件的创建和渲染流程\n\n1. 自定义组件的创建：自定义组件的实例由ArkUI框架创建。\n2. 初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。\n3. 如果开发者定义了aboutToAppear，则执行aboutToAppear方法。\n4. 在首次渲染的时候，执行build方法渲染系统组件，如果有自定义子组件，则创建自定义组件的实例。在执行build()函数的过程中，框架会观察每个状态变量的读取状态，将保存两个map：\n\na. 状态变量 -> UI组件（包括ForEach和if）。\n\nb. UI组件 -> 此组件的更新函数，即一个lambda方法，作为build()函数的子集，创建对应的UI组件并执行其属性方法，示意如下。\n\n```typescript\nbuild() {\n  ...\n  this.observeComponentCreation(() => {\n    Button.create();\n  })\n\n  this.observeComponentCreation(() => {\n    Text.create();\n  })\n  ...\n}\n```\n\n当应用在后台启动时，此时应用进程并没有销毁，所以仅需要执行onPageShow。\n\n### 2.2 自定义组件重新渲染\n\n当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage / AppStorage中的属性更改，并导致绑定的状态变量更改其值时：\n\n1. 框架观察到了变化，将启动重新渲染。\n2. 根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。\n\n### 2.3 自定义组件的删除\n\n如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：\n\n1. 在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，当前端节点已经没有引用时，将被JS虚拟机垃圾回收。\n\n 2. 自定义组件和它的变量将被删除，如果其有同步的变量，比如[@Link](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-link.md)、[@Prop](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-prop.md)、[@StorageLink](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-appstorage.md#storagelink)，将从[同步源](https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md#基本概念)上取消注册。\n\n不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。\n\n以下示例展示了生命周期的调用时机：\n\n```typescript\n// Index.ets\nimport router from '@ohos.router';\n\n@Entry\n@Component\nstruct MyComponent {\n  @State showChild: boolean = true;\n\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onPageShow() {\n    console.info('Index onPageShow');\n  }\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onPageHide() {\n    console.info('Index onPageHide');\n  }\n\n  // 只有被@Entry装饰的组件才可以调用页面的生命周期\n  onBackPress() {\n    console.info('Index onBackPress');\n  }\n\n  // 组件生命周期\n  aboutToAppear() {\n    console.info('MyComponent aboutToAppear');\n  }\n\n  // 组件生命周期\n  aboutToDisappear() {\n    console.info('MyComponent aboutToDisappear');\n  }\n\n  build() {\n    Column() {\n      // this.showChild为true，创建Child子组件，执行Child aboutToAppear\n      if (this.showChild) {\n        Child()\n      }\n      // this.showChild为false，删除Child子组件，执行Child aboutToDisappear\n      Button('delete Child').onClick(() => {\n        this.showChild = false;\n      })\n      // push到Page2页面，执行onPageHide\n      Button('push to next page')\n        .onClick(() => {\n          router.pushUrl({ url: 'pages/Page2' });\n        })\n    }\n\n  }\n}\n\n@Component\nstruct Child {\n  @State title: string = 'Hello World';\n  // 组件生命周期\n  aboutToDisappear() {\n    console.info('[lifeCycle] Child aboutToDisappear')\n  }\n  // 组件生命周期\n  aboutToAppear() {\n    console.info('[lifeCycle] Child aboutToAppear')\n  }\n\n  build() {\n    Text(this.title).fontSize(50).onClick(() => {\n      this.title = 'Hello ArkUI';\n    })\n  }\n}\n```\n\n以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以生效页面的生命周期方法，所以MyComponent中声明了当前Index页面的页面生命周期函数。MyComponent和其子组件Child也同时声明了组件的生命周期函数。\n\n● 应用冷启动的初始化流程为：MyComponent aboutToAppear --> MyComponent build --> Child aboutToAppear --> Child build --> Child build执行完毕 --> MyComponent build执行完毕 --> Index onPageShow。\n\n● 点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。\n\n● 点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。\n\n● 如果调用的是router.replaceUrl，则当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。上文已经提到，组件的销毁是从组件树上直接摘下子树，所以先调用父组件的aboutToDisappear，再调用子组件的aboutToDisappear，然后执行初始化新页面的生命周期流程。\n\n● 点击返回按钮，触发页面生命周期Index onBackPress，且触发返回一个页面后会导致当前Index页面被销毁。\n\n● 最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。\n\n● 退出应用，执行Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。\n\n","slug":"20240216-HarmonyOS开发—基础—自定义组件","published":1,"updated":"2024-07-10T10:24:18.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyfsx01t000t0nv60cw9g9x4","content":"<h2 id=\"HarmonyOS开发—基础—自定义组件\"><a href=\"#HarmonyOS开发—基础—自定义组件\" class=\"headerlink\" title=\"HarmonyOS开发—基础—自定义组件\"></a>HarmonyOS开发—基础—自定义组件</h2><h2 id=\"一、创建自定义组件\"><a href=\"#一、创建自定义组件\" class=\"headerlink\" title=\"一、创建自定义组件\"></a>一、创建自定义组件</h2><p>在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。</p>\n<p>自定义组件具有以下特点：</p>\n<p>● 可组合：允许开发者组合使用系统组件、及其属性和方法。</p>\n<p>● 可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。</p>\n<p>● 数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。</p>\n<p>以下示例展示了自定义组件的基本用法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">HelloComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;Hello, World!&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// HelloComponent自定义组件组合系统组件Row和Text</span></span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">message</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 状态变量message的改变驱动UI刷新，UI从&#x27;Hello, World!&#x27;刷新为&#x27;Hello, ArkUI!&#x27;</span></span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;Hello, ArkUI!&#x27;</span>;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>HelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloComponentParam</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">param</span>: <span class=\"title class_\">HelloComponentParam</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello, World!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;ArkUI message&#x27;</span>)</span><br><span class=\"line\">      <span class=\"title class_\">HelloComponent</span>(param);</span><br><span class=\"line\">      <span class=\"title class_\">Divider</span>()</span><br><span class=\"line\">      <span class=\"title class_\">HelloComponent</span>(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\">自定义组件的基本结构</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F\">成员函数&#x2F;变量</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%84%E5%AE%9A\">自定义组件的参数规定</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#build%E5%87%BD%E6%95%B0\">build()函数</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E9%80%9A%E7%94%A8%E6%A0%B7%E5%BC%8F\">自定义组件通用样式</a></p>\n<h3 id=\"1-1-自定义组件的基本结构\"><a href=\"#1-1-自定义组件的基本结构\" class=\"headerlink\" title=\"1.1 自定义组件的基本结构\"></a>1.1 自定义组件的基本结构</h3><p>● struct：自定义组件基于struct实现，struct + 自定义组件名 + {…}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。</p>\n<p>说明：自定义组件名、类名、函数名不能和系统组件名相同。</p>\n<p>● @Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。</p>\n<p>说明：从API version 9开始，该装饰器支持在ArkTS卡片中使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ● @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a>的参数。</p>\n<p>说明：</p>\n<p>从API version 9开始，该装饰器支持在ArkTS卡片中使用。</p>\n<p>从API version 10开始，@Entry可以接受一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a>的参数或者一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#entryOptions\">EntryOptions</a>参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>EntryOptions10+命名路由跳转选项。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>必填</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>routeName</td>\n<td>string</td>\n<td>否</td>\n<td>表示作为命名路由页面的名字。</td>\n</tr>\n<tr>\n<td>storage</td>\n<td><a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a></td>\n<td>否</td>\n<td>页面级的UI状态存储。</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span>(&#123; routeName : <span class=\"string\">&#x27;myPage&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● @Reusable：@Reusable装饰的自定义组件具备可复用能力</p>\n<p>说明：</p>\n<p>从API version 10开始，该装饰器支持在ArkTS卡片中使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reusable</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-成员函数-x2F-变量\"><a href=\"#1-2-成员函数-x2F-变量\" class=\"headerlink\" title=\"1.2 成员函数&#x2F;变量\"></a>1.2 成员函数&#x2F;变量</h3><p>自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：</p>\n<p>● 不支持静态函数。</p>\n<p>● 成员函数的访问始终是私有的。</p>\n<p>自定义组件可以包含成员变量，成员变量具有以下约束：</p>\n<p>● 不支持静态成员变量。</p>\n<p>● 所有成员变量都是私有的，变量的访问规则与成员函数的访问规则相同。</p>\n<p> ● 自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md\">状态管理</a>。</p>\n<h3 id=\"1-3-自定义组件的参数规定\"><a href=\"#1-3-自定义组件的参数规定\" class=\"headerlink\" title=\"1.3 自定义组件的参数规定\"></a>1.3 自定义组件的参数规定</h3><p>从上文的示例中，我们已经了解到，可以在build方法或者<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-builder.md\">@Builder</a>装饰的函数里创建自定义组件，在创建的过程中，参数可以被提供给组件。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">countDownFrom</span>: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">color</span>: <span class=\"title class_\">Color</span> = <span class=\"title class_\">Color</span>.<span class=\"property\">Blue</span>;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">someColor</span>: <span class=\"title class_\">Color</span> = <span class=\"title class_\">Color</span>.<span class=\"property\">Pink</span>;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor</span></span><br><span class=\"line\">      <span class=\"title class_\">MyComponent</span>(&#123; <span class=\"attr\">countDownFrom</span>: <span class=\"number\">10</span>, <span class=\"attr\">color</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">someColor</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-build-函数\"><a href=\"#1-4-build-函数\" class=\"headerlink\" title=\"1.4 build()函数\"></a>1.4 build()函数</h3><p>所有声明在build()函数的语言，我们统称为UI描述语言，UI描述语言需要遵循以下规则：</p>\n<p>● @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根节点唯一且必要，必须为容器组件</span></span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">ChildComponent</span>() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根节点唯一且必要，可为非容器组件</span></span><br><span class=\"line\">    <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;test.jpg&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许声明本地变量，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许声明本地变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"built_in\">number</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"number\">1.2</span><span class=\"number\">.3</span><span class=\"number\">.4</span>.</span><br></pre></td></tr></table></figure>\n\n<p> ● <a href=\"http://不允许在ui描述里直接使用console.info/\">不允许在UI描述里直接使用console.info</a>，但允许在方法或者函数里使用，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许console.info</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;print debug log&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许创建本地的作用域，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许本地作用域</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许调用除了被@Builder装饰以外的方法，允许系统组件的参数是TS方法的返回值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">doSomeCalculations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">calcTextValue</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello World&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Builder</span> <span class=\"title function_\">doSomeRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>(<span class=\"string\">`Hello World`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 反例：不能调用没有用@Builder装饰的方法</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">doSomeCalculations</span>();</span><br><span class=\"line\">      <span class=\"comment\">// 正例：可以调用</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">doSomeRender</span>();</span><br><span class=\"line\">      <span class=\"comment\">// 正例：参数可以为调用TS方法的返回值</span></span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">calcTextValue</span>())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>● 不允许使用switch语法，如果需要使用条件判断，请使用if。反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反例：不允许使用switch语法</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (expression) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许使用表达式，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反例：不允许使用表达式</span></span><br><span class=\"line\">    (<span class=\"variable language_\">this</span>.<span class=\"property\">aVar</span> &gt; <span class=\"number\">10</span>) ? <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>) : <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-自定义组件通用样式\"><a href=\"#1-5-自定义组件通用样式\" class=\"headerlink\" title=\"1.5 自定义组件通用样式\"></a>1.5 自定义组件通用样式</h3><p>自定义组件通过“.”链式调用的形式设置通用样式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent2</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Button</span>(<span class=\"string\">`Hello World`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">MyComponent2</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">width</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">backgroundColor</span>(<span class=\"title class_\">Color</span>.<span class=\"property\">Red</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<p>ArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。</p>\n<h2 id=\"二、页面和自定义组件生命周期\"><a href=\"#二、页面和自定义组件生命周期\" class=\"headerlink\" title=\"二、页面和自定义组件生命周期\"></a>二、页面和自定义组件生命周期</h2><p>在开始之前，我们先明确自定义组件和页面的关系：</p>\n<p>● 自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。</p>\n<p>● 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。</p>\n<p>页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpageshow\">onPageShow</a>：页面每次显示时触发。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpagehide\">onPageHide</a>：页面每次隐藏时触发一次。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onbackpress\">onBackPress</a>：当用户点击返回按钮时触发。</p>\n<p>组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttoappear\">aboutToAppear</a>：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttodisappear\">aboutToDisappear</a>：在自定义组件即将析构销毁时执行。</p>\n<p>生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（首页）生命周期。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/Plugin/plugin-lifecycle.png\" alt=\"img\"></p>\n<p>根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。</p>\n<h3 id=\"2-1-自定义组件的创建和渲染流程\"><a href=\"#2-1-自定义组件的创建和渲染流程\" class=\"headerlink\" title=\"2.1 自定义组件的创建和渲染流程\"></a>2.1 自定义组件的创建和渲染流程</h3><ol>\n<li>自定义组件的创建：自定义组件的实例由ArkUI框架创建。</li>\n<li>初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。</li>\n<li>如果开发者定义了aboutToAppear，则执行aboutToAppear方法。</li>\n<li>在首次渲染的时候，执行build方法渲染系统组件，如果有自定义子组件，则创建自定义组件的实例。在执行build()函数的过程中，框架会观察每个状态变量的读取状态，将保存两个map：</li>\n</ol>\n<p>a. 状态变量 -&gt; UI组件（包括ForEach和if）。</p>\n<p>b. UI组件 -&gt; 此组件的更新函数，即一个lambda方法，作为build()函数的子集，创建对应的UI组件并执行其属性方法，示意如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeComponentCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Button</span>.<span class=\"title function_\">create</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeComponentCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>.<span class=\"title function_\">create</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当应用在后台启动时，此时应用进程并没有销毁，所以仅需要执行onPageShow。</p>\n<h3 id=\"2-2-自定义组件重新渲染\"><a href=\"#2-2-自定义组件重新渲染\" class=\"headerlink\" title=\"2.2 自定义组件重新渲染\"></a>2.2 自定义组件重新渲染</h3><p>当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage &#x2F; AppStorage中的属性更改，并导致绑定的状态变量更改其值时：</p>\n<ol>\n<li>框架观察到了变化，将启动重新渲染。</li>\n<li>根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。</li>\n</ol>\n<h3 id=\"2-3-自定义组件的删除\"><a href=\"#2-3-自定义组件的删除\" class=\"headerlink\" title=\"2.3 自定义组件的删除\"></a>2.3 自定义组件的删除</h3><p>如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：</p>\n<ol>\n<li><p>在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，当前端节点已经没有引用时，将被JS虚拟机垃圾回收。</p>\n</li>\n<li><p>自定义组件和它的变量将被删除，如果其有同步的变量，比如<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-link.md\">@Link</a>、<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-prop.md\">@Prop</a>、<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-appstorage.md#storagelink\">@StorageLink</a>，将从<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">同步源</a>上取消注册。</p>\n</li>\n</ol>\n<p>不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。</p>\n<p>以下示例展示了生命周期的调用时机：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Index.ets</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@ohos.router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">showChild</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onPageShow</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onPageShow&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onPageHide</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onPageHide&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onBackPress</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onBackPress&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToAppear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;MyComponent aboutToAppear&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToDisappear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;MyComponent aboutToDisappear&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// this.showChild为true，创建Child子组件，执行Child aboutToAppear</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">showChild</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Child</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// this.showChild为false，删除Child子组件，执行Child aboutToDisappear</span></span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;delete Child&#x27;</span>).<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">showChild</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"comment\">// push到Page2页面，执行onPageHide</span></span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;push to next page&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          router.<span class=\"title function_\">pushUrl</span>(&#123; <span class=\"attr\">url</span>: <span class=\"string\">&#x27;pages/Page2&#x27;</span> &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">Child</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">title</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;Hello World&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToDisappear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;[lifeCycle] Child aboutToDisappear&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToAppear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;[lifeCycle] Child aboutToAppear&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">title</span>).<span class=\"title function_\">fontSize</span>(<span class=\"number\">50</span>).<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = <span class=\"string\">&#x27;Hello ArkUI&#x27;</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以生效页面的生命周期方法，所以MyComponent中声明了当前Index页面的页面生命周期函数。MyComponent和其子组件Child也同时声明了组件的生命周期函数。</p>\n<p>● 应用冷启动的初始化流程为：MyComponent aboutToAppear –&gt; MyComponent build –&gt; Child aboutToAppear –&gt; Child build –&gt; Child build执行完毕 –&gt; MyComponent build执行完毕 –&gt; Index onPageShow。</p>\n<p>● 点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。</p>\n<p>● 点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。</p>\n<p>● 如果调用的是router.replaceUrl，则当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear。上文已经提到，组件的销毁是从组件树上直接摘下子树，所以先调用父组件的aboutToDisappear，再调用子组件的aboutToDisappear，然后执行初始化新页面的生命周期流程。</p>\n<p>● 点击返回按钮，触发页面生命周期Index onBackPress，且触发返回一个页面后会导致当前Index页面被销毁。</p>\n<p>● 最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。</p>\n<p>● 退出应用，执行Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HarmonyOS开发—基础—自定义组件\"><a href=\"#HarmonyOS开发—基础—自定义组件\" class=\"headerlink\" title=\"HarmonyOS开发—基础—自定义组件\"></a>HarmonyOS开发—基础—自定义组件</h2><h2 id=\"一、创建自定义组件\"><a href=\"#一、创建自定义组件\" class=\"headerlink\" title=\"一、创建自定义组件\"></a>一、创建自定义组件</h2><p>在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。</p>\n<p>自定义组件具有以下特点：</p>\n<p>● 可组合：允许开发者组合使用系统组件、及其属性和方法。</p>\n<p>● 可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。</p>\n<p>● 数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。</p>\n<p>以下示例展示了自定义组件的基本用法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">HelloComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;Hello, World!&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// HelloComponent自定义组件组合系统组件Row和Text</span></span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">message</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 状态变量message的改变驱动UI刷新，UI从&#x27;Hello, World!&#x27;刷新为&#x27;Hello, ArkUI!&#x27;</span></span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;Hello, ArkUI!&#x27;</span>;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>HelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloComponentParam</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">param</span>: <span class=\"title class_\">HelloComponentParam</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello, World!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;ArkUI message&#x27;</span>)</span><br><span class=\"line\">      <span class=\"title class_\">HelloComponent</span>(param);</span><br><span class=\"line\">      <span class=\"title class_\">Divider</span>()</span><br><span class=\"line\">      <span class=\"title class_\">HelloComponent</span>(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\">自定义组件的基本结构</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F\">成员函数&#x2F;变量</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%84%E5%AE%9A\">自定义组件的参数规定</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#build%E5%87%BD%E6%95%B0\">build()函数</a></p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E9%80%9A%E7%94%A8%E6%A0%B7%E5%BC%8F\">自定义组件通用样式</a></p>\n<h3 id=\"1-1-自定义组件的基本结构\"><a href=\"#1-1-自定义组件的基本结构\" class=\"headerlink\" title=\"1.1 自定义组件的基本结构\"></a>1.1 自定义组件的基本结构</h3><p>● struct：自定义组件基于struct实现，struct + 自定义组件名 + {…}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。</p>\n<p>说明：自定义组件名、类名、函数名不能和系统组件名相同。</p>\n<p>● @Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。</p>\n<p>说明：从API version 9开始，该装饰器支持在ArkTS卡片中使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ● @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a>的参数。</p>\n<p>说明：</p>\n<p>从API version 9开始，该装饰器支持在ArkTS卡片中使用。</p>\n<p>从API version 10开始，@Entry可以接受一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a>的参数或者一个可选的<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-create-custom-components.md#entryOptions\">EntryOptions</a>参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>EntryOptions10+命名路由跳转选项。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>必填</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>routeName</td>\n<td>string</td>\n<td>否</td>\n<td>表示作为命名路由页面的名字。</td>\n</tr>\n<tr>\n<td>storage</td>\n<td><a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-localstorage.md\">LocalStorage</a></td>\n<td>否</td>\n<td>页面级的UI状态存储。</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span>(&#123; routeName : <span class=\"string\">&#x27;myPage&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● @Reusable：@Reusable装饰的自定义组件具备可复用能力</p>\n<p>说明：</p>\n<p>从API version 10开始，该装饰器支持在ArkTS卡片中使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reusable</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-成员函数-x2F-变量\"><a href=\"#1-2-成员函数-x2F-变量\" class=\"headerlink\" title=\"1.2 成员函数&#x2F;变量\"></a>1.2 成员函数&#x2F;变量</h3><p>自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：</p>\n<p>● 不支持静态函数。</p>\n<p>● 成员函数的访问始终是私有的。</p>\n<p>自定义组件可以包含成员变量，成员变量具有以下约束：</p>\n<p>● 不支持静态成员变量。</p>\n<p>● 所有成员变量都是私有的，变量的访问规则与成员函数的访问规则相同。</p>\n<p> ● 自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md\">状态管理</a>。</p>\n<h3 id=\"1-3-自定义组件的参数规定\"><a href=\"#1-3-自定义组件的参数规定\" class=\"headerlink\" title=\"1.3 自定义组件的参数规定\"></a>1.3 自定义组件的参数规定</h3><p>从上文的示例中，我们已经了解到，可以在build方法或者<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-builder.md\">@Builder</a>装饰的函数里创建自定义组件，在创建的过程中，参数可以被提供给组件。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">countDownFrom</span>: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">color</span>: <span class=\"title class_\">Color</span> = <span class=\"title class_\">Color</span>.<span class=\"property\">Blue</span>;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">someColor</span>: <span class=\"title class_\">Color</span> = <span class=\"title class_\">Color</span>.<span class=\"property\">Pink</span>;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor</span></span><br><span class=\"line\">      <span class=\"title class_\">MyComponent</span>(&#123; <span class=\"attr\">countDownFrom</span>: <span class=\"number\">10</span>, <span class=\"attr\">color</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">someColor</span> &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-build-函数\"><a href=\"#1-4-build-函数\" class=\"headerlink\" title=\"1.4 build()函数\"></a>1.4 build()函数</h3><p>所有声明在build()函数的语言，我们统称为UI描述语言，UI描述语言需要遵循以下规则：</p>\n<p>● @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根节点唯一且必要，必须为容器组件</span></span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">ChildComponent</span>() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根节点唯一且必要，可为非容器组件</span></span><br><span class=\"line\">    <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;test.jpg&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许声明本地变量，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许声明本地变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"built_in\">number</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"number\">1.2</span><span class=\"number\">.3</span><span class=\"number\">.4</span>.</span><br></pre></td></tr></table></figure>\n\n<p> ● <a href=\"http://不允许在ui描述里直接使用console.info/\">不允许在UI描述里直接使用console.info</a>，但允许在方法或者函数里使用，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许console.info</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;print debug log&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许创建本地的作用域，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反例：不允许本地作用域</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许调用除了被@Builder装饰以外的方法，允许系统组件的参数是TS方法的返回值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">doSomeCalculations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">calcTextValue</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello World&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Builder</span> <span class=\"title function_\">doSomeRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>(<span class=\"string\">`Hello World`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 反例：不能调用没有用@Builder装饰的方法</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">doSomeCalculations</span>();</span><br><span class=\"line\">      <span class=\"comment\">// 正例：可以调用</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">doSomeRender</span>();</span><br><span class=\"line\">      <span class=\"comment\">// 正例：参数可以为调用TS方法的返回值</span></span><br><span class=\"line\">      <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">calcTextValue</span>())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复制</p>\n<p>● 不允许使用switch语法，如果需要使用条件判断，请使用if。反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反例：不允许使用switch语法</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (expression) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">        <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>● 不允许使用表达式，反例如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反例：不允许使用表达式</span></span><br><span class=\"line\">    (<span class=\"variable language_\">this</span>.<span class=\"property\">aVar</span> &gt; <span class=\"number\">10</span>) ? <span class=\"title class_\">Text</span>(<span class=\"string\">&#x27;...&#x27;</span>) : <span class=\"title class_\">Image</span>(<span class=\"string\">&#x27;...&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-自定义组件通用样式\"><a href=\"#1-5-自定义组件通用样式\" class=\"headerlink\" title=\"1.5 自定义组件通用样式\"></a>1.5 自定义组件通用样式</h3><p>自定义组件通过“.”链式调用的形式设置通用样式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent2</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Button</span>(<span class=\"string\">`Hello World`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Row</span>() &#123;</span><br><span class=\"line\">      <span class=\"title class_\">MyComponent2</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">width</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">height</span>(<span class=\"number\">300</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">backgroundColor</span>(<span class=\"title class_\">Color</span>.<span class=\"property\">Red</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<p>ArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。</p>\n<h2 id=\"二、页面和自定义组件生命周期\"><a href=\"#二、页面和自定义组件生命周期\" class=\"headerlink\" title=\"二、页面和自定义组件生命周期\"></a>二、页面和自定义组件生命周期</h2><p>在开始之前，我们先明确自定义组件和页面的关系：</p>\n<p>● 自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。</p>\n<p>● 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。</p>\n<p>页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpageshow\">onPageShow</a>：页面每次显示时触发。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onpagehide\">onPageHide</a>：页面每次隐藏时触发一次。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#onbackpress\">onBackPress</a>：当用户点击返回按钮时触发。</p>\n<p>组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttoappear\">aboutToAppear</a>：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。</p>\n<p> ● <a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/reference/arkui-ts/ts-custom-component-lifecycle.md#abouttodisappear\">aboutToDisappear</a>：在自定义组件即将析构销毁时执行。</p>\n<p>生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（首页）生命周期。</p>\n<p><img src=\"http://image.jucaiwy.com/image/Harmony/Plugin/plugin-lifecycle.png\" alt=\"img\"></p>\n<p>根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。</p>\n<h3 id=\"2-1-自定义组件的创建和渲染流程\"><a href=\"#2-1-自定义组件的创建和渲染流程\" class=\"headerlink\" title=\"2.1 自定义组件的创建和渲染流程\"></a>2.1 自定义组件的创建和渲染流程</h3><ol>\n<li>自定义组件的创建：自定义组件的实例由ArkUI框架创建。</li>\n<li>初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。</li>\n<li>如果开发者定义了aboutToAppear，则执行aboutToAppear方法。</li>\n<li>在首次渲染的时候，执行build方法渲染系统组件，如果有自定义子组件，则创建自定义组件的实例。在执行build()函数的过程中，框架会观察每个状态变量的读取状态，将保存两个map：</li>\n</ol>\n<p>a. 状态变量 -&gt; UI组件（包括ForEach和if）。</p>\n<p>b. UI组件 -&gt; 此组件的更新函数，即一个lambda方法，作为build()函数的子集，创建对应的UI组件并执行其属性方法，示意如下。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeComponentCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Button</span>.<span class=\"title function_\">create</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">observeComponentCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>.<span class=\"title function_\">create</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当应用在后台启动时，此时应用进程并没有销毁，所以仅需要执行onPageShow。</p>\n<h3 id=\"2-2-自定义组件重新渲染\"><a href=\"#2-2-自定义组件重新渲染\" class=\"headerlink\" title=\"2.2 自定义组件重新渲染\"></a>2.2 自定义组件重新渲染</h3><p>当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage &#x2F; AppStorage中的属性更改，并导致绑定的状态变量更改其值时：</p>\n<ol>\n<li>框架观察到了变化，将启动重新渲染。</li>\n<li>根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。</li>\n</ol>\n<h3 id=\"2-3-自定义组件的删除\"><a href=\"#2-3-自定义组件的删除\" class=\"headerlink\" title=\"2.3 自定义组件的删除\"></a>2.3 自定义组件的删除</h3><p>如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：</p>\n<ol>\n<li><p>在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，当前端节点已经没有引用时，将被JS虚拟机垃圾回收。</p>\n</li>\n<li><p>自定义组件和它的变量将被删除，如果其有同步的变量，比如<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-link.md\">@Link</a>、<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-prop.md\">@Prop</a>、<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-appstorage.md#storagelink\">@StorageLink</a>，将从<a href=\"https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/arkts-state-management-overview.md#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">同步源</a>上取消注册。</p>\n</li>\n</ol>\n<p>不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。</p>\n<p>以下示例展示了生命周期的调用时机：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Index.ets</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@ohos.router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entry</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">showChild</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onPageShow</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onPageShow&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onPageHide</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onPageHide&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只有被@Entry装饰的组件才可以调用页面的生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">onBackPress</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;Index onBackPress&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToAppear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;MyComponent aboutToAppear&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToDisappear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;MyComponent aboutToDisappear&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Column</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// this.showChild为true，创建Child子组件，执行Child aboutToAppear</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">showChild</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Child</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// this.showChild为false，删除Child子组件，执行Child aboutToDisappear</span></span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;delete Child&#x27;</span>).<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">showChild</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"comment\">// push到Page2页面，执行onPageHide</span></span><br><span class=\"line\">      <span class=\"title class_\">Button</span>(<span class=\"string\">&#x27;push to next page&#x27;</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          router.<span class=\"title function_\">pushUrl</span>(&#123; <span class=\"attr\">url</span>: <span class=\"string\">&#x27;pages/Page2&#x27;</span> &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">struct <span class=\"title class_\">Child</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@State</span> <span class=\"attr\">title</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;Hello World&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToDisappear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;[lifeCycle] Child aboutToDisappear&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 组件生命周期</span></span><br><span class=\"line\">  <span class=\"title function_\">aboutToAppear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;[lifeCycle] Child aboutToAppear&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Text</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">title</span>).<span class=\"title function_\">fontSize</span>(<span class=\"number\">50</span>).<span class=\"title function_\">onClick</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = <span class=\"string\">&#x27;Hello ArkUI&#x27;</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以生效页面的生命周期方法，所以MyComponent中声明了当前Index页面的页面生命周期函数。MyComponent和其子组件Child也同时声明了组件的生命周期函数。</p>\n<p>● 应用冷启动的初始化流程为：MyComponent aboutToAppear –&gt; MyComponent build –&gt; Child aboutToAppear –&gt; Child build –&gt; Child build执行完毕 –&gt; MyComponent build执行完毕 –&gt; Index onPageShow。</p>\n<p>● 点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。</p>\n<p>● 点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。</p>\n<p>● 如果调用的是router.replaceUrl，则当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear。上文已经提到，组件的销毁是从组件树上直接摘下子树，所以先调用父组件的aboutToDisappear，再调用子组件的aboutToDisappear，然后执行初始化新页面的生命周期流程。</p>\n<p>● 点击返回按钮，触发页面生命周期Index onBackPress，且触发返回一个页面后会导致当前Index页面被销毁。</p>\n<p>● 最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。</p>\n<p>● 退出应用，执行Index onPageHide –&gt; MyComponent aboutToDisappear –&gt; Child aboutToDisappear。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl278jur80001b3t10a2vg87e","category_id":"cl278jurd0004b3t1ht3d438x","_id":"cl278jurj000eb3t17f8z61ul"},{"post_id":"cl278jurg0007b3t1du3h4zht","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurm000kb3t1dpnmgqzr"},{"post_id":"cl278jurj000db3t1gltw5j7t","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurn000nb3t1ekxzhfvg"},{"post_id":"cl278jurl000hb3t1eu2d8tob","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278juro000rb3t1dqen8zl5"},{"post_id":"cl278jurg0008b3t10hho5m3g","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurp000vb3t1h8nc5fsj"},{"post_id":"cl278jurl000ib3t13wnx2ilj","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurq000yb3t102eu6kcm"},{"post_id":"cl278jurn000mb3t1bx4vfxp6","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurr0012b3t1eyegc7rs"},{"post_id":"cl278jurh0009b3t1hctq2wak","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurs0015b3t17uxn2v7t"},{"post_id":"cl278juro000pb3t18ixn8wwj","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurs0018b3t1duij3b4p"},{"post_id":"cl278juri000cb3t17dorgxy9","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurt001bb3t14wx5fh90"},{"post_id":"cl278juri000cb3t17dorgxy9","category_id":"cl278juro000qb3t18bu5gl89","_id":"cl278jurt001db3t1dju0h47u"},{"post_id":"cl278jurp000xb3t14kfs891n","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278juru001gb3t1ehxyg4cq"},{"post_id":"cl278jurp000xb3t14kfs891n","category_id":"cl278juro000qb3t18bu5gl89","_id":"cl278jurv001ib3t16huxevtk"},{"post_id":"cl278jurq0010b3t136yrg4ur","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurw001lb3t15d88fx11"},{"post_id":"cl278jurr0014b3t1ethsfjqp","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurw001ob3t1hyjdazup"},{"post_id":"cl278jurp000ub3t14q8a9ltb","category_id":"cl278jurq000zb3t1bg803n4r","_id":"cl278jurx001tb3t16nab4ata"},{"post_id":"cl278jurs0017b3t16sly86sy","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jury001wb3t13x1rdevp"},{"post_id":"cl278jurs001ab3t1gzhof7wx","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurz0020b3t1bou6478j"},{"post_id":"cl278jurt001cb3t1339f4usa","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurz0022b3t180zu6wvc"},{"post_id":"cl278juru001fb3t1eu0d1kfo","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jurz0025b3t1f5tm6t0c"},{"post_id":"cl278juru001hb3t1644q7z4k","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jus00027b3t1gvlv9atw"},{"post_id":"cl278jurw001nb3t1a8te5k7v","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jus00028b3t1fpcn4d32"},{"post_id":"cl278jurw001nb3t1a8te5k7v","category_id":"cl278juro000qb3t18bu5gl89","_id":"cl278jus0002cb3t10w5x3q91"},{"post_id":"cl278jurv001kb3t1212t7t7h","category_id":"cl278juri000ab3t19zg9fsvh","_id":"cl278jus1002eb3t177axcapy"},{"post_id":"cl278jurv001kb3t1212t7t7h","category_id":"cl278jurx001sb3t19a5vhpl2","_id":"cl278jus1002gb3t14dgsgsua"},{"post_id":"cl278jurx001rb3t11agz5uev","category_id":"cl278jurz001zb3t14jxfayeu","_id":"cl278jus1002hb3t1cy5z9b1j"},{"post_id":"cl278jurx001vb3t1ebxm6sqc","category_id":"cl278jus00026b3t1hs282ncp","_id":"cl278jus1002kb3t1asgxa2xf"},{"post_id":"clyfsx01a00010nv6dd8n37ld","category_id":"cl278jus00026b3t1hs282ncp","_id":"clyfsx01m00090nv65tzt5gkn"},{"post_id":"clyfsx01k00060nv6fe01fxxr","category_id":"clyfsx01c00020nv6gbm2952p","_id":"clyfsx01o000e0nv6b1mv9jzu"},{"post_id":"clyfsx01600000nv64iy2f8v5","category_id":"clyfsx01c00020nv6gbm2952p","_id":"clyfsx01o000g0nv651ow5hc1"},{"post_id":"clyfsx01m00080nv6cxks0lpe","category_id":"clyfsx01c00020nv6gbm2952p","_id":"clyfsx01p000i0nv69pukdwln"},{"post_id":"clyfsx01n000c0nv61o103566","category_id":"clyfsx01c00020nv6gbm2952p","_id":"clyfsx01p000l0nv64a0ebgm2"},{"post_id":"clyfsx01t000t0nv60cw9g9x4","category_id":"clyfsx01c00020nv6gbm2952p","_id":"clyfsx01u000w0nv63r3ae0ll"}],"PostTag":[{"post_id":"cl278jur80001b3t10a2vg87e","tag_id":"cl278jurf0005b3t1dscb8xhh","_id":"cl278jurn000ob3t1gnqv4lyn"},{"post_id":"cl278jur80001b3t10a2vg87e","tag_id":"cl278juri000bb3t187l7hvtr","_id":"cl278juro000sb3t192qp8e43"},{"post_id":"cl278jur80001b3t10a2vg87e","tag_id":"cl278jurk000gb3t165tz130x","_id":"cl278jurp000wb3t1d3dd49ic"},{"post_id":"cl278jurc0003b3t11wt5hzux","tag_id":"cl278jurm000lb3t1hjc930ol","_id":"cl278jurr0013b3t1bfqv4oza"},{"post_id":"cl278jurc0003b3t11wt5hzux","tag_id":"cl278juro000tb3t19bd9bzqg","_id":"cl278jurs0016b3t1gpro0auv"},{"post_id":"cl278jurg0007b3t1du3h4zht","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jurw001mb3t11e7k95eu"},{"post_id":"cl278jurg0007b3t1du3h4zht","tag_id":"cl278jurs0019b3t124u5ao1f","_id":"cl278jurw001pb3t15wjj04mf"},{"post_id":"cl278jurg0007b3t1du3h4zht","tag_id":"cl278jurt001eb3t12qlk3nh6","_id":"cl278jurx001ub3t1fk9ucfuk"},{"post_id":"cl278jurg0008b3t10hho5m3g","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jurz0021b3t14rhdgsmd"},{"post_id":"cl278jurg0008b3t10hho5m3g","tag_id":"cl278jurw001qb3t1anxrfoxx","_id":"cl278jurz0023b3t1hay6825q"},{"post_id":"cl278jurh0009b3t1hctq2wak","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus0002bb3t1a94og8j9"},{"post_id":"cl278jurh0009b3t1hctq2wak","tag_id":"cl278jurz0024b3t18k0t6772","_id":"cl278jus0002db3t1bwnn7tyr"},{"post_id":"cl278juri000cb3t17dorgxy9","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus1002jb3t146rwa56h"},{"post_id":"cl278juri000cb3t17dorgxy9","tag_id":"cl278juro000tb3t19bd9bzqg","_id":"cl278jus1002lb3t14xcp6lwh"},{"post_id":"cl278jurj000db3t1gltw5j7t","tag_id":"cl278jus1002ib3t19hh75yhg","_id":"cl278jus2002qb3t1h5493i3x"},{"post_id":"cl278jurj000db3t1gltw5j7t","tag_id":"cl278jus1002nb3t15xvb0vsp","_id":"cl278jus2002rb3t16k963ras"},{"post_id":"cl278jurj000db3t1gltw5j7t","tag_id":"cl278jus2002ob3t1d90qhb8c","_id":"cl278jus2002tb3t14wlz0ij9"},{"post_id":"cl278jurl000hb3t1eu2d8tob","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus3002wb3t1gv9agt6x"},{"post_id":"cl278jurl000hb3t1eu2d8tob","tag_id":"cl278jus2002sb3t1g3r508lc","_id":"cl278jus3002xb3t135mb1w2j"},{"post_id":"cl278jurl000hb3t1eu2d8tob","tag_id":"cl278jus2002ub3t17ywt9rgk","_id":"cl278jus3002zb3t1e99zfz5u"},{"post_id":"cl278jurl000ib3t13wnx2ilj","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus40032b3t1amvf5513"},{"post_id":"cl278jurl000ib3t13wnx2ilj","tag_id":"cl278jus3002yb3t15ebjc0yn","_id":"cl278jus40033b3t1gso84bv4"},{"post_id":"cl278jurl000ib3t13wnx2ilj","tag_id":"cl278jus30030b3t1eohce0h6","_id":"cl278jus40035b3t15cflcd0k"},{"post_id":"cl278jurn000mb3t1bx4vfxp6","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus50039b3t1743p450n"},{"post_id":"cl278jurn000mb3t1bx4vfxp6","tag_id":"cl278jurs0019b3t124u5ao1f","_id":"cl278jus5003ab3t1c9y0cso4"},{"post_id":"cl278jurn000mb3t1bx4vfxp6","tag_id":"cl278jus40036b3t1ctwq3ckl","_id":"cl278jus5003cb3t1eprb21z3"},{"post_id":"cl278jurn000mb3t1bx4vfxp6","tag_id":"cl278jus40037b3t104oc6iwa","_id":"cl278jus5003db3t1awwr1nof"},{"post_id":"cl278juro000pb3t18ixn8wwj","tag_id":"cl278jus40038b3t19rkw3s0o","_id":"cl278jus5003fb3t124sve43w"},{"post_id":"cl278juro000pb3t18ixn8wwj","tag_id":"cl278jus5003bb3t1fdd02rc9","_id":"cl278jus5003gb3t115pw2cs5"},{"post_id":"cl278jurp000ub3t14q8a9ltb","tag_id":"cl278jus5003eb3t1aauw3c6s","_id":"cl278jus6003kb3t1f6pe1ej8"},{"post_id":"cl278jurp000ub3t14q8a9ltb","tag_id":"cl278jus5003hb3t1hkfj9opn","_id":"cl278jus6003lb3t1277qeheh"},{"post_id":"cl278jurp000ub3t14q8a9ltb","tag_id":"cl278jus5003ib3t18li1hesz","_id":"cl278jus6003nb3t1596bawma"},{"post_id":"cl278jurp000xb3t14kfs891n","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus7003pb3t167jyauvv"},{"post_id":"cl278jurp000xb3t14kfs891n","tag_id":"cl278jus6003mb3t1bqq0hcdj","_id":"cl278jus7003qb3t11l7idz2f"},{"post_id":"cl278jurq0010b3t136yrg4ur","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus7003tb3t1dths7l49"},{"post_id":"cl278jurq0010b3t136yrg4ur","tag_id":"cl278jus7003rb3t12v8ubweh","_id":"cl278jus7003ub3t1gaii6fx3"},{"post_id":"cl278jurr0014b3t1ethsfjqp","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus7003wb3t1ce1i6pf4"},{"post_id":"cl278jurr0014b3t1ethsfjqp","tag_id":"cl278jus7003sb3t15ib3an3k","_id":"cl278jus7003xb3t1gjmm3ban"},{"post_id":"cl278jurs0017b3t16sly86sy","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus8003zb3t1gnmy5x3y"},{"post_id":"cl278jurs0017b3t16sly86sy","tag_id":"cl278jus7003vb3t10joi32jb","_id":"cl278jus80040b3t1fr52d1lv"},{"post_id":"cl278jurs001ab3t1gzhof7wx","tag_id":"cl278jus7003yb3t12isl995j","_id":"cl278jus80043b3t15i8gaqzn"},{"post_id":"cl278jurs001ab3t1gzhof7wx","tag_id":"cl278jus80041b3t1gehl20af","_id":"cl278jus80044b3t15su8hdmk"},{"post_id":"cl278jurt001cb3t1339f4usa","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus90047b3t1690cdp90"},{"post_id":"cl278jurt001cb3t1339f4usa","tag_id":"cl278jus80042b3t1hsnbftu7","_id":"cl278jus90048b3t1bkx55scb"},{"post_id":"cl278jurt001cb3t1339f4usa","tag_id":"cl278jus80045b3t1dy0sg2wh","_id":"cl278jus9004ab3t16n6rhvf0"},{"post_id":"cl278juru001fb3t1eu0d1kfo","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jus9004cb3t16o5ihe9s"},{"post_id":"cl278juru001fb3t1eu0d1kfo","tag_id":"cl278jus80042b3t1hsnbftu7","_id":"cl278jus9004db3t17nhh6jtr"},{"post_id":"cl278juru001fb3t1eu0d1kfo","tag_id":"cl278jus90049b3t1cy472lp3","_id":"cl278jus9004fb3t18i8q03a6"},{"post_id":"cl278juru001hb3t1644q7z4k","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jusa004hb3t14f3dgdwn"},{"post_id":"cl278juru001hb3t1644q7z4k","tag_id":"cl278jus9004bb3t1fnfianyd","_id":"cl278jusa004ib3t15wd2hyyb"},{"post_id":"cl278juru001hb3t1644q7z4k","tag_id":"cl278jus9004eb3t1df2r3h3t","_id":"cl278jusa004kb3t15ulvgkgl"},{"post_id":"cl278jurv001kb3t1212t7t7h","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jusb004nb3t15eze7vv6"},{"post_id":"cl278jurv001kb3t1212t7t7h","tag_id":"cl278jusa004gb3t1ccrq8azs","_id":"cl278jusb004ob3t13t01cbqy"},{"post_id":"cl278jurv001kb3t1212t7t7h","tag_id":"cl278jusa004jb3t1910e2xqp","_id":"cl278jusb004qb3t1e89t62uy"},{"post_id":"cl278jurv001kb3t1212t7t7h","tag_id":"cl278jusa004lb3t1g0359bks","_id":"cl278jusb004rb3t1gksicabu"},{"post_id":"cl278jurw001nb3t1a8te5k7v","tag_id":"cl278jurr0011b3t17cyf4uyk","_id":"cl278jusb004tb3t1dy87078i"},{"post_id":"cl278jurw001nb3t1a8te5k7v","tag_id":"cl278jusa004gb3t1ccrq8azs","_id":"cl278jusb004ub3t178nahfpf"},{"post_id":"cl278jurx001rb3t11agz5uev","tag_id":"cl278jusb004pb3t1dfw6fvtn","_id":"cl278jusc004wb3t15cdgekw5"},{"post_id":"cl278jurx001rb3t11agz5uev","tag_id":"cl278jusb004sb3t10bvc8i2k","_id":"cl278jusc004xb3t16d1ph928"},{"post_id":"cl278jurx001vb3t1ebxm6sqc","tag_id":"cl278jusb004vb3t19jfe02q5","_id":"cl278jusc0051b3t1ejx0c5lt"},{"post_id":"cl278jurx001vb3t1ebxm6sqc","tag_id":"cl278jusc004yb3t16fjb2kcg","_id":"cl278jusc0052b3t122c4doci"},{"post_id":"cl278jurx001vb3t1ebxm6sqc","tag_id":"cl278jusc004zb3t1fdrthc0m","_id":"cl278jusd0054b3t1gwnbgqwz"},{"post_id":"clyfsx01a00010nv6dd8n37ld","tag_id":"cl278jusb004vb3t19jfe02q5","_id":"clyfsx01k00050nv69qb90132"},{"post_id":"clyfsx01a00010nv6dd8n37ld","tag_id":"cl278jusc0053b3t1daophyxi","_id":"clyfsx01l00070nv6bt86cdfz"},{"post_id":"clyfsx01a00010nv6dd8n37ld","tag_id":"cl278jusd0055b3t1gpr36j83","_id":"clyfsx01n000b0nv652zbgy70"},{"post_id":"clyfsx01a00010nv6dd8n37ld","tag_id":"cl278jusd0056b3t13sjh3olw","_id":"clyfsx01o000d0nv6hhu70czp"},{"post_id":"clyfsx01600000nv64iy2f8v5","tag_id":"clyfsx01h00030nv61skjfgcd","_id":"clyfsx01o000h0nv62l0556rf"},{"post_id":"clyfsx01600000nv64iy2f8v5","tag_id":"clyfsx01m000a0nv6e2st8scc","_id":"clyfsx01p000j0nv638onhy3j"},{"post_id":"clyfsx01k00060nv6fe01fxxr","tag_id":"clyfsx01h00030nv61skjfgcd","_id":"clyfsx01p000m0nv628a31p65"},{"post_id":"clyfsx01k00060nv6fe01fxxr","tag_id":"clyfsx01o000f0nv6h13d9d1j","_id":"clyfsx01p000n0nv6bjx13vmy"},{"post_id":"clyfsx01m00080nv6cxks0lpe","tag_id":"clyfsx01h00030nv61skjfgcd","_id":"clyfsx01p000p0nv64b5s6a34"},{"post_id":"clyfsx01m00080nv6cxks0lpe","tag_id":"clyfsx01p000k0nv6by9u0gqd","_id":"clyfsx01p000q0nv6em3ocrz0"},{"post_id":"clyfsx01n000c0nv61o103566","tag_id":"clyfsx01h00030nv61skjfgcd","_id":"clyfsx01q000r0nv6esby8euz"},{"post_id":"clyfsx01n000c0nv61o103566","tag_id":"clyfsx01p000o0nv65vgh1j0l","_id":"clyfsx01q000s0nv62fb8awhi"},{"post_id":"clyfsx01t000t0nv60cw9g9x4","tag_id":"clyfsx01h00030nv61skjfgcd","_id":"clyfsx01t000u0nv62m1u24cl"},{"post_id":"clyfsx01t000t0nv60cw9g9x4","tag_id":"clyfsx01p000k0nv6by9u0gqd","_id":"clyfsx01u000v0nv61kdv3iga"}],"Tag":[{"name":"FastDFS","_id":"cl278jurf0005b3t1dscb8xhh"},{"name":"Linux","_id":"cl278juri000bb3t187l7hvtr"},{"name":"数据存储","_id":"cl278jurk000gb3t165tz130x"},{"name":"String.xml空格","_id":"cl278jurm000lb3t1hjc930ol"},{"name":"问题记录","_id":"cl278juro000tb3t19bd9bzqg"},{"name":"Android","_id":"cl278jurr0011b3t17cyf4uyk"},{"name":"OCR","_id":"cl278jurs0019b3t124u5ao1f"},{"name":"图像识别","_id":"cl278jurt001eb3t12qlk3nh6"},{"name":"LogcatUtil","_id":"cl278jurw001qb3t1anxrfoxx"},{"name":"FindBugs","_id":"cl278jurz0024b3t18k0t6772"},{"name":"Android笔记","_id":"cl278jus1002ib3t19hh75yhg"},{"name":"横竖屏切换","_id":"cl278jus1002nb3t15xvb0vsp"},{"name":"生命周期","_id":"cl278jus2002ob3t1d90qhb8c"},{"name":"SQLite数据库","_id":"cl278jus2002sb3t1g3r508lc"},{"name":"数据库性能","_id":"cl278jus2002ub3t17ywt9rgk"},{"name":"EventBus","_id":"cl278jus3002yb3t15ebjc0yn"},{"name":"观察者模式","_id":"cl278jus30030b3t1eohce0h6"},{"name":"Tess-Two","_id":"cl278jus40036b3t1ctwq3ckl"},{"name":"Tesseract","_id":"cl278jus40037b3t104oc6iwa"},{"name":"Bouncycast","_id":"cl278jus40038b3t19rkw3s0o"},{"name":"Https证书生成","_id":"cl278jus5003bb3t1fdd02rc9"},{"name":"Https","_id":"cl278jus5003eb3t1aauw3c6s"},{"name":"Https单向认证","_id":"cl278jus5003hb3t1hkfj9opn"},{"name":"Https双向认证","_id":"cl278jus5003ib3t18li1hesz"},{"name":"HTTP","_id":"cl278jus6003mb3t1bqq0hcdj"},{"name":"Protobuf","_id":"cl278jus7003rb3t12v8ubweh"},{"name":"Eclipse","_id":"cl278jus7003sb3t15ib3an3k"},{"name":"CRC","_id":"cl278jus7003vb3t10joi32jb"},{"name":"App更新","_id":"cl278jus7003yb3t12isl995j"},{"name":"Google更新","_id":"cl278jus80041b3t1gehl20af"},{"name":"自动化测试","_id":"cl278jus80042b3t1hsnbftu7"},{"name":"Monkey","_id":"cl278jus80045b3t1dy0sg2wh"},{"name":"MonkeyRunner","_id":"cl278jus90049b3t1cy472lp3"},{"name":"斗地主","_id":"cl278jus9004bb3t1fnfianyd"},{"name":"算法","_id":"cl278jus9004eb3t1df2r3h3t"},{"name":"IJKPlayer","_id":"cl278jusa004gb3t1ccrq8azs"},{"name":"IOS11图片格式","_id":"cl278jusa004jb3t1910e2xqp"},{"name":"图片存储","_id":"cl278jusa004lb3t1g0359bks"},{"name":"ReactNative","_id":"cl278jusb004pb3t1dfw6fvtn"},{"name":"集成RN","_id":"cl278jusb004sb3t10bvc8i2k"},{"name":"Flutter","_id":"cl278jusb004vb3t19jfe02q5"},{"name":"Json","_id":"cl278jusc004yb3t16fjb2kcg"},{"name":"序列化和反序列化","_id":"cl278jusc004zb3t1fdrthc0m"},{"name":"状态管理","_id":"cl278jusc0053b3t1daophyxi"},{"name":"Provider","_id":"cl278jusd0055b3t1gpr36j83"},{"name":"Stream","_id":"cl278jusd0056b3t13sjh3olw"},{"name":"HarmonyOS开发","_id":"clyfsx01h00030nv61skjfgcd"},{"name":"环境搭建","_id":"clyfsx01m000a0nv6e2st8scc"},{"name":"UIAbility","_id":"clyfsx01o000f0nv6h13d9d1j"},{"name":"自定义组件","_id":"clyfsx01p000k0nv6by9u0gqd"},{"name":"ArkTS语言介绍","_id":"clyfsx01p000o0nv65vgh1j0l"}]}}